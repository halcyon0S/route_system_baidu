<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç½‘ç‚¹è·¯çº¿ä¼˜åŒ–ç³»ç»Ÿï¼ˆç™¾åº¦åœ°å›¾ç‰ˆï¼‰</title>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: "Microsoft YaHei", "PingFang SC", Arial, sans-serif; }
    #container { width: 100%; height: 100vh; }
    #control-panel {
      position: absolute; top: 20px; left: 20px; background: white;
      padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      max-width: 380px; z-index: 1000; max-height: 85vh; overflow-y: auto;
    }
    h2 { margin-bottom: 15px; color: #333; font-size: 18px; }
    .input-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; font-size: 13px; }
    textarea, input[type="text"], input[type="file"] {
      width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;
      font-size: 12px; font-family: inherit;
    }
    textarea { resize: vertical; }
    input[type="file"] { padding: 8px; }
    .btn {
      padding: 10px 20px; margin: 5px 5px 5px 0; border: none; border-radius: 5px;
      cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s;
    }
    .btn-primary { background: #3366FF; color: white; }
    .btn-primary:hover { background: #2850CC; }
    .btn-success { background: #4CAF50; color: white; }
    .btn-success:hover { background: #388E3C; }
    .btn-clear { background: #9E9E9E; color: white; }
    .btn-clear:hover { background: #757575; }
    .btn-screenshot { background: #FF9800; color: white; }
    .btn-screenshot:hover { background: #F57C00; }
    #route-info { margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 5px; font-size: 13px; }
    .route-item { padding: 8px; margin: 5px 0; background: white; border-left: 4px solid #3366FF; border-radius: 3px; }
    .distance-info { color: #FF5722; font-weight: bold; }
    .loading { text-align: center; color: #666; padding: 10px; }
    .error-box {
      background: #FFEBEE; padding: 10px; border-radius: 5px; margin-top: 10px;
      font-size: 12px; color: #C62828; border-left: 4px solid #F44336;
    }
    .tabs { display: flex; margin-bottom: 15px; border-bottom: 2px solid #ddd; }
    .tab {
      padding: 10px 20px; cursor: pointer; border: none; background: none;
      font-size: 14px; color: #666; transition: all 0.3s;
    }
    .tab.active { color: #3366FF; border-bottom: 3px solid #3366FF; margin-bottom: -2px; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .excel-template {
      background: #E3F2FD; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 12px;
    }
    .excel-template code { background: white; padding: 2px 6px; border-radius: 3px; font-family: monospace; }

    /* marker åœ†ç‚¹æ ·å¼ï¼ˆç”¨DOMå åŠ ï¼Œä¿æŒä½ åŸå…ˆâ€œç¼–å·åœ†ç‚¹â€é£æ ¼ï¼‰ */
    .num-marker {
      width: 35px; height: 35px; border-radius: 50%;
      color: white; display: flex; align-items: center; justify-content: center;
      font-weight: bold; font-size: 16px;
      border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }

    /* è‡ªå®šä¹‰æ¨¡æ€å¯¹è¯æ¡†æ ·å¼ */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .modal-dialog {
      background: white;
      border-radius: 12px;
      padding: 30px 40px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      min-width: 320px;
      text-align: center;
    }

    .modal-title {
      font-size: 18px;
      font-weight: bold;
      color: #333;
      margin-bottom: 25px;
    }

    .modal-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
    }

    .modal-btn {
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 120px;
    }

    .modal-btn-detail {
      background: #F44336;
      color: white;
    }

    .modal-btn-detail:hover {
      background: #D32F2F;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
    }

    .modal-btn-simple {
      background: #4CAF50;
      color: white;
    }

    .modal-btn-simple:hover {
      background: #388E3C;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }
  </style>
</head>

<body>
  <div id="control-panel">
    <h2>ğŸ“ ç½‘ç‚¹è·¯çº¿ä¼˜åŒ–ç³»ç»Ÿï¼ˆç™¾åº¦åœ°å›¾ï¼‰</h2>

    <div class="tabs">
      <button class="tab active" onclick="switchTab('excel')">ğŸ“Š Excelå¯¼å…¥</button>
      <button class="tab" onclick="switchTab('manual')">âœï¸ æ‰‹åŠ¨è¾“å…¥</button>
    </div>

    <div id="excel-tab" class="tab-content active">
      <div class="excel-template">
        <strong>ğŸ“‹ Excelæ ¼å¼è¦æ±‚ï¼š</strong><br>
        åˆ—åï¼š<code>ç»åº¦</code> <code>çº¬åº¦</code> <code>ç½‘ç‚¹åç§°</code> <code>å¤‡æ³¨(å¯é€‰)</code> <code>ç½‘ç»„(å¯é€‰)</code> <code>å·¥å·(å¯é€‰)</code> <code>å§“å(å¯é€‰)</code> <code>å¿åŒº(å¯é€‰)</code> <code>è°ƒæ•´(å¯é€‰)</code><br>
        <small style="color: #666;">æ”¯æŒæ‰¹é‡å¯¼å…¥ï¼šé¦–å…ˆæŒ‰"è°ƒæ•´"å­—æ®µåˆ†ç»„ï¼ˆè°ƒæ•´å‰/è°ƒæ•´åï¼‰ï¼Œç„¶ååœ¨åŒå­—æ®µä¸‹æŒ‰å·¥å·ã€ç½‘ç»„åˆ†ç»„å¤„ç†ï¼›å¦‚æœ‰å¿åŒºå­—æ®µï¼Œç”¨äºç»˜åˆ¶è¡Œæ”¿åŒºåˆ’è¾¹ç•Œ</small>
      </div>

      <div class="input-group">
        <label>é€‰æ‹©Excelæ–‡ä»¶</label>
        <input type="file" id="excelFile" accept=".xlsx,.xls" onchange="handleExcelUpload()">
      </div>
      
      <div class="input-group" id="batchProcessSection" style="display: none;">
        <button class="btn btn-success" onclick="startBatchProcess()" style="width: 100%;">
          ğŸ”„ æ‰¹é‡å¤„ç†ï¼ˆæŒ‰ç½‘ç»„ï¼‰
        </button>
      </div>
    </div>

    <div id="manual-tab" class="tab-content">
      <div class="input-group">
        <label>ç½‘ç‚¹æ•°æ®ï¼ˆæ ¼å¼ï¼šç»åº¦,çº¬åº¦,åç§°,å¤‡æ³¨å¯é€‰,ç½‘ç»„å¯é€‰,å·¥å·å¯é€‰,å§“åå¯é€‰,å¿åŒºå¯é€‰,è°ƒæ•´å¯é€‰ï¼‰</label>
        <textarea id="locationInput" rows="8"
          placeholder="116.397428,39.90923,åŒ—äº¬è¥ä¸šéƒ¨,å¤‡æ³¨A
116.404,39.915,æœé˜³æ”¯è¡Œ
116.326,39.989,æµ·æ·€æ”¯è¡Œ,é‡ç‚¹æ‹œè®¿">116.397428,39.90923,åŒ—äº¬è¥ä¸šéƒ¨,èµ·ç‚¹
116.404,39.915,æœé˜³æ”¯è¡Œ
116.326,39.989,æµ·æ·€æ”¯è¡Œ,é‡ç‚¹æ‹œè®¿
116.368,39.867,ä¸°å°æ”¯è¡Œ
116.481,39.990,é¡ºä¹‰æ”¯è¡Œ
        </textarea>
      </div>
    </div>

    <div class="input-group">
      <label>èµ·å§‹ç½‘ç‚¹ï¼ˆå¯é€‰ï¼šå¡«â€œç½‘ç‚¹åç§°â€åŒ¹é…ï¼‰</label>
      <input type="text" id="startPoint" placeholder="ç•™ç©ºåˆ™é»˜è®¤ä½¿ç”¨ç¬¬1è¡Œä½œä¸ºèµ·ç‚¹ï¼ˆä¼˜åŒ–æ—¶ä¹Ÿå¯è‡ªåŠ¨ï¼‰">
    </div>

    <div>
      <button class="btn btn-primary" onclick="optimizeRoute()">ğŸ”„ ä¼˜åŒ–è·¯çº¿</button>
      <button class="btn btn-success" onclick="calculateRoute()">ğŸ“ æŒ‰åºè®¡ç®—</button>
      <button class="btn btn-clear" onclick="clearMap()">ğŸ—‘ï¸ æ¸…é™¤</button>
    </div>

    <!-- æ‰‹åŠ¨æˆªå›¾æŒ‰é’® -->
    <div style="margin-top: 10px;">
      <button class="btn btn-screenshot" onclick="manualCaptureScreenshot()" style="width: 100%;">
        ğŸ“¸ æ‰‹åŠ¨æˆªå›¾
      </button>
    </div>

    <!-- çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸï¼ˆå›ºå®šä½ç½®ï¼Œæ˜¾ç¤ºè®¡ç®—è·¯çº¿ã€æˆªå›¾ç­‰çŠ¶æ€ï¼‰ -->
    <div id="status-info" style="margin-top: 10px; min-height: 40px; padding: 8px; background: #f5f5f5; border-radius: 5px; font-size: 12px; color: #666; text-align: center;">
      <div id="status-text">å°±ç»ª</div>
    </div>

    <!-- âœ… æœ€è¿œçº¿å¼€å…³ -->
    <div style="margin-top:10px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleFarthest" checked onchange="toggleFarthestLine()">
        æ˜¾ç¤ºæœ€è¿œä¸¤ç‚¹ç›´çº¿ï¼ˆç»¿è‰²ï¼‰
      </label>
    </div>

    <!-- âœ… è·ç¦»æ ‡ç­¾å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleDistanceLabels" checked onchange="toggleDistanceLabels()">
        æ˜¾ç¤ºè·¯çº¿è·ç¦»æ ‡ç­¾ï¼ˆé»„è‰²ï¼‰
      </label>
    </div>

    <!-- âœ… è·¯çº¿ç®€ç‰ˆå¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleRouteSimple" onchange="toggleRouteSimple()">
        è·¯çº¿ç®€ç‰ˆ
      </label>
    </div>

    <!-- âœ… è¡Œæ”¿åŒºå›¾å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleDistrictMap" checked onchange="toggleDistrictMap()">
        è¡Œæ”¿åŒºå›¾
      </label>
    </div>

    <div id="route-info"></div>
  </div>

  <div id="container"></div>

  <!-- é…ç½®æ–‡ä»¶ï¼šä¼˜å…ˆåŠ è½½config-custom.jsï¼Œå¦‚æœæ²¡æœ‰åˆ™åŠ è½½static/config.js -->
  <script>
    // æå‰å®šä¹‰ showError å‡½æ•°ï¼Œä¾›åŠ è½½è„šæœ¬ä½¿ç”¨
    function showError(message) {
      const routeInfo = document.getElementById('route-info');
      if (routeInfo) {
        routeInfo.innerHTML = '<div class="error-box">âŒ ' + message + '</div>';
      } else {
        alert('é”™è¯¯ï¼š' + message);
      }
    }

    (function () {
      // ä¼˜å…ˆå°è¯•åŠ è½½config-custom.jsï¼ˆæ‰“åŒ…åä½äºexeåŒç›®å½•ï¼‰
      // å¦‚æœå¤±è´¥ï¼Œåˆ™åŠ è½½static/config.js
      let configLoaded = false;
      
      // å°è¯•åŠ è½½config-custom.js
      const customConfigScript = document.createElement("script");
      customConfigScript.src = "/config-custom.js";
      customConfigScript.onload = function() {
        console.log("[é…ç½®] æˆåŠŸåŠ è½½ config-custom.js");
        configLoaded = true;
        loadBaiduMap();
      };
      customConfigScript.onerror = function() {
        console.log("[é…ç½®] config-custom.js ä¸å­˜åœ¨ï¼Œå°è¯•åŠ è½½ static/config.js");
        // å¦‚æœconfig-custom.jsä¸å­˜åœ¨ï¼ŒåŠ è½½static/config.js
        const defaultConfigScript = document.createElement("script");
        defaultConfigScript.src = "/static/config.js";
        defaultConfigScript.onload = function() {
          console.log("[é…ç½®] æˆåŠŸåŠ è½½ static/config.js");
          configLoaded = true;
          loadBaiduMap();
        };
        defaultConfigScript.onerror = function() {
          showError("é…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ config-custom.js æˆ– static/config.js æ˜¯å¦å­˜åœ¨");
        };
        document.head.appendChild(defaultConfigScript);
      };
      document.head.appendChild(customConfigScript);
      
      function loadBaiduMap() {
        function waitForConfig(callback, maxAttempts = 50) {
          if (window.BMAP_CONFIG) {
            callback();
            return;
          }
          if (maxAttempts <= 0) {
            showError("é…ç½®æ–‡ä»¶åŠ è½½è¶…æ—¶ï¼è¯·æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨");
            return;
          }
          setTimeout(() => waitForConfig(callback, maxAttempts - 1), 100);
        }

        waitForConfig(function() {
          const ak = window.BMAP_CONFIG.jsAk;
          if (!ak || ak.includes("æ›¿æ¢")) {
            showError("âš ï¸ è¯·åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½®æœ‰æ•ˆçš„ jsAk");
            console.warn("âš ï¸ è¯·åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½® jsAk");
            return;
          }

          const script = document.createElement("script");
          script.src = "https://api.map.baidu.com/api?v=3.0&ak=" + encodeURIComponent(ak) + "&callback=baiduMapInit";
          script.onerror = function () {
            showError("ç™¾åº¦åœ°å›¾JSåŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š<br>1. jsAkæ˜¯å¦æ­£ç¡®<br>2. åŸŸåç™½åå•/Refereré™åˆ¶<br>3. ç½‘ç»œæ˜¯å¦æ­£å¸¸<br>4. æµè§ˆå™¨æ§åˆ¶å°æ˜¯å¦æœ‰è¯¦ç»†é”™è¯¯ä¿¡æ¯");
          };
          document.head.appendChild(script);
        });
      }
    })();
  </script>

  <script>
    let map;
    let markers = [];
    let overlays = []; // label / polyline / è‡ªå®šä¹‰overlay
    let currentLocations = []; // Excelå¯¼å…¥ç»“æœ

    // âœ… æœ€è¿œçº¿ï¼šå¯å¼€å…³å¯¹è±¡å¼•ç”¨
    let farthestLineOverlay = null;
    let farthestLabelOverlay = null;
    let farthestVisible = true;

    // âœ… è·ç¦»æ ‡ç­¾ï¼šå¯å¼€å…³å¯¹è±¡å¼•ç”¨
    let distanceLabels = [];  // ä¿å­˜æ‰€æœ‰è·ç¦»æ ‡ç­¾å¼•ç”¨
    let distanceLabelsVisible = true;  // è·ç¦»æ ‡ç­¾æ˜¾ç¤ºçŠ¶æ€

    function toggleFarthestLine() {
      farthestVisible = document.getElementById('toggleFarthest')?.checked ?? true;
      console.log('åˆ‡æ¢æœ€è¿œè¿çº¿æ˜¾ç¤ºçŠ¶æ€:', farthestVisible);

      if (farthestLineOverlay) {
        if (typeof farthestLineOverlay.setVisible === 'function') {
          farthestLineOverlay.setVisible(farthestVisible);
        } else {
          // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
          try {
            if (!farthestVisible) {
              map.removeOverlay(farthestLineOverlay);
            } else {
              map.addOverlay(farthestLineOverlay);
            }
          } catch(e) {
            console.warn('åˆ‡æ¢æœ€è¿œè¿çº¿æ˜¾ç¤ºå¤±è´¥:', e);
          }
        }
      }

      if (farthestLabelOverlay) {
        if (typeof farthestLabelOverlay.setVisible === 'function') {
          farthestLabelOverlay.setVisible(farthestVisible);
        } else {
          // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
          try {
            if (!farthestVisible) {
              map.removeOverlay(farthestLabelOverlay);
            } else {
              map.addOverlay(farthestLabelOverlay);
            }
          } catch(e) {
            console.warn('åˆ‡æ¢æœ€è¿œæ ‡ç­¾æ˜¾ç¤ºå¤±è´¥:', e);
          }
        }
      }
    }

    function toggleDistanceLabels() {
      distanceLabelsVisible = document.getElementById('toggleDistanceLabels')?.checked ?? true;
      console.log('åˆ‡æ¢è·ç¦»æ ‡ç­¾æ˜¾ç¤ºçŠ¶æ€:', distanceLabelsVisible);

      distanceLabels.forEach((label) => {
        if (label) {
          if (typeof label.setVisible === 'function') {
            label.setVisible(distanceLabelsVisible);
          } else {
            // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
            try {
              if (!distanceLabelsVisible) {
                map.removeOverlay(label);
              } else {
                map.addOverlay(label);
              }
            } catch(e) {
              console.warn('åˆ‡æ¢è·ç¦»æ ‡ç­¾æ˜¾ç¤ºå¤±è´¥:', e);
            }
          }
        }
      });
    }

    // è·¯çº¿ç®€ç‰ˆå¼€å…³çŠ¶æ€
    let routeSimpleMode = false;
    // ä¿å­˜å½“å‰è·¯çº¿ç»“æœ
    let currentRouteResult = null;
    // è¡Œæ”¿åŒºå›¾å¼€å…³çŠ¶æ€
    let districtMapEnabled = true;

    function toggleRouteSimple() {
      routeSimpleMode = document.getElementById('toggleRouteSimple')?.checked ?? false;
      console.log('åˆ‡æ¢è·¯çº¿ç®€ç‰ˆçŠ¶æ€:', routeSimpleMode);
      
      // å¦‚æœå½“å‰æœ‰è·¯çº¿æ•°æ®ï¼Œé‡æ–°æ¸²æŸ“è·¯çº¿è¯¦æƒ…
      if (currentRouteResult) {
        updateRouteInfo(currentRouteResult, routeSimpleMode);
      }
    }

    // è¡Œæ”¿åŒºå›¾å¼€å…³
    function toggleDistrictMap() {
      districtMapEnabled = document.getElementById('toggleDistrictMap')?.checked ?? true;
      console.log('åˆ‡æ¢è¡Œæ”¿åŒºå›¾çŠ¶æ€:', districtMapEnabled);
    }

    // æ›´æ–°è·¯çº¿è¯¦æƒ…æ˜¾ç¤º
    function updateRouteInfo(result, simpleMode = false) {
      const { route, legs, total_distance, total_duration, farthest_points } = result;
      const routeInfoDiv = document.getElementById('route-info');
      
      if (!routeInfoDiv) return;
      
      let html = '';
      
      if (simpleMode) {
        // ç®€ç‰ˆï¼šåªæ˜¾ç¤ºåºå·å’Œç½‘ç‚¹åç§°ï¼Œç«–å‘æ’åºï¼Œé‡‡ç”¨åœ°å›¾æ ‡è®°åç§°æ ·å¼
        html = '<h3 style="color:#3366FF;margin-bottom:15px;">ğŸ—ºï¸ è·¯çº¿è¯¦æƒ…ï¼ˆç®€ç‰ˆï¼‰</h3>';
        html += '<div style="line-height:1.8;margin-bottom:15px;">';
        route.forEach((loc, i) => {
          // ä½¿ç”¨åœ°å›¾æ ‡è®°åç§°çš„æ ·å¼ï¼šç™½è‰²èƒŒæ™¯ã€è“è‰²è¾¹æ¡†ã€é˜´å½±ç­‰
          html += `<div style="padding:3px 0;display:flex;align-items:center;">
            <span style="
              background: white;
              border: 2px solid #2196F3;
              padding: 5px 10px;
              border-radius: 5px;
              font-size: 13px;
              font-weight: bold;
              box-shadow: 0 2px 6px rgba(0,0,0,0.3);
              white-space: nowrap;
              color: #333;
            ">${i + 1}. ${loc.name}</span>
          </div>`;
        });
        html += '</div>';
        
        // æ€»ç½‘ç‚¹æ•°ä¿¡æ¯
        html += `
          <div style="margin-top:15px;padding:12px;background:#E3F2FD;border-radius:6px;font-weight:bold;border-left:4px solid #2196F3;">
            <div style="color:#1976D2;font-size:15px;">ğŸ“Š æ€»ç½‘ç‚¹æ•°ï¼š<span style="color:#FF5722;font-size:16px;">${route.length} ä¸ª</span></div>
            <div style="color:#FF5722;font-size:15px;margin-top:8px;">
              æ€»è·ç¦»ï¼š${formatMeters(total_distance)} Â· æ€»ç”¨æ—¶ï¼š${formatSeconds(total_duration)}
            </div>
          </div>`;

        // æœ€è¿œç½‘ç‚¹ä¿¡æ¯
        if (farthest_points && farthest_points.point1 && farthest_points.point2) {
          html += `
            <div style="margin-top:15px;padding:12px;background:#E8F5E9;border-radius:6px;border-left:4px solid #4CAF50;">
              <div style="color:#2E7D32;font-weight:bold;margin-bottom:8px;font-size:14px;">ğŸ“ æœ€è¿œç½‘ç‚¹ï¼ˆç›´çº¿è·ç¦»ï¼‰</div>
              <div style="color:#388E3C;font-size:15px;margin-bottom:5px;">
                <strong>${farthest_points.point1.name}</strong> â†” <strong>${farthest_points.point2.name}</strong>
              </div>
              <div style="color:#4CAF50;font-size:16px;font-weight:bold;margin-top:5px;">
                ${farthest_points.straight_distance_text}
              </div>
            </div>`;
        }
      } else {
        // å®Œæ•´ç‰ˆï¼šæ˜¾ç¤ºè¯¦ç»†è·¯çº¿ä¿¡æ¯
        html = '<h3 style="color:#3366FF;margin-bottom:10px;">ğŸ—ºï¸ è·¯çº¿è¯¦æƒ…</h3>';
        (legs || []).forEach((lg, i) => {
          html += `
            <div class="route-item">
              <strong>${i + 1}. ${lg.from}</strong> â†’ <strong>${i + 2}. ${lg.to}</strong>
              <div class="distance-info">${lg.distance_text} Â· ${lg.duration_text}</div>
            </div>`;
        });
        html += `
          <div style="margin-top:15px;padding:10px;background:#E3F2FD;border-radius:5px;font-weight:bold;">
            <div style="color:#1976D2;">æ€»ç½‘ç‚¹æ•°ï¼š${route.length} ä¸ª</div>
            <div style="color:#FF5722;font-size:16px;margin-top:5px;">
              æ€»è·ç¦»ï¼š${formatMeters(total_distance)} Â· æ€»ç”¨æ—¶ï¼š${formatSeconds(total_duration)}
            </div>
          </div>`;

        if (farthest_points && farthest_points.point1 && farthest_points.point2) {
          html += `
            <div style="margin-top:15px;padding:10px;background:#E8F5E9;border-radius:5px;border-left:4px solid #00FF00;">
              <div style="color:#2E7D32;font-weight:bold;margin-bottom:5px;">ğŸ“ æœ€è¿œç½‘ç‚¹ï¼ˆç›´çº¿è·ç¦»ï¼‰</div>
              <div style="color:#388E3C;font-size:13px;">
                <strong>${farthest_points.point1.name}</strong> â†” <strong>${farthest_points.point2.name}</strong>
              </div>
              <div style="color:#00FF00;font-size:14px;font-weight:bold;margin-top:5px;">
                ${farthest_points.straight_distance_text}
              </div>
            </div>`;
        }
      }
      
      routeInfoDiv.innerHTML = html;
    }

    function drawFarthestLine(farthest_points) {
      // æ¸…ç†æ—§çš„
      if (farthestLineOverlay) {
        try {
          map.removeOverlay(farthestLineOverlay);
          const idx = overlays.indexOf(farthestLineOverlay);
          if (idx > -1) overlays.splice(idx, 1);
        } catch(e) {
          console.warn('ç§»é™¤æ—§çš„æœ€è¿œè¿çº¿å¤±è´¥:', e);
        }
      }
      if (farthestLabelOverlay) {
        try {
          map.removeOverlay(farthestLabelOverlay);
          const idx = overlays.indexOf(farthestLabelOverlay);
          if (idx > -1) overlays.splice(idx, 1);
        } catch(e) {
          console.warn('ç§»é™¤æ—§çš„æœ€è¿œæ ‡ç­¾å¤±è´¥:', e);
        }
      }
      farthestLineOverlay = null;
      farthestLabelOverlay = null;

      if (!map) {
        console.warn('åœ°å›¾æœªåˆå§‹åŒ–ï¼Œæ— æ³•ç»˜åˆ¶æœ€è¿œè¿çº¿');
        return;
      }

      if (!farthest_points || !farthest_points.point1 || !farthest_points.point2) {
        console.log('æœªæ‰¾åˆ°æœ€è¿œç½‘ç‚¹æ•°æ®:', farthest_points);
        return;
      }

      console.log('å¼€å§‹ç»˜åˆ¶æœ€è¿œç½‘ç‚¹è¿çº¿:', farthest_points);

      const p1 = new BMap.Point(farthest_points.point1.lng, farthest_points.point1.lat);
      const p2 = new BMap.Point(farthest_points.point2.lng, farthest_points.point2.lat);

      console.log('ç‚¹1åæ ‡:', p1.lng, p1.lat, 'åç§°:', farthest_points.point1.name);
      console.log('ç‚¹2åæ ‡:', p2.lng, p2.lat, 'åç§°:', farthest_points.point2.name);

      // ä½¿ç”¨äº®ç»¿è‰² #00E676 (Material Design äº®ç»¿è‰²) æˆ– #00FF00 (çº¯ç»¿è‰²)
      const line = new BMap.Polyline([p1, p2], {
        strokeWeight: 4,  // çº¿æ¡å®½åº¦ï¼ˆç¨å¾®ç»†ä¸€ç‚¹ï¼‰
        strokeOpacity: 1.0,  // å®Œå…¨ä¸é€æ˜
        strokeColor: "#00FF00"  // äº®ç»¿è‰²
      });

      // å°è¯•è®¾ç½®è™šçº¿æ ·å¼ï¼ˆå¦‚æœAPIæ”¯æŒï¼‰
      if (typeof line.setStrokeStyle === 'function') {
        try {
          line.setStrokeStyle("dashed");
          console.log('å·²è®¾ç½®è™šçº¿æ ·å¼');
        } catch(e) {
          console.log('è™šçº¿æ ·å¼è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨å®çº¿');
        }
      }

      map.addOverlay(line);
      overlays.push(line);
      farthestLineOverlay = line;
      console.log('âœ“ æœ€è¿œè¿çº¿å·²æ·»åŠ åˆ°åœ°å›¾');

      // è®¡ç®—ä¸­ç‚¹ç”¨äºæ ‡æ³¨è·ç¦»
      const midPoint = new BMap.Point((p1.lng + p2.lng) / 2, (p1.lat + p2.lat) / 2);

      // æ ‡æ³¨ç›´çº¿è·ç¦»ï¼ˆä½¿ç”¨äº®ç»¿è‰²èƒŒæ™¯ï¼‰
      const label = new BMap.Label(farthest_points.straight_distance_text || "æœ€è¿œç›´çº¿è·ç¦»", {
        offset: new BMap.Size(0, -15)
      });

      label.setStyle({
        background: 'rgba(0, 255, 0, 0.9)',  // äº®ç»¿è‰²èƒŒæ™¯
        color: 'white',
        border: '2px solid white',
        padding: '6px 12px',
        borderRadius: '5px',
        fontSize: '13px',
        fontWeight: 'bold',
        boxShadow: '0 2px 6px rgba(0,0,0,0.4)',
        whiteSpace: 'nowrap',
        zIndex: 1001
      });

      label.setPosition(midPoint);
      map.addOverlay(label);
      overlays.push(label);
      farthestLabelOverlay = label;
      console.log('âœ“ è·ç¦»æ ‡ç­¾å·²æ·»åŠ :', farthest_points.straight_distance_text);

      // æŒ‰å¼€å…³çŠ¶æ€æ˜¾ç¤º/éšè—
      toggleFarthestLine();
    }

    // å®šä¹‰å…¨å±€å›è°ƒå‡½æ•°ï¼Œä¾›ç™¾åº¦åœ°å›¾APIè°ƒç”¨
    window.baiduMapInit = function() {
      if (typeof BMap !== 'undefined') {
        initMap();
      } else {
        showError("ç™¾åº¦åœ°å›¾APIå¯¹è±¡æœªåˆå§‹åŒ–ï¼Œè¯·æ£€æŸ¥AKé…ç½®å’Œç½‘ç»œè¿æ¥");
      }
    };

    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      if (tabName === 'excel') {
        document.querySelector('.tab:first-child').classList.add('active');
        document.getElementById('excel-tab').classList.add('active');
      } else {
        document.querySelector('.tab:last-child').classList.add('active');
        document.getElementById('manual-tab').classList.add('active');
      }
    }

    function initMap() {
      if (typeof BMap === 'undefined') {
        showError("ç™¾åº¦åœ°å›¾APIæœªåŠ è½½æˆåŠŸ");
        return;
      }
      map = new BMap.Map("container");
      const center = new BMap.Point(116.397428, 39.90923);
      map.centerAndZoom(center, 11);
      map.enableScrollWheelZoom(true);
    }

    // ç»Ÿä¸€çš„çŠ¶æ€æ›´æ–°å‡½æ•°ï¼Œç¡®ä¿çŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
    function updateStatus(message, type = 'info') {
      const statusInfo = document.getElementById('status-info');
      if (!statusInfo) return;
      
      // ç¡®ä¿çŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
      statusInfo.style.display = 'block';
      
      let statusText = document.getElementById('status-text');
      // å¦‚æœæ‰¾ä¸åˆ°status-textå…ƒç´ ï¼Œåˆ›å»ºå®ƒ
      if (!statusText) {
        statusInfo.innerHTML = '<div id="status-text">' + message + '</div>';
        statusText = document.getElementById('status-text');
      } else {
        statusText.textContent = message;
      }
      
      if (statusText) {
        // è®¾ç½®é»˜è®¤æ ·å¼
        statusInfo.style.background = '#f5f5f5'; // é»˜è®¤èƒŒæ™¯è‰²
        statusText.style.color = '#666'; // é»˜è®¤æ–‡å­—é¢œè‰²
        
        if (type === 'loading') {
          statusInfo.style.background = '#E3F2FD'; // è“è‰²èƒŒæ™¯ï¼ˆåŠ è½½ä¸­ï¼‰
          statusText.style.color = '#1976D2';
        } else if (type === 'success') {
          statusInfo.style.background = '#E8F5E9'; // ç»¿è‰²èƒŒæ™¯ï¼ˆæˆåŠŸï¼‰
          statusText.style.color = '#2E7D32';
        } else if (type === 'error') {
          statusInfo.style.background = '#FFEBEE'; // çº¢è‰²èƒŒæ™¯ï¼ˆé”™è¯¯ï¼‰
          statusText.style.color = '#C62828';
        } else if (type === 'ready') {
          statusInfo.style.background = '#f5f5f5'; // é»˜è®¤èƒŒæ™¯ï¼ˆå°±ç»ªï¼‰
          statusText.style.color = '#666';
        }
      }
    }

    function showLoading(message) {
      updateStatus(message, 'loading');
    }
    
    function clearStatusInfo() {
      // ä¸æ¸…é™¤çŠ¶æ€æ ï¼Œåªé‡ç½®ä¸º"å°±ç»ª"çŠ¶æ€
      updateStatus('å°±ç»ª', 'ready');
    }

    // æ˜¾ç¤ºæˆªå›¾æ¨¡å¼é€‰æ‹©å¯¹è¯æ¡†
    function showScreenshotModeDialog(callback) {
      // åˆ›å»ºé®ç½©å±‚
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
      
      // åˆ›å»ºå¯¹è¯æ¡†
      const dialog = document.createElement('div');
      dialog.className = 'modal-dialog';
      dialog.innerHTML = `
        <div class="modal-title">ğŸ“¸ é€‰æ‹©æˆªå›¾æ¨¡å¼</div>
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-detail" onclick="closeScreenshotDialog(false)">è¯¦ç»†ç‰ˆ</button>
          <button class="modal-btn modal-btn-simple" onclick="closeScreenshotDialog(true)">ç®€æ´ç‰ˆ</button>
        </div>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // ä¿å­˜å›è°ƒå‡½æ•°åˆ°å…¨å±€ï¼Œä¾›æŒ‰é’®è°ƒç”¨
      window._screenshotModeCallback = callback;
      
      // ç‚¹å‡»é®ç½©å±‚å…³é—­
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeScreenshotDialog(false); // é»˜è®¤é€‰æ‹©è¯¦ç»†ç‰ˆ
        }
      });
    }

    // å…³é—­æˆªå›¾æ¨¡å¼å¯¹è¯æ¡†
    function closeScreenshotDialog(useSimpleMode) {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) {
        overlay.remove();
      }
      
      // è°ƒç”¨å›è°ƒå‡½æ•°
      if (window._screenshotModeCallback) {
        window._screenshotModeCallback(useSimpleMode);
        window._screenshotModeCallback = null;
      }
    }
    
    // æ˜¾ç¤ºæ‰¹é‡å¤„ç†è¿›åº¦
    function showBatchProgress(totalGroups) {
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = `
          <div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
            <div id="batchStatus">å‡†å¤‡å¤„ç† ${totalGroups} ä¸ªç½‘ç»„...</div>
            <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
              <div id="batchProgressBar" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
            </div>
          </div>
        `;
      }
    }
    
    // æ›´æ–°æ‰¹é‡å¤„ç†çŠ¶æ€
    function updateBatchStatus(message, current, total) {
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        const batchStatus = document.getElementById('batchStatus');
        const batchProgressBar = document.getElementById('batchProgressBar');
        if (batchStatus) {
          batchStatus.textContent = message;
        }
        if (batchProgressBar) {
          const progress = (current / total * 100).toFixed(0);
          batchProgressBar.style.width = progress + '%';
        }
      }
    }

    function clearMap() {
      if (!map) return;
      markers.forEach(m => map.removeOverlay(m));
      overlays.forEach(o => map.removeOverlay(o));
      markers = [];
      overlays = [];
      currentLocations = [];
      document.getElementById('route-info').innerHTML = '';

      // âœ… æ¸…ç©ºæœ€è¿œçº¿å¼•ç”¨
      farthestLineOverlay = null;
      farthestLabelOverlay = null;
      
      // âœ… æ¸…ç©ºè·ç¦»æ ‡ç­¾å¼•ç”¨
      distanceLabels = [];
    }

    function parseLocationData() {
      const input = document.getElementById('locationInput').value.trim();
      if (!input) {
        showError('è¯·è¾“å…¥ç½‘ç‚¹æ•°æ®ï¼');
        return [];
      }
      const lines = input.split('\n');
      const locations = [];
      const errors = [];

      lines.forEach((line, idx) => {
        const t = line.trim();
        if (!t) return;
        const parts = t.split(',');
        if (parts.length < 3) {
          errors.push(`ç¬¬${idx + 1}è¡Œï¼šæ ¼å¼é”™è¯¯ï¼ˆè‡³å°‘éœ€è¦ ç»åº¦,çº¬åº¦,åç§°ï¼‰`);
          return;
        }
        const lng = parseFloat(parts[0].trim());
        const lat = parseFloat(parts[1].trim());
        const name = parts[2].trim();
        const remark = parts.length > 3 ? parts[3].trim() : '';  // ç¬¬å››åˆ—ï¼šå¤‡æ³¨
        const group = parts.length > 4 ? parts[4].trim() : '';  // ç¬¬äº”åˆ—ï¼šç½‘ç»„
        const employee_id = parts.length > 5 ? parts[5].trim() : '';  // ç¬¬å…­åˆ—ï¼šå·¥å·
        const employee_name = parts.length > 6 ? parts[6].trim() : '';  // ç¬¬ä¸ƒåˆ—ï¼šå§“å
        const district = parts.length > 7 ? parts[7].trim() : '';  // ç¬¬å…«åˆ—ï¼šå¿åŒº
        const adjustment = parts.length > 8 ? parts[8].trim() : '';  // ç¬¬ä¹åˆ—ï¼šè°ƒæ•´
        if (Number.isNaN(lng) || Number.isNaN(lat)) {
          errors.push(`ç¬¬${idx + 1}è¡Œï¼šç»çº¬åº¦æ ¼å¼é”™è¯¯`);
          return;
        }
        locations.push({ lng, lat, name, remark, group, employee_id, employee_name, district, adjustment });
      });

      if (errors.length) {
        showError(errors.join('<br>'));
        return [];
      }
      return locations;
    }

    // ä¿å­˜åˆ†ç»„æ•°æ®
    let excelGroups = {};
    let excelEmployees = {};  // æŒ‰å·¥å·åˆ†ç»„çš„æ•°æ®
    let excelAdjustments = {};  // æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ•°æ®ï¼ˆç»“æ„ï¼šadjustment -> employee_id -> groups -> locationsï¼‰

    async function handleExcelUpload() {
      const fileInput = document.getElementById('excelFile');
      const file = fileInput.files[0];
      if (!file) return;

      showLoading('ğŸ“¤ æ­£åœ¨ä¸Šä¼ æ–‡ä»¶...');

      const formData = new FormData();
      formData.append('file', file);

      try {
        const resp = await fetch('/upload_excel', { method: 'POST', body: formData });
        const data = await resp.json();
        if (data.error) return showError(data.error);

        currentLocations = data.locations || [];
        excelGroups = data.groups || {};
        excelEmployees = data.employees || {};  // ä¿å­˜æŒ‰å·¥å·åˆ†ç»„çš„æ•°æ®
        excelAdjustments = data.adjustments || {};  // ä¿å­˜æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ•°æ®
        
        // ç¾åŒ–æˆåŠŸå¯¼å…¥çš„å¼¹çª—æ ¼å¼
        let infoHtml = `<div style="
          padding: 16px 20px;
          background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
          color: white;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
          border-left: 4px solid #2E7D32;
        ">
          <div style="font-size: 18px; font-weight: bold; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 24px;">âœ…</span>
            <span>æˆåŠŸå¯¼å…¥ ${currentLocations.length} ä¸ªç½‘ç‚¹</span>
          </div>`;
        
        if (data.group_count > 0) {
          infoHtml += `
          <div style="
            margin-top: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            backdrop-filter: blur(10px);
          ">
            <div style="font-size: 15px; font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
              <span>ğŸ“¦</span>
              <span>å…± ${data.group_count} ä¸ªç½‘ç»„</span>
            </div>
            <div style="font-size: 13px; line-height: 1.6; opacity: 0.95;">
              ${Object.keys(excelGroups).map(g => `<span style="display: inline-block; margin: 2px 4px; padding: 4px 8px; background: rgba(255, 255, 255, 0.2); border-radius: 4px;">${g} (${excelGroups[g].length}ä¸ªç½‘ç‚¹)</span>`).join('')}
            </div>
            <div style="margin-top: 10px; font-size: 13px; font-style: italic; opacity: 0.9;">
              â³ æ­£åœ¨æŒ‰ç½‘ç»„ä¾æ¬¡å¤„ç†...
            </div>
          </div>`;
        }
        
        infoHtml += `</div>`;
        document.getElementById('route-info').innerHTML = infoHtml;

        if (currentLocations.length) {
          document.getElementById('locationInput').value =
            currentLocations.map(l => [l.lng, l.lat, l.name, l.remark || "", l.group || "", l.employee_id || "", l.employee_name || "", l.district || "", l.adjustment || ""].filter(x => x !== "").join(',')).join('\n');
        }

        // å¦‚æœæœ‰åˆ†ç»„æ•°æ®ï¼Œæ˜¾ç¤ºè‡ªå®šä¹‰å¯¹è¯æ¡†é€‰æ‹©æˆªå›¾æ¨¡å¼
        if (data.group_count > 0) {
          // åˆ›å»ºè‡ªå®šä¹‰æ¨¡æ€å¯¹è¯æ¡†
          showScreenshotModeDialog((useSimpleMode) => {
            // è®¾ç½®è·¯çº¿ç®€ç‰ˆå¼€å…³çŠ¶æ€
            const routeSimpleCheckbox = document.getElementById('toggleRouteSimple');
            if (routeSimpleCheckbox) {
              routeSimpleCheckbox.checked = useSimpleMode;
              // è§¦å‘changeäº‹ä»¶ï¼Œç¡®ä¿çŠ¶æ€åŒæ­¥
              if (typeof toggleRouteSimple === 'function') {
                toggleRouteSimple();
              }
            }
            
            // å»¶è¿Ÿä¸€ä¸‹å†å¼€å§‹æ‰¹é‡å¤„ç†ï¼Œç¡®ä¿UIçŠ¶æ€å·²æ›´æ–°
            setTimeout(() => {
              // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰è°ƒæ•´å­—æ®µæ•°æ®ï¼Œå¦‚æœæœ‰åˆ™æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„å¤„ç†
              if (data.adjustment_count > 0 && data.adjustment_count > 0) {
                startBatchProcessByAdjustment();
              } else if (data.employee_count > 0) {
                // å¦‚æœæœ‰å·¥å·æ•°æ®ï¼ŒæŒ‰å·¥å·åˆ†ç»„å¤„ç†
                startBatchProcessByEmployee();
              } else {
                // å¦åˆ™æŒ‰ç½‘ç»„å¤„ç†
                startBatchProcess();
              }
            }, 300);
          });
        } else {
          // æ²¡æœ‰åˆ†ç»„ï¼Œç›´æ¥ç»˜åˆ¶æ‰€æœ‰ç‚¹
          await drawPoints(currentLocations);
          document.getElementById('batchProcessSection').style.display = 'none';
        }
      } catch (e) {
        showError('ä¸Šä¼ å¤±è´¥ï¼š' + e);
      }
    }
    
    // æ‰¹é‡å¤„ç†å‡½æ•°
    async function startBatchProcess() {
      if (!excelGroups || Object.keys(excelGroups).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„ç½‘ç»„æ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥Excelæ–‡ä»¶');
        return;
      }
      
      const groups = Object.keys(excelGroups);
      const totalGroups = groups.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡åœ¨çŠ¶æ€åŒºåŸŸ
      showBatchProgress(totalGroups);
      
      const results = [];
      
      for (let i = 0; i < groups.length; i++) {
        const groupName = groups[i];
        const locations = excelGroups[groupName];
        
        // æ›´æ–°è¿›åº¦ï¼ˆåœ¨çŠ¶æ€åŒºåŸŸæ˜¾ç¤ºï¼‰
        updateBatchStatus(`æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, i + 1, totalGroups);
        
        try {
          // 1. æ¸…é™¤åœ°å›¾
          clearMap();
          
          // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
          await drawPoints(locations);
          
          // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // 4. ä¼˜åŒ–è·¯çº¿
          updateBatchStatus(`ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, i + 1, totalGroups);
          const optimizeResp = await fetch('/optimize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: locations })
          });
          const optimizeData = await optimizeResp.json();
          
          if (optimizeData.error) {
            results.push({ group: groupName, success: false, error: optimizeData.error });
            continue;
          }
          
          // 5. ç»˜åˆ¶è·¯çº¿ç»“æœï¼ˆä¸è‡ªåŠ¨æˆªå›¾ï¼Œç”±æ‰¹é‡å¤„ç†æ§åˆ¶ï¼‰
          await drawRouteResult(optimizeData, false);
          
          // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // 7. æˆªå›¾ï¼ˆä½¿ç”¨ç½‘ç»„åç§°ï¼Œå¦‚æœæ²¡æœ‰å·¥å·åˆ™ä¼ ç©ºå­—ç¬¦ä¸²ï¼‰
          updateBatchStatus(`ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, i + 1, totalGroups);
          try {
            await captureScreenshot(groupName, '', '');
            // captureScreenshotå†…éƒ¨å·²ç»å¤„ç†äº†å“åº”ï¼Œè¿™é‡Œå‡è®¾æˆåŠŸ
            results.push({ 
              group: groupName, 
              success: true, 
              location_count: locations.length
            });
          } catch (e) {
            results.push({ 
              group: groupName, 
              success: false, 
              error: 'æˆªå›¾å¤±è´¥: ' + String(e)
            });
          }
          
          // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
          await new Promise(resolve => setTimeout(resolve, 500));
          
        } catch (e) {
          results.push({ group: groupName, success: false, error: String(e) });
        }
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœï¼ˆåœ¨çŠ¶æ€åŒºåŸŸï¼‰
      const successCount = results.filter(r => r.success).length;
      const failCount = results.filter(r => !r.success).length;
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${successCount} ç»„, å¤±è´¥: ${failCount} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (failCount > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        results.filter(r => !r.success).forEach(r => {
          statusHtml += `${r.group}: ${r.error}<br>`;
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        // ä¿æŒçŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
        statusInfo.style.display = 'block';
        // å¯¹äºå¤æ‚çš„æ‰¹é‡å¤„ç†ç»“æœï¼Œç›´æ¥æ›´æ–°innerHTMLï¼Œä½†ä¿æŒçŠ¶æ€æ å¯è§
        statusInfo.innerHTML = statusHtml;
        // 10ç§’åæ¢å¤ä¸º"å°±ç»ª"çŠ¶æ€
        setTimeout(() => {
          // æ¢å¤çŠ¶æ€æ çš„æ ‡å‡†ç»“æ„ï¼ˆåŒ…å«status-textå…ƒç´ ï¼‰
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
      
      // è·¯çº¿è¯¦æƒ…é¡µä¿æŒä¸å˜ï¼Œä¸è¦†ç›–
    }

    // æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ‰¹é‡å¤„ç†å‡½æ•°ï¼ˆé¦–å…ˆæŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„ï¼Œç„¶åæŒ‰å·¥å·ã€ç½‘ç»„åˆ†ç»„ï¼‰
    async function startBatchProcessByAdjustment() {
      if (!excelAdjustments || Object.keys(excelAdjustments).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„è°ƒæ•´å­—æ®µæ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥åŒ…å«è°ƒæ•´å­—æ®µçš„Excelæ–‡ä»¶');
        return;
      }
      
      const adjustments = Object.keys(excelAdjustments);
      const totalAdjustments = adjustments.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡
      showBatchProgress(totalAdjustments);
      
      const allResults = [];
      
      // éå†æ¯ä¸ªè°ƒæ•´å­—æ®µ
      for (let adjIdx = 0; adjIdx < adjustments.length; adjIdx++) {
        const adjustment = adjustments[adjIdx];
        const adjustmentData = excelAdjustments[adjustment];
        const employeeIds = Object.keys(adjustmentData);
        const totalEmployees = employeeIds.length;
        
        updateBatchStatus(`æ­£åœ¨å¤„ç†è°ƒæ•´å­—æ®µ ${adjIdx + 1}/${totalAdjustments}: ${adjustment} - ${totalEmployees}ä¸ªå·¥å·`, adjIdx + 1, totalAdjustments);
        
        // éå†è¯¥è°ƒæ•´å­—æ®µä¸‹çš„æ¯ä¸ªå·¥å·
        for (let empIdx = 0; empIdx < employeeIds.length; empIdx++) {
          const employeeId = employeeIds[empIdx];
          const employeeData = adjustmentData[employeeId];
          const employeeName = employeeData.employee_name || '';
          const groups = Object.keys(employeeData.groups);
          const totalGroups = groups.length;
          
          updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId} (${employeeName}): ${totalGroups}ä¸ªç½‘ç»„`, adjIdx + 1, totalAdjustments);
          
          const employeeResults = [];
          
          // å¤„ç†è¯¥å·¥å·ä¸‹çš„æ‰€æœ‰ç½‘ç»„
          for (let i = 0; i < groups.length; i++) {
            const groupName = groups[i];
            const locations = employeeData.groups[groupName];
            
            updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, adjIdx + 1, totalAdjustments);
            
            try {
              // 1. æ¸…é™¤åœ°å›¾
              clearMap();
              
              // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
              await drawPoints(locations);
              
              // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
              await new Promise(resolve => setTimeout(resolve, 500));
              
              // 4. ä¼˜åŒ–è·¯çº¿
              updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, adjIdx + 1, totalAdjustments);
              const optimizeResp = await fetch('/optimize', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ locations: locations })
              });
              const optimizeData = await optimizeResp.json();
              
              if (optimizeData.error) {
                employeeResults.push({ group: groupName, success: false, error: optimizeData.error });
                continue;
              }
              
              // 5. ç»˜åˆ¶è·¯çº¿ç»“æœ
              await drawRouteResult(optimizeData, false);
              
              // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // 7. æˆªå›¾ï¼ˆä½¿ç”¨æ–°çš„å‘½åè§„åˆ™ï¼šç½‘ç»„ç½‘ç‚¹å›¾-å·¥å·-å§“å-è°ƒæ•´ï¼‰
              updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, adjIdx + 1, totalAdjustments);
              try {
                await captureScreenshot(groupName, employeeId, employeeName, adjustment);
                employeeResults.push({ 
                  group: groupName, 
                  success: true, 
                  location_count: locations.length
                });
              } catch (e) {
                employeeResults.push({ 
                  group: groupName, 
                  success: false, 
                  error: 'æˆªå›¾å¤±è´¥: ' + String(e)
                });
              }
              
              // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
              await new Promise(resolve => setTimeout(resolve, 500));
              
            } catch (e) {
              employeeResults.push({ group: groupName, success: false, error: String(e) });
            }
          }
          
          // å¦‚æœè¡Œæ”¿åŒºå›¾åŠŸèƒ½å¼€å¯ï¼Œä¸”è¯¥å·¥å·æœ‰ç½‘ç»„ï¼Œç»˜åˆ¶è¡Œæ”¿åŒºå›¾
          if (districtMapEnabled && totalGroups > 0) {
            updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ—ºï¸ æ­£åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºå›¾...`, adjIdx + 1, totalAdjustments);
            try {
              await drawDistrictMapForEmployee(employeeId, employeeName, employeeData.groups, adjustment);
              employeeResults.push({ 
                type: 'district_map',
                success: true
              });
            } catch (e) {
              console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
              employeeResults.push({ 
                type: 'district_map',
                success: false,
                error: String(e)
              });
            }
          }
          
          allResults.push({
            adjustment: adjustment,
            employee_id: employeeId,
            employee_name: employeeName,
            groups: employeeResults
          });
        }
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœ
      const totalSuccess = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => r.success).length, 0);
      const totalFail = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => !r.success).length, 0);
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${totalSuccess} ç»„, å¤±è´¥: ${totalFail} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (totalFail > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        allResults.forEach(emp => {
          emp.groups.filter(r => !r.success).forEach(r => {
            statusHtml += `${emp.adjustment} - ${emp.employee_id} - ${r.group}: ${r.error}<br>`;
          });
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = statusHtml;
        setTimeout(() => {
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
    }

    // æŒ‰å·¥å·åˆ†ç»„çš„æ‰¹é‡å¤„ç†å‡½æ•°
    async function startBatchProcessByEmployee() {
      if (!excelEmployees || Object.keys(excelEmployees).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„å·¥å·æ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥åŒ…å«å·¥å·çš„Excelæ–‡ä»¶');
        return;
      }
      
      const employeeIds = Object.keys(excelEmployees);
      const totalEmployees = employeeIds.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡
      showBatchProgress(totalEmployees);
      
      const allResults = [];
      
      // éå†æ¯ä¸ªå·¥å·
      for (let empIdx = 0; empIdx < employeeIds.length; empIdx++) {
        const employeeId = employeeIds[empIdx];
        const employeeData = excelEmployees[employeeId];
        const employeeName = employeeData.employee_name || '';
        const groups = Object.keys(employeeData.groups);
        const totalGroups = groups.length;
        
        updateBatchStatus(`æ­£åœ¨å¤„ç†å·¥å· ${empIdx + 1}/${totalEmployees}: ${employeeId} (${employeeName}) - ${totalGroups}ä¸ªç½‘ç»„`, empIdx + 1, totalEmployees);
        
        const employeeResults = [];
        
        // å¤„ç†è¯¥å·¥å·ä¸‹çš„æ‰€æœ‰ç½‘ç»„
        for (let i = 0; i < groups.length; i++) {
          const groupName = groups[i];
          const locations = employeeData.groups[groupName];
          
          updateBatchStatus(`å·¥å· ${employeeId}: æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, empIdx + 1, totalEmployees);
          
          try {
            // 1. æ¸…é™¤åœ°å›¾
            clearMap();
            
            // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
            await drawPoints(locations);
            
            // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // 4. ä¼˜åŒ–è·¯çº¿
            updateBatchStatus(`å·¥å· ${employeeId}: ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, empIdx + 1, totalEmployees);
            const optimizeResp = await fetch('/optimize', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ locations: locations })
            });
            const optimizeData = await optimizeResp.json();
            
            if (optimizeData.error) {
              employeeResults.push({ group: groupName, success: false, error: optimizeData.error });
              continue;
            }
            
            // 5. ç»˜åˆ¶è·¯çº¿ç»“æœ
            await drawRouteResult(optimizeData, false);
            
            // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // 7. æˆªå›¾ï¼ˆä½¿ç”¨æ–°çš„å‘½åè§„åˆ™ï¼šå·¥å·-å§“å-ç½‘ç»„ç½‘ç‚¹å›¾-ç½‘ç»„ï¼‰
            updateBatchStatus(`å·¥å· ${employeeId}: ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, empIdx + 1, totalEmployees);
            try {
              // ä»locationsä¸­è·å–adjustmentå­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
              const adjustment = locations.length > 0 && locations[0].adjustment ? locations[0].adjustment : '';
              await captureScreenshot(groupName, employeeId, employeeName, adjustment);
              employeeResults.push({ 
                group: groupName, 
                success: true, 
                location_count: locations.length
              });
            } catch (e) {
              employeeResults.push({ 
                group: groupName, 
                success: false, 
                error: 'æˆªå›¾å¤±è´¥: ' + String(e)
              });
            }
            
            // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
            await new Promise(resolve => setTimeout(resolve, 500));
            
          } catch (e) {
            employeeResults.push({ group: groupName, success: false, error: String(e) });
          }
        }
        
        // å¦‚æœè¡Œæ”¿åŒºå›¾åŠŸèƒ½å¼€å¯ï¼Œä¸”è¯¥å·¥å·æœ‰ç½‘ç»„ï¼Œç»˜åˆ¶è¡Œæ”¿åŒºå›¾
        if (districtMapEnabled && totalGroups > 0) {
          updateBatchStatus(`å·¥å· ${employeeId}: ğŸ—ºï¸ æ­£åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºå›¾...`, empIdx + 1, totalEmployees);
          try {
            // ä»ç¬¬ä¸€ä¸ªç½‘ç»„çš„ç¬¬ä¸€ä¸ªç½‘ç‚¹è·å–adjustmentå­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const firstGroupName = groups[0];
            const firstLocations = employeeData.groups[firstGroupName];
            const adjustment = firstLocations.length > 0 && firstLocations[0].adjustment ? firstLocations[0].adjustment : '';
            await drawDistrictMapForEmployee(employeeId, employeeName, employeeData.groups, adjustment);
            employeeResults.push({ 
              type: 'district_map',
              success: true
            });
          } catch (e) {
            console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
            employeeResults.push({ 
              type: 'district_map',
              success: false,
              error: String(e)
            });
          }
        }
        
        allResults.push({
          employee_id: employeeId,
          employee_name: employeeName,
          groups: employeeResults
        });
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœ
      const totalSuccess = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => r.success).length, 0);
      const totalFail = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => !r.success).length, 0);
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${totalSuccess} ç»„, å¤±è´¥: ${totalFail} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (totalFail > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        allResults.forEach(emp => {
          emp.groups.filter(r => !r.success).forEach(r => {
            statusHtml += `${emp.employee_id} - ${r.group}: ${r.error}<br>`;
          });
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = statusHtml;
        setTimeout(() => {
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
    }

    // ç»˜åˆ¶å·¥å·çš„è¡Œæ”¿åŒºå›¾
    async function drawDistrictMapForEmployee(employeeId, employeeName, groups, adjustment = '') {
      try {
        // æ”¶é›†è¯¥å·¥å·ä¸‹æ‰€æœ‰ç½‘ç‚¹çš„åæ ‡
        const allLocations = [];
        Object.values(groups).forEach(groupLocs => {
          allLocations.push(...groupLocs);
        });
        
        if (allLocations.length === 0) return;
      
      // æ”¶é›†æ‰€æœ‰ç½‘ç»„ä¸­çš„å¿åŒºå­—æ®µï¼ˆç”¨äºç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼‰
      const districtsFromField = new Set();
      allLocations.forEach(loc => {
        if (loc.district && loc.district.trim()) {
          districtsFromField.add(loc.district.trim());
        }
      });
      
      console.log(`[è¡Œæ”¿åŒºå›¾] ä»å¿åŒºå­—æ®µè·å–åˆ°çš„è¡Œæ”¿åŒº: ${Array.from(districtsFromField).join(', ')}`);
      
      // å¦‚æœæä¾›äº†å¿åŒºå­—æ®µï¼Œç›´æ¥ä½¿ç”¨å¿åŒºå­—æ®µï¼›å¦åˆ™ä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼ˆæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒºï¼‰
      let districtsMap = {};
      let useDistrictField = districtsFromField.size > 0;
      
      if (useDistrictField) {
        // ä½¿ç”¨å¿åŒºå­—æ®µæä¾›çš„è¡Œæ”¿åŒºåç§°
        console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨å¿åŒºå­—æ®µç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼Œå…± ${districtsFromField.size} ä¸ªè¡Œæ”¿åŒº`);
        Array.from(districtsFromField).forEach(districtName => {
          districtsMap[districtName] = [];  // åªéœ€è¦è¡Œæ”¿åŒºåç§°ï¼Œä¸éœ€è¦åæ ‡ä¿¡æ¯
        });
      } else {
        // å¦‚æœæ²¡æœ‰å¿åŒºå­—æ®µï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼šè°ƒç”¨APIæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒº
        console.log(`[è¡Œæ”¿åŒºå›¾] æœªæä¾›å¿åŒºå­—æ®µï¼ŒæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒºä¿¡æ¯`);
        
        try {
          const resp = await fetch('/get_district_boundary', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: allLocations })
          });
          const data = await resp.json();
          
          if (data.error || !data.success) {
            console.error('è·å–è¡Œæ”¿åŒºä¿¡æ¯å¤±è´¥:', data.error || 'æœªçŸ¥é”™è¯¯');
            return;
          }
          
          // æŒ‰è¡Œæ”¿åŒºåˆ†ç»„
          data.districts.forEach(dist => {
            const districtName = dist.district;
            if (districtName && districtName !== 'æœªçŸ¥åŒºåŸŸ' && districtName !== 'æŸ¥è¯¢å¤±è´¥') {
              if (!districtsMap[districtName]) {
                districtsMap[districtName] = [];
              }
              districtsMap[districtName].push(dist);
            }
          });
          
          console.log(`[è¡Œæ”¿åŒºå›¾] æŸ¥è¯¢åˆ°çš„è¡Œæ”¿åŒº: ${Object.keys(districtsMap).join(', ')}`);
        } catch (e) {
          console.error('æŸ¥è¯¢è¡Œæ”¿åŒºä¿¡æ¯å¤±è´¥:', e);
          return;
        }
      }
      
      if (Object.keys(districtsMap).length === 0) {
        console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆè¡Œæ”¿åŒºï¼Œè·³è¿‡è¡Œæ”¿åŒºè¾¹ç•Œç»˜åˆ¶`);
        return;
      }
      
      // æ¸…é™¤åœ°å›¾
      clearMap();
      
      // å®šä¹‰é¢œè‰²æ•°ç»„ï¼ˆç”¨äºä¸åŒè¡Œæ”¿åŒºè¾¹æ¡†ï¼Œä½¿ç”¨æ˜æ˜¾åŒºåˆ†çš„é¢œè‰²ï¼‰
      const districtColors = [
        '#FF0000',  // çº¢è‰² - æœ€æ˜æ˜¾
        '#0000FF',  // è“è‰² - ä¸çº¢è‰²å¯¹æ¯”æ˜æ˜¾
        '#00FF00',  // ç»¿è‰² - ä¸çº¢è“å¯¹æ¯”æ˜æ˜¾
        '#FF00FF',  // æ´‹çº¢è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FFFF00',  // é»„è‰² - æ˜äº®é†’ç›®
        '#00FFFF',  // é’è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FF8000',  // æ©™è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#8000FF',  // ç´«è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FF0080',  // ç²‰çº¢è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#0080FF'   // å¤©è“è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
      ];
      const groupColors = [
        '#2196F3', '#FF5722', '#4CAF50', '#FF9800', '#9C27B0',
        '#00BCD4', '#795548', '#607D8B', '#E91E63', '#009688'
      ];
      
      // å‡½æ•°ï¼šå°†é¢œè‰²å˜äº®ï¼ˆå¢åŠ äº®åº¦ï¼‰
      function brightenColor(hex, percent = 30) {
        // ç§»é™¤ # å·
        hex = hex.replace('#', '');
        
        // è½¬æ¢ä¸º RGB
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        // å¢åŠ äº®åº¦
        const newR = Math.min(255, Math.floor(r + (255 - r) * percent / 100));
        const newG = Math.min(255, Math.floor(g + (255 - g) * percent / 100));
        const newB = Math.min(255, Math.floor(b + (255 - b) * percent / 100));
        
        // è½¬æ¢å›åå…­è¿›åˆ¶
        return '#' + 
          newR.toString(16).padStart(2, '0') + 
          newG.toString(16).padStart(2, '0') + 
          newB.toString(16).padStart(2, '0');
      }
      
      // å…ˆç»˜åˆ¶æ‰€æœ‰ç½‘ç»„çš„è·¯çº¿å’Œç½‘ç‚¹ï¼ˆä¸åŒç½‘ç»„ç”¨ä¸åŒé¢œè‰²ï¼‰
      let groupIndex = 0;
      
      console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹ç»˜åˆ¶æ‰€æœ‰ç½‘ç»„çš„è·¯çº¿å’Œç½‘ç‚¹ï¼Œå…± ${Object.keys(groups).length} ä¸ªç½‘ç»„`);
      
      for (const [groupName, groupLocs] of Object.entries(groups)) {
        const groupColor = groupColors[groupIndex % groupColors.length];
        groupIndex++;
        
        console.log(`[è¡Œæ”¿åŒºå›¾] ç»˜åˆ¶ç½‘ç»„ ${groupName}ï¼Œå…± ${groupLocs.length} ä¸ªç½‘ç‚¹ï¼Œé¢œè‰²: ${groupColor}`);
        
        // ä¼˜åŒ–è·¯çº¿ä»¥è·å–é¡ºåº
        let optimizedLocs = groupLocs;
        try {
          const optimizeResp = await fetch('/optimize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: groupLocs })
          });
          const optimizeData = await optimizeResp.json();
          
          if (!optimizeData.error && optimizeData.route) {
            optimizedLocs = optimizeData.route;
          }
        } catch (e) {
          console.error(`ä¼˜åŒ–ç½‘ç»„ ${groupName} è·¯çº¿å¤±è´¥:`, e);
        }
        
        // å…ˆç»˜åˆ¶è·¯çº¿ï¼ˆåŠ ç²—ï¼Œé¢œè‰²åˆ†æ˜ï¼‰ï¼Œç¡®ä¿è·¯çº¿åœ¨åº•å±‚
        try {
          const optimizeResp = await fetch('/optimize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: groupLocs })
          });
          const optimizeData = await optimizeResp.json();
          
          if (!optimizeData.error && optimizeData.polyline) {
            const routePoints = optimizeData.polyline.map(p => new BMap.Point(p[0], p[1]));
            const polyline = new BMap.Polyline(routePoints, {
              strokeColor: groupColor,
              strokeWeight: 4,  // è·¯çº¿çº¿æ¡ï¼ˆç¨å¾®ç»†ä¸€ç‚¹ï¼‰
              strokeOpacity: 0.9
            });
            map.addOverlay(polyline);
            overlays.push(polyline);
          }
        } catch (e) {
          console.error(`[è¡Œæ”¿åŒºå›¾] ç»˜åˆ¶ç½‘ç»„ ${groupName} è·¯çº¿å¤±è´¥:`, e);
        }
        
        // åç»˜åˆ¶ç½‘ç‚¹ï¼ˆä½¿ç”¨ç™¾åº¦åœ°å›¾é»˜è®¤Markeræ ·å¼ï¼‰ï¼Œç¡®ä¿æ ‡è®°åœ¨ä¸Šå±‚æ˜¾ç¤º
        optimizedLocs.forEach((loc, idx) => {
          const pt = new BMap.Point(loc.lng, loc.lat);
          
          // ä½¿ç”¨ç™¾åº¦åœ°å›¾JS APIè‡ªå¸¦çš„é»˜è®¤Markeræ ·å¼
          const marker = new BMap.Marker(pt);
          map.addOverlay(marker);
          markers.push(marker);
        });
        
        console.log(`[è¡Œæ”¿åŒºå›¾] ç½‘ç»„ ${groupName} å·²ç»˜åˆ¶ ${optimizedLocs.length} ä¸ªç½‘ç‚¹æ ‡è®°`);
      }
      
      // ç­‰å¾…æ‰€æœ‰ç½‘ç»„è·¯çº¿å’Œç½‘ç‚¹ç»˜åˆ¶å®Œæˆ
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // ç°åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼ˆåœ¨è·¯çº¿å’Œç½‘ç‚¹ä¹‹ä¸Šï¼‰
      // å¦‚æœæä¾›äº†å¿åŒºå­—æ®µï¼Œç»˜åˆ¶æ‰€æœ‰ç½‘ç»„æ‰€åœ¨å¿åŒºçš„è¾¹ç•Œï¼›å¦åˆ™ç»˜åˆ¶æŸ¥è¯¢åˆ°çš„è¡Œæ”¿åŒºè¾¹ç•Œ
      console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹ç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼Œå…± ${Object.keys(districtsMap).length} ä¸ªè¡Œæ”¿åŒº`);
      
      const districtPolygons = [];
      const boundaryPromises = [];
      let colorIndex = 0;
      
      for (const [districtName, districtLocs] of Object.entries(districtsMap)) {
          const color = districtColors[colorIndex % districtColors.length];
          colorIndex++;
          
          console.log(`[è¡Œæ”¿åŒºå›¾] å¤„ç†è¡Œæ”¿åŒº: ${districtName}`);
          
          // å¦‚æœä½¿ç”¨å¿åŒºå­—æ®µï¼Œç›´æ¥ä½¿ç”¨å­—æ®µå€¼ï¼›å¦åˆ™å°è¯•ä¸åŒçš„åç§°æ ¼å¼
          let nameVariants = [];
          
          if (useDistrictField) {
            // ä½¿ç”¨å¿åŒºå­—æ®µæä¾›çš„åç§°ï¼Œç›´æ¥ä½¿ç”¨
            nameVariants.push(districtName);
            // ä¹Ÿå¯ä»¥å°è¯•ä¸€äº›å¸¸è§å˜ä½“ï¼ˆå»æ‰çœã€å¸‚ç­‰å‰ç¼€ï¼‰
            const nameWithoutProvince = districtName.replace(/^[^çœ]+çœ/, '').replace(/^[^å¸‚]+å¸‚/, '');
            if (nameWithoutProvince && nameWithoutProvince !== districtName) {
              nameVariants.push(nameWithoutProvince);
            }
            // å°è¯•å»æ‰"åŒº"ã€"å¿"ã€"å¸‚"åç¼€åçš„åç§°
            const nameWithoutSuffix = districtName.replace(/[åŒºå¿å¸‚]$/, '');
            if (nameWithoutSuffix && nameWithoutSuffix !== districtName) {
              nameVariants.push(nameWithoutSuffix);
            }
          } else {
            // å¦‚æœæ²¡æœ‰å¿åŒºå­—æ®µï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼šå°è¯•ä¸åŒçš„åç§°æ ¼å¼
            if (districtLocs && districtLocs.length > 0) {
              const firstDist = districtLocs[0];
              
              // ä¼˜å…ˆå°è¯•åŒºå¿åï¼ˆæœ€å¸¸ç”¨ï¼‰
              if (firstDist.district_level) {
                nameVariants.push(firstDist.district_level);  // "å»ºé‚ºåŒº"
              }
              
              // å°è¯•å¸‚+åŒºå¿
              if (firstDist.city && firstDist.district_level) {
                const cityName = firstDist.city.replace('å¸‚', '');
                nameVariants.push(cityName + firstDist.district_level);  // "å—äº¬å»ºé‚ºåŒº"
                nameVariants.push(firstDist.city + firstDist.district_level);  // "å—äº¬å¸‚å»ºé‚ºåŒº"
              }
            }
            
            // æœ€åå°è¯•å®Œæ•´æ ¼å¼
            nameVariants.push(districtName);  // "æ±Ÿè‹å—äº¬å¸‚å»ºé‚ºåŒº"
          }
          
          // å»é‡
          const uniqueVariants = [...new Set(nameVariants)];
          console.log(`[è¡Œæ”¿åŒºå›¾] å°†å°è¯•çš„åç§°æ ¼å¼:`, uniqueVariants);
          
          // ä½¿ç”¨PromiseåŒ…è£…Boundary APIè°ƒç”¨ï¼ˆå‚è€ƒxzqh.htmlçš„å®ç°æ–¹å¼ï¼‰
          const boundaryPromise = new Promise((resolve) => {
            let boundaryFound = false;
            let attemptIndex = 0;
            
            const tryGetBoundary = (nameToTry) => {
              console.log(`[è¡Œæ”¿åŒºå›¾] å°è¯•è·å–è¾¹ç•Œ: ${nameToTry}`);
              const boundary = new BMap.Boundary();
              boundary.get(nameToTry, (rs) => {
                console.log(`[è¡Œæ”¿åŒºå›¾] Boundary APIè¿”å›ç»“æœ:`, rs);
                if (rs && rs.boundaries && rs.boundaries.length > 0) {
                  console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æˆåŠŸè·å– ${nameToTry} çš„è¾¹ç•Œï¼Œå…± ${rs.boundaries.length} ä¸ªè¾¹ç•Œ`);
                  boundaryFound = true;
                  
                  // å‚è€ƒxzqh.htmlï¼šç›´æ¥ä½¿ç”¨boundaries[i]ä½œä¸ºå‚æ•°ä¼ ç»™Polygon
                  for (let i = 0; i < rs.boundaries.length; i++) {
                    try {
                      const polygon = new BMap.Polygon(rs.boundaries[i], {
                        strokeWeight: 3,
                        strokeColor: color,
                        strokeOpacity: 0.9,
                        fillOpacity: 0,  // ä¸å¡«å……ï¼Œåªæ˜¾ç¤ºè¾¹ç•Œçº¿
                        strokeStyle: "solid"
                      });
                      map.addOverlay(polygon);
                      overlays.push(polygon);  // æ·»åŠ åˆ°overlaysæ•°ç»„ï¼Œç¡®ä¿clearMap()èƒ½æ¸…é™¤
                      districtPolygons.push(polygon);
                      console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æˆåŠŸç»˜åˆ¶å¤šè¾¹å½¢ ${i + 1}/${rs.boundaries.length}`);
                    } catch (polyErr) {
                      console.error(`[è¡Œæ”¿åŒºå›¾] âŒ ç»˜åˆ¶å¤šè¾¹å½¢ ${i + 1} å¤±è´¥:`, polyErr);
                    }
                  }
                  resolve();
                } else {
                  // å¦‚æœå½“å‰åç§°æ ¼å¼å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª
                  attemptIndex++;
                  if (attemptIndex < uniqueVariants.length && !boundaryFound) {
                    console.log(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ${nameToTry} æœªæ‰¾åˆ°è¾¹ç•Œ (boundaries: ${rs?.boundaries?.length || 0})ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæ ¼å¼...`);
                    tryGetBoundary(uniqueVariants[attemptIndex]);
                  } else {
                    console.log(`[è¡Œæ”¿åŒºå›¾] âŒ æ‰€æœ‰æ ¼å¼éƒ½å¤±è´¥ï¼Œæ— æ³•è·å– ${districtName} çš„è¾¹ç•Œ`);
                    console.log(`[è¡Œæ”¿åŒºå›¾] å°è¯•è¿‡çš„åç§°æ ¼å¼:`, uniqueVariants);
                    resolve();  // å³ä½¿å¤±è´¥ä¹Ÿresolveï¼Œä¸é˜»å¡å…¶ä»–è¡Œæ”¿åŒºçš„ç»˜åˆ¶
                  }
                }
              });
            };
            
            // å¼€å§‹å°è¯•ç¬¬ä¸€ä¸ªåç§°æ ¼å¼
            if (uniqueVariants.length > 0) {
              tryGetBoundary(uniqueVariants[0]);
            } else {
              // å¦‚æœæ²¡æœ‰å¯ç”¨çš„åç§°å˜ä½“ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹åç§°
              tryGetBoundary(districtName);
            }
          });
          boundaryPromises.push(boundaryPromise);
        }
        
        // ç­‰å¾…æ‰€æœ‰è¾¹ç•Œç»˜åˆ¶å®Œæˆ
        await Promise.all(boundaryPromises);
        console.log(`[è¡Œæ”¿åŒºå›¾] è¾¹ç•Œç»˜åˆ¶å®Œæˆï¼Œå…± ${districtPolygons.length} ä¸ªå¤šè¾¹å½¢`);
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // æ”¶é›†æ‰€æœ‰è¾¹ç•Œç‚¹ï¼Œç”¨äºæœ€ç»ˆè°ƒæ•´è§†é‡
        const allBoundaryPoints = [];
        districtPolygons.forEach((polygon, idx) => {
          try {
            const path = polygon.getPath();
            if (path && path.length > 0) {
              path.forEach(point => {
                allBoundaryPoints.push(point);
              });
              console.log(`[è¡Œæ”¿åŒºå›¾] å¤šè¾¹å½¢ ${idx + 1} æœ‰ ${path.length} ä¸ªç‚¹`);
            }
          } catch (e) {
            console.error(`[è¡Œæ”¿åŒºå›¾] è·å–è¾¹ç•Œç‚¹å¤±è´¥ (å¤šè¾¹å½¢ ${idx + 1}):`, e);
          }
        });
        console.log(`[è¡Œæ”¿åŒºå›¾] æ€»å…±æ”¶é›†åˆ° ${allBoundaryPoints.length} ä¸ªè¾¹ç•Œç‚¹`);
        
        // åˆå¹¶æ‰€æœ‰ç‚¹ï¼ˆç½‘ç‚¹ + è¾¹ç•Œç‚¹ï¼‰ç”¨äºè°ƒæ•´è§†é‡
        const allPoints = allLocations.map(loc => new BMap.Point(loc.lng, loc.lat));
        const combinedPoints = [...allPoints, ...allBoundaryPoints];
        
        // ç­‰å¾…ä¸€ä¸‹ç¡®ä¿æ‰€æœ‰è¦†ç›–ç‰©éƒ½å·²æ·»åŠ 
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // è°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬è¡Œæ”¿è¾¹ç•Œï¼‰
        // ç›®æ ‡ï¼šåœ¨ä¿è¯è¾¹æ¡†ä¸è¢«æ§åˆ¶é¢æ¿é®æŒ¡ä¸”å®Œå…¨å¯è§çš„æƒ…å†µä¸‹ï¼Œå°½é‡ä½¿ç”¨æ›´å¤§çš„ç¼©æ”¾çº§åˆ«
        const maxZoom = 15;  // æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼Œé¿å…è¿‡è¿‘
        const minZoom = 10;  // æœ€å°ç¼©æ”¾çº§åˆ«ï¼Œé¿å…è¿‡è¿œ
        
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        
        // æ£€æŸ¥è¾¹ç•Œç‚¹æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡çš„å‡½æ•°
        const checkBoundaryOverlap = (points) => {
          let hasOverlap = false;
          for (const pt of points) {
            try {
              const pixel = map.pointToPixel(pt);
              const screenX = pixel.x;
              const screenY = pixel.y;
              
              // æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶é¢æ¿åŒºåŸŸå†…
              if (screenX >= panelLeft && screenX <= panelRight && screenY >= panelTop) {
                hasOverlap = true;
                break;
              }
            } catch (e) {
              // å¿½ç•¥è½¬æ¢å¤±è´¥çš„ç‚¹
            }
          }
          return hasOverlap;
        };
        
        if (combinedPoints.length > 0) {
          console.log(`[è¡Œæ”¿åŒºå›¾] è°ƒæ•´è§†é‡ï¼ŒåŒ…å« ${combinedPoints.length} ä¸ªç‚¹ï¼ˆ${allPoints.length} ä¸ªç½‘ç‚¹ + ${allBoundaryPoints.length} ä¸ªè¾¹ç•Œç‚¹ï¼‰`);
          // å…ˆè®¾ç½®viewporté€‚åº”æ‰€æœ‰ç‚¹ï¼ˆåŒ…æ‹¬è¾¹ç•Œç‚¹ï¼‰
          map.setViewport(combinedPoints);
          
          // ç­‰å¾…è§†é‡è°ƒæ•´å®Œæˆ
          await new Promise(resolve => setTimeout(resolve, 500));
          let currentZoom = map.getZoom();
          
          // å…ˆç¼©å°ä¸€ç‚¹ï¼Œç¡®ä¿æ‰€æœ‰è¾¹ç•Œå®Œå…¨å¯è§
          if (currentZoom > minZoom) {
            currentZoom = Math.max(minZoom, currentZoom - 1);
            map.setZoom(currentZoom);
            await new Promise(resolve => setTimeout(resolve, 300));
            console.log(`[è¡Œæ”¿åŒºå›¾] åˆæ­¥è°ƒæ•´ç¼©æ”¾çº§åˆ«ï¼Œç¡®ä¿è¾¹ç•Œå¯è§: ${map.getZoom()}`);
          }
          
          // æ£€æŸ¥è¾¹ç•Œç‚¹æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡
          let hasOverlap = checkBoundaryOverlap(allBoundaryPoints.length > 0 ? allBoundaryPoints : combinedPoints);
          
          // å¦‚æœæ²¡æœ‰è¢«é®æŒ¡ï¼Œå°è¯•é€æ­¥å¢å¤§ç¼©æ”¾çº§åˆ«ï¼Œç›´åˆ°åˆšå¥½ä¸è¢«é®æŒ¡
          if (!hasOverlap && currentZoom < maxZoom) {
            let bestZoom = currentZoom;
            // å°è¯•é€æ­¥å¢å¤§ç¼©æ”¾çº§åˆ«
            for (let testZoom = currentZoom + 1; testZoom <= maxZoom; testZoom++) {
              map.setZoom(testZoom);
              await new Promise(resolve => setTimeout(resolve, 200));
              
              // æ£€æŸ¥æ˜¯å¦è¢«é®æŒ¡
              hasOverlap = checkBoundaryOverlap(allBoundaryPoints.length > 0 ? allBoundaryPoints : combinedPoints);
              
              if (!hasOverlap) {
                bestZoom = testZoom;
                console.log(`[è¡Œæ”¿åŒºå›¾] æµ‹è¯•ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šæœªè¢«é®æŒ¡ï¼Œå¯ä»¥ç»§ç»­æ”¾å¤§`);
              } else {
                console.log(`[è¡Œæ”¿åŒºå›¾] æµ‹è¯•ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šè¢«é®æŒ¡ï¼Œå›é€€åˆ° ${bestZoom}`);
                map.setZoom(bestZoom);
                await new Promise(resolve => setTimeout(resolve, 200));
                break;
              }
            }
            console.log(`[è¡Œæ”¿åŒºå›¾] æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${bestZoom}ï¼ˆåœ¨ä¿è¯è¾¹æ¡†å¯è§ä¸”ä¸è¢«é®æŒ¡çš„æƒ…å†µä¸‹å°½é‡æ”¾å¤§ï¼‰`);
          } else if (hasOverlap) {
            // å¦‚æœè¢«é®æŒ¡ï¼Œç¼©å°åˆ°åˆé€‚å¤§å°
            while (hasOverlap && currentZoom > minZoom) {
              currentZoom = Math.max(minZoom, currentZoom - 1);
              map.setZoom(currentZoom);
              await new Promise(resolve => setTimeout(resolve, 200));
              hasOverlap = checkBoundaryOverlap(allBoundaryPoints.length > 0 ? allBoundaryPoints : combinedPoints);
              console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${currentZoom}ï¼š${hasOverlap ? 'ä»è¢«é®æŒ¡' : 'æœªè¢«é®æŒ¡'}`);
            }
            console.log(`[è¡Œæ”¿åŒºå›¾] æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${currentZoom}ï¼ˆå·²é¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          } else {
            console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ«åˆé€‚: ${currentZoom}ï¼ˆå·²ç¡®ä¿æ‰€æœ‰è¡Œæ”¿åŒºè¾¹æ¡†å®Œå…¨å¯è§ä¸”ä¸è¢«é®æŒ¡ï¼‰`);
          }
          
          // å†æ¬¡ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾å®Œå…¨æ¸²æŸ“
          await new Promise(resolve => setTimeout(resolve, 500));
        } else if (allBoundaryPoints.length > 0) {
          // å¦‚æœåªæœ‰è¾¹ç•Œç‚¹ï¼Œä½¿ç”¨è¾¹ç•Œç‚¹è°ƒæ•´è§†é‡
          console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨è¾¹ç•Œç‚¹è°ƒæ•´è§†é‡ï¼Œå…± ${allBoundaryPoints.length} ä¸ªç‚¹`);
          map.setViewport(allBoundaryPoints);
          await new Promise(resolve => setTimeout(resolve, 500));
          let currentZoom = map.getZoom();
          
          // å…ˆç¼©å°ä¸€ç‚¹ï¼Œç¡®ä¿æ‰€æœ‰è¾¹ç•Œå®Œå…¨å¯è§
          if (currentZoom > minZoom) {
            currentZoom = Math.max(minZoom, currentZoom - 1);
            map.setZoom(currentZoom);
            await new Promise(resolve => setTimeout(resolve, 300));
          }
          
          // æ£€æŸ¥è¾¹ç•Œç‚¹æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡
          let hasOverlap = checkBoundaryOverlap(allBoundaryPoints);
          
          // å¦‚æœæ²¡æœ‰è¢«é®æŒ¡ï¼Œå°è¯•é€æ­¥å¢å¤§ç¼©æ”¾çº§åˆ«
          if (!hasOverlap && currentZoom < maxZoom) {
            let bestZoom = currentZoom;
            for (let testZoom = currentZoom + 1; testZoom <= maxZoom; testZoom++) {
              map.setZoom(testZoom);
              await new Promise(resolve => setTimeout(resolve, 200));
              hasOverlap = checkBoundaryOverlap(allBoundaryPoints);
              if (!hasOverlap) {
                bestZoom = testZoom;
              } else {
                map.setZoom(bestZoom);
                await new Promise(resolve => setTimeout(resolve, 200));
                break;
              }
            }
            console.log(`[è¡Œæ”¿åŒºå›¾] æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${bestZoom}`);
          } else if (hasOverlap) {
            while (hasOverlap && currentZoom > minZoom) {
              currentZoom = Math.max(minZoom, currentZoom - 1);
              map.setZoom(currentZoom);
              await new Promise(resolve => setTimeout(resolve, 200));
              hasOverlap = checkBoundaryOverlap(allBoundaryPoints);
            }
            console.log(`[è¡Œæ”¿åŒºå›¾] æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${currentZoom}ï¼ˆå·²é¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          }
          
          await new Promise(resolve => setTimeout(resolve, 500));
        } else if (allPoints.length > 0) {
          // å¦‚æœåªæœ‰ç½‘ç‚¹ï¼Œä½¿ç”¨ç½‘ç‚¹è°ƒæ•´è§†é‡
          console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨ç½‘ç‚¹è°ƒæ•´è§†é‡ï¼Œå…± ${allPoints.length} ä¸ªç‚¹`);
          map.setViewport(allPoints);
          await new Promise(resolve => setTimeout(resolve, 500));
          const currentZoom = map.getZoom();
          
          if (currentZoom > maxZoom) {
            map.setZoom(maxZoom);
            console.log(`[è¡Œæ”¿åŒºå›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${maxZoom}ï¼ˆé™åˆ¶æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼‰`);
          } else {
            console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ«åˆé€‚: ${currentZoom}ï¼ˆç½‘ç‚¹æ•°é‡: ${allPoints.length}ï¼‰`);
          }
        }
        
        // ç­‰å¾…æ¸²æŸ“å®Œæˆ
        console.log('[è¡Œæ”¿åŒºå›¾] ç­‰å¾…åœ°å›¾æ¸²æŸ“å®Œæˆ...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        console.log('[è¡Œæ”¿åŒºå›¾] å¼€å§‹æˆªå›¾...');
        // æˆªå›¾ï¼ˆä½¿ç”¨ç‰¹æ®Šæ ‡è®°è¡¨ç¤ºè¿™æ˜¯è¡Œæ”¿åŒºå›¾ï¼‰
        // è¡Œæ”¿åŒºå›¾ä¸éœ€è¦adjustmentå­—æ®µ
        await captureScreenshot('__DISTRICT_MAP__', employeeId, employeeName, adjustment);
        console.log('[è¡Œæ”¿åŒºå›¾] æˆªå›¾å®Œæˆ');
        
        // æˆªå›¾å®Œæˆåï¼Œæ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰è¦†ç›–ç‰©ï¼ˆè·¯çº¿ã€è¾¹æ¡†ã€ç½‘ç‚¹åœ†åœˆï¼‰ï¼Œé¿å…å½±å“ä¸‹ä¸€ä¸ªå‘˜å·¥
        console.log('[è¡Œæ”¿åŒºå›¾] æ¸…é™¤åœ°å›¾è¦†ç›–ç‰©ï¼Œå‡†å¤‡ä¸‹ä¸€ä¸ªå‘˜å·¥çš„æ•°æ®...');
        clearMap();
        // ç­‰å¾…æ¸…é™¤å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
        console.log('[è¡Œæ”¿åŒºå›¾] åœ°å›¾å·²æ¸…é™¤ï¼Œå¯ä»¥å¤„ç†ä¸‹ä¸€ä¸ªå‘˜å·¥çš„æ•°æ®');
        
    } catch (e) {
      console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
      // å³ä½¿å‡ºé”™ä¹Ÿè¦æ¸…é™¤åœ°å›¾ï¼Œé¿å…å½±å“ä¸‹ä¸€ä¸ªå‘˜å·¥
      try {
        clearMap();
      } catch (clearErr) {
        console.error('æ¸…é™¤åœ°å›¾å¤±è´¥:', clearErr);
      }
      throw e;
    }
  }

    function colorByIndex(i, total) {
      return '#2196F3';
    }

    function createNumberMarker(point, number, total) {
      const markerContent = document.createElement('div');
      const bgColor = colorByIndex(number - 1, total);
      markerContent.style.cssText = `
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background: ${bgColor};
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        border: 3px solid white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        position: absolute;
        z-index: 10000;
        pointer-events: none;
        cursor: pointer;
      `;
      markerContent.innerHTML = String(number);
      markerContent.setAttribute('data-marker-number', number);

      const icon = new BMap.Icon(
        "data:image/svg+xml;base64," + btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="1" height="1"></svg>`),
        new BMap.Size(1, 1)
      );

      const marker = new BMap.Marker(point, {
        icon,
        offset: new BMap.Size(0, 0),
        enableDragging: false
      });
      marker.setLabel(new BMap.Label('', { offset: new BMap.Size(-9999, -9999) }));

      function NumberMarkerOverlay(point, content) {
        this._point = point;
        this._content = content;
      }
      
      NumberMarkerOverlay.prototype = new BMap.Overlay();
      NumberMarkerOverlay.prototype.initialize = function(map) {
        this._map = map;
        const pane = map.getPanes().markerPane || map.getPanes().labelPane;
        if (pane) {
          pane.appendChild(this._content);
          this._pane = pane;
        }
        return this._content;
      };
      
      NumberMarkerOverlay.prototype.draw = function() {
        if (this._content && this._map) {
          try {
            const pixel = this._map.pointToOverlayPixel(this._point);
            this._content.style.position = 'absolute';
            this._content.style.left = (pixel.x - 17.5) + 'px';
            this._content.style.top = (pixel.y - 17.5) + 'px';
            this._content.style.display = 'flex';
            this._content.style.visibility = 'visible';
            this._content.style.zIndex = '10000';
          } catch(e) {
            console.warn('ç»˜åˆ¶æ ‡è®°å¤±è´¥:', e);
          }
        }
      };
      
      const overlay = new NumberMarkerOverlay(point, markerContent);

      map.addOverlay(overlay);
      overlays.push(overlay);
      
      setTimeout(() => {
        if (overlay.draw) {
          overlay.draw();
        }
      }, 100);

      return marker;
    }

    async function drawPoints(locations) {
      clearMap();
      if (!map || !locations.length) return;

      const pts = [];
      locations.forEach((loc, idx) => {
        const pt = new BMap.Point(loc.lng, loc.lat);
        pts.push(pt);

        const marker = createNumberMarker(pt, idx + 1, locations.length);
        map.addOverlay(marker);
        markers.push(marker);

        const labelText = loc.remark ? `${idx + 1}. ${loc.remark}` : `${idx + 1}. ${loc.name}`;
        const offsetX = (idx % 2 === 0) ? 30 : -30;
        const offsetY = (idx % 4 < 2) ? -15 : 10;
        const label = new BMap.Label(labelText, { offset: new BMap.Size(offsetX, offsetY) });
        label.setStyle({
          background: 'white',
          border: '2px solid #2196F3',
          padding: '5px 10px',
          borderRadius: '5px',
          fontSize: '13px',
          fontWeight: 'bold',
          boxShadow: '0 2px 6px rgba(0,0,0,0.3)',
          whiteSpace: 'nowrap',
          zIndex: 10000  // ç½‘ç‚¹åç§°æ ‡ç­¾æœ€é«˜ä¼˜å…ˆçº§ï¼Œç¡®ä¿åœ¨æ‰€æœ‰è·ç¦»æ ‡ç­¾ä¸Šæ–¹
        });
        marker.setLabel(label);

        // é€šè¿‡DOMç›´æ¥è®¾ç½®z-indexï¼Œç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚
        setTimeout(() => {
          try {
            const labelElement = label.getContent();
            if (labelElement && labelElement.style) {
              labelElement.style.zIndex = '10000';
              labelElement.style.position = 'relative';
            }
          } catch(e) {
            // å¿½ç•¥é”™è¯¯
          }
        }, 100);

        const infoHtml = `
          <div style="padding:10px;">
            <h4 style="margin:0 0 10px 0;color:#3366FF;">ç¬¬ ${idx + 1} ç«™ï¼š${loc.name}</h4>
            ${loc.remark ? `<p style="margin:5px 0;font-size:14px;color:#FF9800;font-weight:bold;">${loc.remark}</p>` : '<p style="margin:5px 0;font-size:12px;color:#999;">æ— å¤‡æ³¨</p>'}
            <p style="margin:5px 0;font-size:12px;color:#666;">ç»åº¦: ${loc.lng}</p>
            <p style="margin:5px 0;font-size:12px;color:#666;">çº¬åº¦: ${loc.lat}</p>
          </div>`;
        marker.addEventListener('click', () => {
          const win = new BMap.InfoWindow(infoHtml);
          map.openInfoWindow(win, pt);
        });
      });

      // è°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰ç½‘ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡
      if (pts.length > 0) {
        // å…ˆè®¾ç½®viewporté€‚åº”æ‰€æœ‰ç½‘ç‚¹
        map.setViewport(pts);
        
        // ç­‰å¾…è§†é‡è°ƒæ•´å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç½‘ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        
        let hasOverlap = false;
        for (const pt of pts) {
          // å°†åœ°å›¾åæ ‡è½¬æ¢ä¸ºå±å¹•åƒç´ åæ ‡
          const pixel = map.pointToPixel(pt);
          const screenX = pixel.x;
          const screenY = pixel.y;
          
          // æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶é¢æ¿åŒºåŸŸå†…
          if (screenX >= panelLeft && screenX <= panelRight && screenY >= panelTop) {
            hasOverlap = true;
            console.log(`[åœ°å›¾è§†å›¾] æ£€æµ‹åˆ°ç½‘ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡: (${screenX}, ${screenY})`);
            break;
          }
        }
        
        // åªæœ‰å½“æœ‰ç½‘ç‚¹è¢«é®æŒ¡æ—¶ï¼Œæ‰ç¼©å°åœ°å›¾
        if (hasOverlap) {
          const currentZoom = map.getZoom();
          if (currentZoom > 10) {
            // ç¼©å°1ä¸ªçº§åˆ«ï¼Œç¡®ä¿å·¦ä¾§ç½‘ç‚¹ä¸è¢«æ§åˆ¶é¢æ¿é®æŒ¡
            const adjustedZoom = Math.max(10, currentZoom - 1);
            map.setZoom(adjustedZoom);
            console.log(`[åœ°å›¾è§†å›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${adjustedZoom}ï¼ˆé¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          }
        } else {
          console.log(`[åœ°å›¾è§†å›¾] æ‰€æœ‰ç½‘ç‚¹æœªè¢«æ§åˆ¶é¢æ¿é®æŒ¡ï¼Œä¿æŒå½“å‰ç¼©æ”¾çº§åˆ«: ${map.getZoom()}`);
        }
      }
    }

    async function drawRouteResult(result, autoScreenshot = true) {
      console.log('drawRouteResult æ¥æ”¶åˆ°çš„æ•°æ®:', result);
      const { route, polyline, legs, total_distance, total_duration, farthest_points } = result;

      clearMap();
      if (!map || !route.length) return;

      // ç¬¬ä¸€æ­¥ï¼šç»˜åˆ¶è·¯çº¿å’Œè·ç¦»æ ‡è®°ï¼ˆå…ˆç»˜åˆ¶åº•å±‚å…ƒç´ ï¼‰
      if (polyline && polyline.length) {
        const routePts = polyline.map(p => new BMap.Point(p[0], p[1]));
        const line = new BMap.Polyline(routePts, { strokeWeight: 4, strokeOpacity: 0.9, strokeColor: "#2196F3" });
        map.addOverlay(line);
        overlays.push(line);
        
        // ç»˜åˆ¶è·ç¦»æ ‡è®°ï¼ˆåº•å±‚ï¼Œz-index: 1000ï¼‰
        distanceLabels = [];  // æ¸…ç©ºä¹‹å‰çš„è·ç¦»æ ‡ç­¾å¼•ç”¨
        if (legs && legs.length > 0) {
          legs.forEach((leg) => {
            if (leg.mid_point && leg.mid_point.length === 2) {
              const midPoint = new BMap.Point(leg.mid_point[0], leg.mid_point[1]);
              const label = new BMap.Label(leg.distance_text, { offset: new BMap.Size(10, -10) });
              label.setStyle({
                background: 'rgba(255, 152, 0, 0.95)',
                color: 'white',
                border: '2px solid white',
                padding: '5px 10px',
                borderRadius: '5px',
                fontSize: '12px',
                fontWeight: 'bold',
                boxShadow: '0 2px 6px rgba(0,0,0,0.4)',
                whiteSpace: 'nowrap',
                zIndex: 1000  // è·ç¦»æ ‡è®°åœ¨åº•å±‚ï¼ˆä½äºç½‘ç‚¹åç§°æ ‡ç­¾çš„10000ï¼‰
              });
              label.setPosition(midPoint);
              map.addOverlay(label);
              overlays.push(label);
              distanceLabels.push(label);  // ä¿å­˜å¼•ç”¨ï¼Œç”¨äºæ§åˆ¶æ˜¾ç¤º/éšè—
            }
          });
        }
        
        // æ ¹æ®å¼€å…³çŠ¶æ€è®¾ç½®è·ç¦»æ ‡ç­¾çš„æ˜¾ç¤º
        toggleDistanceLabels();

        // è°ƒæ•´è§†é‡ä»¥é€‚åº”è·¯çº¿ï¼Œæ£€æŸ¥æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        map.setViewport(routePts);
        
        // ç­‰å¾…è§†é‡è°ƒæ•´å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è·¯çº¿ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        
        let hasOverlap = false;
        for (const pt of routePts) {
          // å°†åœ°å›¾åæ ‡è½¬æ¢ä¸ºå±å¹•åƒç´ åæ ‡
          const pixel = map.pointToPixel(pt);
          const screenX = pixel.x;
          const screenY = pixel.y;
          
          // æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶é¢æ¿åŒºåŸŸå†…
          if (screenX >= panelLeft && screenX <= panelRight && screenY >= panelTop) {
            hasOverlap = true;
            console.log(`[åœ°å›¾è§†å›¾] æ£€æµ‹åˆ°è·¯çº¿ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡: (${screenX}, ${screenY})`);
            break;
          }
        }
        
        // åªæœ‰å½“æœ‰è·¯çº¿ç‚¹è¢«é®æŒ¡æ—¶ï¼Œæ‰ç¼©å°åœ°å›¾
        if (hasOverlap) {
          const currentZoom = map.getZoom();
          if (currentZoom > 10) {
            // ç¼©å°1ä¸ªçº§åˆ«ï¼Œç¡®ä¿å·¦ä¾§å†…å®¹ä¸è¢«æ§åˆ¶é¢æ¿é®æŒ¡
            const adjustedZoom = Math.max(10, currentZoom - 1);
            map.setZoom(adjustedZoom);
            console.log(`[åœ°å›¾è§†å›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${adjustedZoom}ï¼ˆé¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          }
        } else {
          console.log(`[åœ°å›¾è§†å›¾] æ‰€æœ‰è·¯çº¿ç‚¹æœªè¢«æ§åˆ¶é¢æ¿é®æŒ¡ï¼Œä¿æŒå½“å‰ç¼©æ”¾çº§åˆ«: ${map.getZoom()}`);
        }
      }

      // ç¬¬äºŒæ­¥ï¼šç»˜åˆ¶æ ‡è®°ç‚¹ï¼ˆåç»˜åˆ¶ï¼Œç¡®ä¿åœ¨ä¸Šå±‚ï¼‰
      const pts = [];
      route.forEach((loc, idx) => {
        const pt = new BMap.Point(loc.lng, loc.lat);
        pts.push(pt);

        const marker = createNumberMarker(pt, idx + 1, route.length);
        map.addOverlay(marker);
        markers.push(marker);

        // ç½‘ç‚¹åç§°æ ‡ç­¾ï¼ˆç¡®ä¿åœ¨æ‰€æœ‰è·ç¦»æ ‡ç­¾ä¸Šæ–¹ï¼ŒåŒ…æ‹¬é»„è‰²è·ç¦»æ ‡ç­¾ï¼‰
        const labelText = loc.remark ? `${idx + 1}. ${loc.remark}` : `${idx + 1}. ${loc.name}`;
        const offsetX = (idx % 2 === 0) ? 30 : -30;
        const offsetY = (idx % 4 < 2) ? -15 : 10;
        const label = new BMap.Label(labelText, { offset: new BMap.Size(offsetX, offsetY) });
        label.setStyle({
          background: 'white',
          border: '2px solid #2196F3',
          padding: '5px 10px',
          borderRadius: '5px',
          fontSize: '13px',
          fontWeight: 'bold',
          boxShadow: '0 2px 6px rgba(0,0,0,0.3)',
          whiteSpace: 'nowrap',
          zIndex: 10000  // ç½‘ç‚¹åç§°æ ‡ç­¾æœ€é«˜ä¼˜å…ˆçº§ï¼Œç¡®ä¿åœ¨æ‰€æœ‰è·ç¦»æ ‡ç­¾ä¸Šæ–¹
        });
        marker.setLabel(label);

        // é€šè¿‡DOMç›´æ¥è®¾ç½®z-indexï¼Œç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚
        setTimeout(() => {
          try {
            const labelElement = label.getContent();
            if (labelElement && labelElement.style) {
              labelElement.style.zIndex = '10000';
              labelElement.style.position = 'relative';
            }
          } catch(e) {
            // å¿½ç•¥é”™è¯¯
          }
        }, 100);

        const infoHtml = `
          <div style="padding:10px;">
            <h4 style="margin:0 0 10px 0;color:#3366FF;">ç¬¬ ${idx + 1} ç«™ï¼š${loc.name}</h4>
            ${loc.remark ? `<p style="margin:5px 0;font-size:14px;color:#FF9800;font-weight:bold;">${loc.remark}</p>` : '<p style="margin:5px 0;font-size:12px;color:#999;">æ— å¤‡æ³¨</p>'}
            <p style="margin:5px 0;font-size:12px;color:#666;">ç»åº¦: ${loc.lng}</p>
            <p style="margin:5px 0;font-size:12px;color:#666;">çº¬åº¦: ${loc.lat}</p>
          </div>`;
        marker.addEventListener('click', () => {
          const win = new BMap.InfoWindow(infoHtml);
          map.openInfoWindow(win, pt);
        });
      });

      // å¦‚æœæ²¡æœ‰è·¯çº¿ï¼Œåªè®¾ç½®æ ‡è®°ç‚¹çš„è§†å›¾
      if (!polyline || !polyline.length) {
        // è°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰ç½‘ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        map.setViewport(pts);
        
        // ç­‰å¾…è§†é‡è°ƒæ•´å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç½‘ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        
        let hasOverlap = false;
        for (const pt of pts) {
          // å°†åœ°å›¾åæ ‡è½¬æ¢ä¸ºå±å¹•åƒç´ åæ ‡
          const pixel = map.pointToPixel(pt);
          const screenX = pixel.x;
          const screenY = pixel.y;
          
          // æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶é¢æ¿åŒºåŸŸå†…
          if (screenX >= panelLeft && screenX <= panelRight && screenY >= panelTop) {
            hasOverlap = true;
            console.log(`[åœ°å›¾è§†å›¾] æ£€æµ‹åˆ°ç½‘ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡: (${screenX}, ${screenY})`);
            break;
          }
        }
        
        // åªæœ‰å½“æœ‰ç½‘ç‚¹è¢«é®æŒ¡æ—¶ï¼Œæ‰ç¼©å°åœ°å›¾
        if (hasOverlap) {
          const currentZoom = map.getZoom();
          if (currentZoom > 10) {
            // ç¼©å°1ä¸ªçº§åˆ«ï¼Œç¡®ä¿å·¦ä¾§ç½‘ç‚¹ä¸è¢«æ§åˆ¶é¢æ¿é®æŒ¡
            const adjustedZoom = Math.max(10, currentZoom - 1);
            map.setZoom(adjustedZoom);
            console.log(`[åœ°å›¾è§†å›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${adjustedZoom}ï¼ˆé¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          }
        } else {
          console.log(`[åœ°å›¾è§†å›¾] æ‰€æœ‰ç½‘ç‚¹æœªè¢«æ§åˆ¶é¢æ¿é®æŒ¡ï¼Œä¿æŒå½“å‰ç¼©æ”¾çº§åˆ«: ${map.getZoom()}`);
        }
      }

      // å¼ºåˆ¶åˆ·æ–°æ ‡è®°ç‚¹æ ‡ç­¾ï¼Œç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚ï¼ˆåœ¨æ‰€æœ‰è·ç¦»æ ‡ç­¾ä¸Šæ–¹ï¼‰
      setTimeout(() => {
        markers.forEach((marker, idx) => {
          try {
            const currentLabel = marker.getLabel();
            if (currentLabel) {
              // é‡æ–°è®¾ç½®æ ‡ç­¾æ ·å¼ï¼Œç¡®ä¿zIndexç”Ÿæ•ˆ
              const style = currentLabel.getStyle();
              if (style) {
                style.zIndex = 10000;  // æœ€é«˜ä¼˜å…ˆçº§
                currentLabel.setStyle(style);
              }
              // é€šè¿‡DOMç›´æ¥è®¾ç½®z-index
              try {
                const labelElement = currentLabel.getContent();
                if (labelElement && labelElement.style) {
                  labelElement.style.zIndex = '10000';
                  labelElement.style.position = 'relative';
                }
              } catch(e) {
                // å¿½ç•¥DOMæ“ä½œé”™è¯¯
              }
            }
          } catch(e) {
            // å¿½ç•¥é”™è¯¯
          }
        });
      }, 200);

      // âœ… ç¬¬ä¸‰æ­¥ï¼šå»¶è¿Ÿç»˜åˆ¶"æœ€è¿œç›´çº¿"ï¼ˆç¡®ä¿åœ¨è·¯çº¿ç»˜åˆ¶å®Œæˆåï¼‰
      setTimeout(() => {
        drawFarthestLine(farthest_points);
      }, 100);

      // å¼ºåˆ¶é‡ç»˜è‡ªå®šä¹‰ overlayï¼ˆåœ†åœˆæ•°å­—ï¼‰
      setTimeout(() => {
        overlays.forEach(overlay => {
          if (overlay && overlay.draw) {
            try { overlay.draw(); } catch(e) {}
          }
        });
      }, 200);

      // ä¿å­˜å½“å‰è·¯çº¿ç»“æœ
      currentRouteResult = result;
      
      // è·å–å½“å‰ç®€ç‰ˆæ¨¡å¼çŠ¶æ€
      routeSimpleMode = document.getElementById('toggleRouteSimple')?.checked ?? false;
      
      // æ›´æ–°è·¯çº¿è¯¦æƒ…æ˜¾ç¤º
      updateRouteInfo(result, routeSimpleMode);
      
      // è‡ªåŠ¨æ»šåŠ¨æ§åˆ¶é¢æ¿åˆ°åº•éƒ¨
      setTimeout(() => {
        const panel = document.getElementById('control-panel');
        if (panel) {
          panel.scrollTo({
            top: panel.scrollHeight,
            behavior: 'smooth'
          });
          
          // åªæœ‰åœ¨ autoScreenshot ä¸º true æ—¶æ‰è‡ªåŠ¨æˆªå›¾ï¼ˆæ‰¹é‡å¤„ç†æ—¶ä¸ä¼šè‡ªåŠ¨æˆªå›¾ï¼Œé¿å…é‡å¤ï¼‰
          if (autoScreenshot) {
            // æ»šåŠ¨å®Œæˆåï¼Œå»¶è¿Ÿæ‰§è¡Œæˆªå›¾ï¼ˆç¡®ä¿å†…å®¹å®Œå…¨æ˜¾ç¤ºï¼‰
            setTimeout(() => {
              captureScreenshot();
            }, 1500);  // ç­‰å¾…æ»šåŠ¨åŠ¨ç”»å®Œæˆåå†æˆªå›¾
          }
        }
      }, 100);
    }

    function formatMeters(m) {
      if (m >= 1000) return (m / 1000).toFixed(2) + " å…¬é‡Œ";
      return Math.round(m) + " ç±³";
    }
    function formatSeconds(s) {
      s = Math.round(s);
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      if (h > 0) return `${h}å°æ—¶${m}åˆ†é’Ÿ`;
      return `${m}åˆ†é’Ÿ`;
    }

    // æŒ‰ç½‘ç»„åˆ†ç»„å¤„ç†
    // æŒ‰å·¥å·åˆ†ç»„
    function groupLocationsByEmployee(locations) {
      const employees = {};
      locations.forEach(loc => {
        const employeeId = loc.employee_id || '';
        if (employeeId && employeeId.trim()) {
          if (!employees[employeeId]) {
            employees[employeeId] = {
              employee_id: employeeId,
              employee_name: loc.employee_name || '',
              groups: {}
            };
          }
          const group = loc.group || 'æœªåˆ†ç»„';
          if (!employees[employeeId].groups[group]) {
            employees[employeeId].groups[group] = [];
          }
          employees[employeeId].groups[group].push(loc);
        }
      });
      return employees;
    }

    function groupLocationsByGroup(locations) {
      const groups = {};
      for (const loc of locations) {
        const group = (loc.group || '').trim();
        const groupKey = group || 'æœªåˆ†ç»„';
        if (!groups[groupKey]) {
          groups[groupKey] = [];
        }
        groups[groupKey].push(loc);
      }
      return groups;
    }

    async function calculateRoute() {
      const locations = currentLocations.length ? currentLocations : parseLocationData();
      if (locations.length < 2) return showError('è‡³å°‘éœ€è¦2ä¸ªç½‘ç‚¹ï¼');

      // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å·¥å·ï¼Œå¦‚æœæœ‰å·¥å·åˆ™æŒ‰å·¥å·åˆ†ç»„å¤„ç†
      const employees = groupLocationsByEmployee(locations);
      if (employees && Object.keys(employees).length > 0) {
        excelEmployees = employees;
        startBatchProcessByEmployee();
        return;
      }

      // æŒ‰ç½‘ç»„åˆ†ç»„
      const groups = groupLocationsByGroup(locations);
      const groupKeys = Object.keys(groups);
      
      // å¦‚æœæœ‰å¤šä¸ªç½‘ç»„ï¼Œè‡ªåŠ¨æŒ‰ç»„ä¾æ¬¡å¤„ç†
      if (groupKeys.length > 1 || (groupKeys.length === 1 && groupKeys[0] !== 'æœªåˆ†ç»„')) {
        excelGroups = groups;
        startBatchProcess();
        return;
      }

      // å•ä¸ªç»„æˆ–æ— åˆ†ç»„ï¼Œç›´æ¥å¤„ç†
      showLoading('ğŸ“ æ­£åœ¨æŒ‰åºè®¡ç®—é©¾è½¦è·¯çº¿...');
      try {
        const resp = await fetch('/calculate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ locations })
        });
        const data = await resp.json();
        if (data.error) return showError(data.error);
        await drawRouteResult(data);
      } catch (e) {
        showError('è®¡ç®—å¤±è´¥ï¼š' + e);
      }
    }

    async function optimizeRoute() {
      const locations = currentLocations.length ? currentLocations : parseLocationData();
      if (locations.length < 2) return showError('è‡³å°‘éœ€è¦2ä¸ªç½‘ç‚¹ï¼');

      // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å·¥å·ï¼Œå¦‚æœæœ‰å·¥å·åˆ™æŒ‰å·¥å·åˆ†ç»„å¤„ç†
      const employees = groupLocationsByEmployee(locations);
      if (employees && Object.keys(employees).length > 0) {
        excelEmployees = employees;
        startBatchProcessByEmployee();
        return;
      }

      // æŒ‰ç½‘ç»„åˆ†ç»„
      const groups = groupLocationsByGroup(locations);
      const groupKeys = Object.keys(groups);
      
      // å¦‚æœæœ‰å¤šä¸ªç½‘ç»„ï¼Œè‡ªåŠ¨æŒ‰ç»„ä¾æ¬¡å¤„ç†
      if (groupKeys.length > 1 || (groupKeys.length === 1 && groupKeys[0] !== 'æœªåˆ†ç»„')) {
        excelGroups = groups;
        startBatchProcess();
        return;
      }

      // å•ä¸ªç»„æˆ–æ— åˆ†ç»„ï¼Œç›´æ¥å¤„ç†
      const startName = document.getElementById('startPoint').value.trim() || null;
      showLoading('ğŸ”„ æ­£åœ¨ä¼˜åŒ–é¡ºåºå¹¶è§„åˆ’é©¾è½¦è·¯çº¿...');

      try {
        const resp = await fetch('/optimize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ locations, start_name: startName })
        });
        const data = await resp.json();
        if (data.error) return showError(data.error);
        await drawRouteResult(data);
      } catch (e) {
        showError('ä¼˜åŒ–å¤±è´¥ï¼š' + e);
      }
    }

    // æ‰‹åŠ¨æˆªå›¾åŠŸèƒ½ï¼ˆå¸¦æ»šåŠ¨æ§åˆ¶é¢æ¿ï¼‰
    async function manualCaptureScreenshot() {
      // å…ˆæ»šåŠ¨æ§åˆ¶é¢æ¿åˆ°åº•éƒ¨ï¼Œç¡®ä¿æ˜¾ç¤ºæœ€æ–°å†…å®¹
      const panel = document.getElementById('control-panel');
      if (panel) {
        panel.scrollTo({
          top: panel.scrollHeight,
          behavior: 'smooth'
        });
        // ç­‰å¾…æ»šåŠ¨å®Œæˆåå†æˆªå›¾
        setTimeout(() => {
          captureScreenshot();
        }, 800);
      } else {
        captureScreenshot();
      }
    }

    // æˆªå›¾åŠŸèƒ½
    async function captureScreenshot(groupName = '', employeeId = '', employeeName = '', adjustment = '') {
      // è·å–å½“å‰çš„UIçŠ¶æ€ï¼ˆå¤é€‰æ¡†çŠ¶æ€ï¼‰
      const uiState = {
        showFarthestLine: document.getElementById('toggleFarthest')?.checked ?? true,
        showDistanceLabels: document.getElementById('toggleDistanceLabels')?.checked ?? true,
        showRouteSimple: document.getElementById('toggleRouteSimple')?.checked ?? false
      };
      
      // åˆ¤æ–­æ˜¯å¦ä¸ºè¡Œæ”¿åŒºå›¾
      const isDistrictMap = groupName === '__DISTRICT_MAP__';
      const displayName = isDistrictMap ? 'è¡Œæ”¿åŒºå›¾' : (groupName ? 'ç½‘ç»„ ' + groupName : '');
      
      // æ˜¾ç¤ºæˆªå›¾æç¤ºåœ¨çŠ¶æ€åŒºåŸŸï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
      updateStatus(`ğŸ“¸ æ­£åœ¨æˆªå›¾${displayName}...`, 'loading');
      
      // è®¾ç½®è¶…æ—¶å¤„ç†ï¼ˆ30ç§’è¶…æ—¶ï¼‰
      const timeoutId = setTimeout(() => {
        updateStatus('âŒ æˆªå›¾è¶…æ—¶ï¼ˆ30ç§’ï¼‰ï¼Œè¯·æ£€æŸ¥Edgeæµè§ˆå™¨å’Œç½‘ç»œè¿æ¥', 'error');
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
      }, 30000);
      
      try {
        const controller = new AbortController();
        const timeoutSignal = setTimeout(() => controller.abort(), 30000);
        
        const resp = await fetch('/capture_screenshot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ui_state: uiState,
            group_name: groupName,
            employee_id: employeeId,
            employee_name: employeeName,
            adjustment: adjustment
          }),
          signal: controller.signal
        });
        
        clearTimeout(timeoutSignal);
        clearTimeout(timeoutId);
        
        const data = await resp.json();
        
        // æ›´æ–°çŠ¶æ€åŒºåŸŸï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
        if (data.error) {
          updateStatus(`âŒ æˆªå›¾å¤±è´¥ï¼š${data.error}`, 'error');
          // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
          setTimeout(() => {
            updateStatus('å°±ç»ª', 'ready');
          }, 10000);
          return;
        }
        
        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        updateStatus(`âœ… æˆªå›¾å·²ä¿å­˜: ${data.filename}`, 'success');
        
        // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
        
        console.log('æˆªå›¾ä¿å­˜æˆåŠŸ:', data.filepath);
      } catch (e) {
        clearTimeout(timeoutId);
        
        // æ›´æ–°çŠ¶æ€åŒºåŸŸæ˜¾ç¤ºé”™è¯¯ï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
        if (e.name === 'AbortError') {
          updateStatus('âŒ æˆªå›¾è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥Edgeæµè§ˆå™¨å’Œç½‘ç»œè¿æ¥', 'error');
        } else {
          updateStatus(`âŒ æˆªå›¾å¤±è´¥ï¼š${e.message || String(e)}`, 'error');
        }
        // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
        console.error('æˆªå›¾è¯·æ±‚å¤±è´¥:', e);
      }
    }
  </script>
</body>
</html>