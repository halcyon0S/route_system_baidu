<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç½‘ç‚¹è·¯çº¿ä¼˜åŒ–ç³»ç»Ÿï¼ˆç™¾åº¦åœ°å›¾ç‰ˆï¼‰</title>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: "Microsoft YaHei", "PingFang SC", Arial, sans-serif; }
    #container { width: 100%; height: 100vh; }
    #control-panel {
      position: absolute; top: 20px; left: 20px; background: white;
      padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      max-width: 380px; z-index: 1000; max-height: 85vh; overflow-y: auto; overflow-x: auto;
    }
    h2 { margin-bottom: 15px; color: #333; font-size: 18px; }
    .input-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; font-size: 13px; }
    textarea, input[type="text"], input[type="file"] {
      width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;
      font-size: 12px; font-family: inherit;
    }
    textarea { resize: vertical; }
    input[type="file"] { padding: 8px; }
    .btn {
      padding: 10px 20px; margin: 5px 5px 5px 0; border: none; border-radius: 5px;
      cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s;
    }
    .btn-primary { background: #3366FF; color: white; }
    .btn-primary:hover { background: #2850CC; }
    .btn-success { background: #4CAF50; color: white; }
    .btn-success:hover { background: #388E3C; }
    .btn-clear { background: #9E9E9E; color: white; }
    .btn-clear:hover { background: #757575; }
    .btn-screenshot { background: #FF9800; color: white; }
    .btn-screenshot:hover { background: #F57C00; }
    #route-info { margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 5px; font-size: 13px; }
    .route-item { padding: 8px; margin: 5px 0; background: white; border-left: 4px solid #3366FF; border-radius: 3px; }
    .distance-info { color: #FF5722; font-weight: bold; }
    .loading { text-align: center; color: #666; padding: 10px; }
    .error-box {
      background: #FFEBEE; padding: 10px; border-radius: 5px; margin-top: 10px;
      font-size: 12px; color: #C62828; border-left: 4px solid #F44336;
    }
    .tabs { display: flex; margin-bottom: 15px; border-bottom: 2px solid #ddd; }
    .tab {
      padding: 10px 20px; cursor: pointer; border: none; background: none;
      font-size: 14px; color: #666; transition: all 0.3s;
    }
    .tab.active { color: #3366FF; border-bottom: 3px solid #3366FF; margin-bottom: -2px; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .excel-template {
      background: #E3F2FD; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 12px;
    }
    .excel-template code { background: white; padding: 2px 6px; border-radius: 3px; font-family: monospace; }

    /* marker åœ†ç‚¹æ ·å¼ï¼ˆç”¨DOMå åŠ ï¼Œä¿æŒä½ åŸå…ˆâ€œç¼–å·åœ†ç‚¹â€é£æ ¼ï¼‰ */
    .num-marker {
      width: 35px; height: 35px; border-radius: 50%;
      color: white; display: flex; align-items: center; justify-content: center;
      font-weight: bold; font-size: 16px;
      border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }

    /* è‡ªå®šä¹‰æ¨¡æ€å¯¹è¯æ¡†æ ·å¼ */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .modal-dialog {
      background: white;
      border-radius: 12px;
      padding: 30px 40px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      min-width: 320px;
      text-align: center;
    }

    .modal-title {
      font-size: 18px;
      font-weight: bold;
      color: #333;
      margin-bottom: 25px;
    }

    .modal-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
    }

    .modal-btn {
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 120px;
    }

    .modal-btn-detail {
      background: #F44336;
      color: white;
    }

    .modal-btn-detail:hover {
      background: #D32F2F;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
    }

    .modal-btn-simple {
      background: #4CAF50;
      color: white;
    }

    .modal-btn-simple:hover {
      background: #388E3C;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }
  </style>
</head>

<body>
  <!-- é®ç½©å±‚ï¼ˆæ‚¬æµ®åœ¨æ§åˆ¶é¢æ¿ä¸Šæ–¹ï¼‰ -->
  <div id="mask-overlay" style="
    position: absolute;
    top: 20px;
    left: 20px;
    width: 380px;
    background: rgba(255, 255, 255, 0.95);
    padding: 15px 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 1001;
    display: none;
    font-size: 18px;
    font-weight: bold;
    color: #333;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 200px;
    overflow-y: auto;
    border-radius: 10px;
    border: 2px solid #3366FF;
  "></div>

  <div id="control-panel">
    <h2>ğŸ“ ç½‘ç‚¹è·¯çº¿ä¼˜åŒ–ç³»ç»Ÿï¼ˆç™¾åº¦åœ°å›¾ï¼‰</h2>

    <div class="tabs">
      <button class="tab active" onclick="switchTab('excel')">ğŸ“Š Excelå¯¼å…¥</button>
      <button class="tab" onclick="switchTab('manual')">âœï¸ æ‰‹åŠ¨è¾“å…¥</button>
    </div>

    <div id="excel-tab" class="tab-content active">
      <div class="excel-template">
        <strong>ğŸ“‹ Excelæ ¼å¼è¦æ±‚ï¼š</strong><br>
        åˆ—åï¼š<code>ç»åº¦</code> <code>çº¬åº¦</code> <code>ç½‘ç‚¹åç§°</code> <code>å¤‡æ³¨(å¯é€‰)</code> <code>ç½‘ç»„(å¯é€‰)</code> <code>å·¥å·(å¯é€‰)</code> <code>å§“å(å¯é€‰)</code> <code>å¿åŒº(å¯é€‰)</code> <code>è°ƒæ•´(å¯é€‰)</code> <code>é®ç½©(å¯é€‰)</code><br>
        <small style="color: #666;">æ”¯æŒæ‰¹é‡å¯¼å…¥ï¼šé¦–å…ˆæŒ‰"è°ƒæ•´"å­—æ®µåˆ†ç»„ï¼ˆè°ƒæ•´å‰/è°ƒæ•´åï¼‰ï¼Œç„¶ååœ¨åŒå­—æ®µä¸‹æŒ‰å·¥å·ã€ç½‘ç»„åˆ†ç»„å¤„ç†ï¼›å¦‚æœ‰å¿åŒºå­—æ®µï¼Œç”¨äºç»˜åˆ¶è¡Œæ”¿åŒºåˆ’è¾¹ç•Œï¼›é®ç½©å­—æ®µå†…å®¹ä¼šåœ¨æˆªå›¾æ—¶æ˜¾ç¤ºåœ¨æ§åˆ¶é¢æ¿ä¸Šæ–¹ï¼ˆæ‚¬æµ®æ˜¾ç¤ºï¼Œå­—ä½“æ”¾å¤§åŠ ç²—ï¼‰</small>
      </div>

      <div class="input-group">
        <label>é€‰æ‹©Excelæ–‡ä»¶</label>
        <input type="file" id="excelFile" accept=".xlsx,.xls" onchange="handleExcelUpload()">
      </div>
      
      <div class="input-group" id="batchProcessSection" style="display: none;">
        <button class="btn btn-success" onclick="startBatchProcess()" style="width: 100%;">
          ğŸ”„ æ‰¹é‡å¤„ç†ï¼ˆæŒ‰ç½‘ç»„ï¼‰
        </button>
      </div>
    </div>

    <div id="manual-tab" class="tab-content">
      <div class="input-group">
        <label>ç½‘ç‚¹æ•°æ®ï¼ˆæ ¼å¼ï¼šç»åº¦,çº¬åº¦,åç§°,å¤‡æ³¨å¯é€‰,ç½‘ç»„å¯é€‰,å·¥å·å¯é€‰,å§“åå¯é€‰,å¿åŒºå¯é€‰,è°ƒæ•´å¯é€‰,é®ç½©å¯é€‰ï¼‰</label>
        <textarea id="locationInput" rows="8"
          placeholder="116.397428,39.90923,åŒ—äº¬è¥ä¸šéƒ¨,å¤‡æ³¨A
116.404,39.915,æœé˜³æ”¯è¡Œ
116.326,39.989,æµ·æ·€æ”¯è¡Œ,é‡ç‚¹æ‹œè®¿">116.397428,39.90923,åŒ—äº¬è¥ä¸šéƒ¨,èµ·ç‚¹
116.404,39.915,æœé˜³æ”¯è¡Œ
116.326,39.989,æµ·æ·€æ”¯è¡Œ,é‡ç‚¹æ‹œè®¿
116.368,39.867,ä¸°å°æ”¯è¡Œ
116.481,39.990,é¡ºä¹‰æ”¯è¡Œ
        </textarea>
      </div>
    </div>

    <div class="input-group">
      <label>èµ·å§‹ç½‘ç‚¹ï¼ˆå¯é€‰ï¼šå¡«â€œç½‘ç‚¹åç§°â€åŒ¹é…ï¼‰</label>
      <input type="text" id="startPoint" placeholder="ç•™ç©ºåˆ™é»˜è®¤ä½¿ç”¨ç¬¬1è¡Œä½œä¸ºèµ·ç‚¹ï¼ˆä¼˜åŒ–æ—¶ä¹Ÿå¯è‡ªåŠ¨ï¼‰">
    </div>

    <div>
      <button class="btn btn-primary" onclick="optimizeRoute()">ğŸ”„ ä¼˜åŒ–è·¯çº¿</button>
      <button class="btn btn-success" onclick="calculateRoute()">ğŸ“ æŒ‰åºè®¡ç®—</button>
      <button class="btn btn-clear" onclick="clearMap()">ğŸ—‘ï¸ æ¸…é™¤</button>
    </div>

    <!-- æ‰‹åŠ¨æˆªå›¾æŒ‰é’® -->
    <div style="margin-top: 10px;">
      <button class="btn btn-screenshot" onclick="manualCaptureScreenshot()" style="width: 100%;">
        ğŸ“¸ æ‰‹åŠ¨æˆªå›¾
      </button>
    </div>

    <!-- çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸï¼ˆå›ºå®šä½ç½®ï¼Œæ˜¾ç¤ºè®¡ç®—è·¯çº¿ã€æˆªå›¾ç­‰çŠ¶æ€ï¼‰ -->
    <div id="status-info" style="margin-top: 10px; min-height: 40px; padding: 8px; background: #f5f5f5; border-radius: 5px; font-size: 12px; color: #666; text-align: center;">
      <div id="status-text">å°±ç»ª</div>
    </div>

    <!-- âœ… æœ€è¿œçº¿å¼€å…³ -->
    <div style="margin-top:10px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleFarthest" checked onchange="toggleFarthestLine()">
        æ˜¾ç¤ºæœ€è¿œä¸¤ç‚¹ç›´çº¿ï¼ˆç»¿è‰²ï¼‰
      </label>
    </div>

    <!-- âœ… è·ç¦»æ ‡ç­¾å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleDistanceLabels" onchange="toggleDistanceLabels()">
        æ˜¾ç¤ºè·¯çº¿è·ç¦»æ ‡ç­¾ï¼ˆé»„è‰²ï¼‰
      </label>
    </div>

    <!-- âœ… è·¯çº¿ç®€ç‰ˆå¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleRouteSimple" checked onchange="toggleRouteSimple()">
        è·¯çº¿ç®€ç‰ˆ
      </label>
    </div>

    <!-- âœ… è¡Œæ”¿åŒºå›¾å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleDistrictMap" checked onchange="toggleDistrictMap()">
        è¡Œæ”¿åŒºå›¾
      </label>
    </div>

    <!-- âœ… ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleDistrictMapOnly" onchange="toggleDistrictMapOnly()">
        ä»…æˆªå–è¡Œæ”¿åŒºå›¾ï¼ˆè·³è¿‡ç½‘ç»„æˆªå›¾ï¼‰
      </label>
    </div>

    <div id="route-info"></div>
  </div>

  <div id="container"></div>

  <!-- é…ç½®æ–‡ä»¶ï¼šä¼˜å…ˆåŠ è½½config-custom.jsï¼Œå¦‚æœæ²¡æœ‰åˆ™åŠ è½½static/config.js -->
  <script>
    // æå‰å®šä¹‰ showError å‡½æ•°ï¼Œä¾›åŠ è½½è„šæœ¬ä½¿ç”¨
    function showError(message) {
      const routeInfo = document.getElementById('route-info');
      if (routeInfo) {
        routeInfo.innerHTML = '<div class="error-box">âŒ ' + message + '</div>';
      } else {
        alert('é”™è¯¯ï¼š' + message);
      }
    }

    (function () {
      // ä¼˜å…ˆå°è¯•åŠ è½½config-custom.jsï¼ˆæ‰“åŒ…åä½äºexeåŒç›®å½•ï¼‰
      // å¦‚æœå¤±è´¥ï¼Œåˆ™åŠ è½½static/config.js
      let configLoaded = false;
      
      // å°è¯•åŠ è½½config-custom.js
      const customConfigScript = document.createElement("script");
      customConfigScript.src = "/config-custom.js";
      customConfigScript.onload = function() {
        console.log("[é…ç½®] æˆåŠŸåŠ è½½ config-custom.js");
        configLoaded = true;
        loadBaiduMap();
      };
      customConfigScript.onerror = function() {
        console.log("[é…ç½®] config-custom.js ä¸å­˜åœ¨ï¼Œå°è¯•åŠ è½½ static/config.js");
        // å¦‚æœconfig-custom.jsä¸å­˜åœ¨ï¼ŒåŠ è½½static/config.js
        const defaultConfigScript = document.createElement("script");
        defaultConfigScript.src = "/static/config.js";
        defaultConfigScript.onload = function() {
          console.log("[é…ç½®] æˆåŠŸåŠ è½½ static/config.js");
          configLoaded = true;
          loadBaiduMap();
        };
        defaultConfigScript.onerror = function() {
          showError("é…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ config-custom.js æˆ– static/config.js æ˜¯å¦å­˜åœ¨");
        };
        document.head.appendChild(defaultConfigScript);
      };
      document.head.appendChild(customConfigScript);
      
      function loadBaiduMap() {
        function waitForConfig(callback, maxAttempts = 50) {
          if (window.BMAP_CONFIG) {
            callback();
            return;
          }
          if (maxAttempts <= 0) {
            showError("é…ç½®æ–‡ä»¶åŠ è½½è¶…æ—¶ï¼è¯·æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨");
            return;
          }
          setTimeout(() => waitForConfig(callback, maxAttempts - 1), 100);
        }

        waitForConfig(function() {
          const ak = window.BMAP_CONFIG.jsAk;
          if (!ak || ak.includes("æ›¿æ¢")) {
            showError("âš ï¸ è¯·åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½®æœ‰æ•ˆçš„ jsAk");
            console.warn("âš ï¸ è¯·åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½® jsAk");
            return;
          }

          const script = document.createElement("script");
          script.src = "https://api.map.baidu.com/api?v=3.0&ak=" + encodeURIComponent(ak) + "&callback=baiduMapInit";
          script.onerror = function () {
            showError("ç™¾åº¦åœ°å›¾JSåŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š<br>1. jsAkæ˜¯å¦æ­£ç¡®<br>2. åŸŸåç™½åå•/Refereré™åˆ¶<br>3. ç½‘ç»œæ˜¯å¦æ­£å¸¸<br>4. æµè§ˆå™¨æ§åˆ¶å°æ˜¯å¦æœ‰è¯¦ç»†é”™è¯¯ä¿¡æ¯");
          };
          document.head.appendChild(script);
        });
      }
    })();
  </script>

  <script>
    let map;
    let markers = [];
    let overlays = []; // label / polyline / è‡ªå®šä¹‰overlay
    let currentLocations = []; // Excelå¯¼å…¥ç»“æœ

    // âœ… æœ€è¿œçº¿ï¼šå¯å¼€å…³å¯¹è±¡å¼•ç”¨
    let farthestLineOverlay = null;
    let farthestLabelOverlay = null;
    let farthestVisible = true;

    // âœ… è·ç¦»æ ‡ç­¾ï¼šå¯å¼€å…³å¯¹è±¡å¼•ç”¨
    let distanceLabels = [];  // ä¿å­˜æ‰€æœ‰è·ç¦»æ ‡ç­¾å¼•ç”¨
    let distanceLabelsVisible = false;  // è·ç¦»æ ‡ç­¾æ˜¾ç¤ºçŠ¶æ€ï¼ˆé»˜è®¤å…³é—­ï¼‰

    function toggleFarthestLine() {
      farthestVisible = document.getElementById('toggleFarthest')?.checked ?? true;
      console.log('åˆ‡æ¢æœ€è¿œè¿çº¿æ˜¾ç¤ºçŠ¶æ€:', farthestVisible);

      if (farthestLineOverlay) {
        if (typeof farthestLineOverlay.setVisible === 'function') {
          farthestLineOverlay.setVisible(farthestVisible);
        } else {
          // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
          try {
            if (!farthestVisible) {
              map.removeOverlay(farthestLineOverlay);
            } else {
              map.addOverlay(farthestLineOverlay);
            }
          } catch(e) {
            console.warn('åˆ‡æ¢æœ€è¿œè¿çº¿æ˜¾ç¤ºå¤±è´¥:', e);
          }
        }
      }

      if (farthestLabelOverlay) {
        if (typeof farthestLabelOverlay.setVisible === 'function') {
          farthestLabelOverlay.setVisible(farthestVisible);
        } else {
          // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
          try {
            if (!farthestVisible) {
              map.removeOverlay(farthestLabelOverlay);
            } else {
              map.addOverlay(farthestLabelOverlay);
            }
          } catch(e) {
            console.warn('åˆ‡æ¢æœ€è¿œæ ‡ç­¾æ˜¾ç¤ºå¤±è´¥:', e);
          }
        }
      }
    }

    function toggleDistanceLabels() {
      distanceLabelsVisible = document.getElementById('toggleDistanceLabels')?.checked ?? false;
      console.log('åˆ‡æ¢è·ç¦»æ ‡ç­¾æ˜¾ç¤ºçŠ¶æ€:', distanceLabelsVisible);

      distanceLabels.forEach((label) => {
        if (label) {
          if (typeof label.setVisible === 'function') {
            label.setVisible(distanceLabelsVisible);
          } else {
            // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
            try {
              if (!distanceLabelsVisible) {
                map.removeOverlay(label);
              } else {
                map.addOverlay(label);
              }
            } catch(e) {
              console.warn('åˆ‡æ¢è·ç¦»æ ‡ç­¾æ˜¾ç¤ºå¤±è´¥:', e);
            }
          }
        }
      });
    }

    // è·¯çº¿ç®€ç‰ˆå¼€å…³çŠ¶æ€ï¼ˆé»˜è®¤å¼€å¯ï¼‰
    let routeSimpleMode = true;
    // ä¿å­˜å½“å‰è·¯çº¿ç»“æœ
    let currentRouteResult = null;
    // è¡Œæ”¿åŒºå›¾å¼€å…³çŠ¶æ€
    let districtMapEnabled = true;
    // ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¼€å…³çŠ¶æ€
    let districtMapOnlyEnabled = false;

    // ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¼€å…³
    function toggleDistrictMapOnly() {
      districtMapOnlyEnabled = document.getElementById('toggleDistrictMapOnly')?.checked ?? false;
      console.log('åˆ‡æ¢ä»…æˆªå–è¡Œæ”¿åŒºå›¾çŠ¶æ€:', districtMapOnlyEnabled);
    }

    function toggleRouteSimple() {
      routeSimpleMode = document.getElementById('toggleRouteSimple')?.checked ?? true;
      console.log('åˆ‡æ¢è·¯çº¿ç®€ç‰ˆçŠ¶æ€:', routeSimpleMode);
      
      // å¦‚æœå½“å‰æœ‰è·¯çº¿æ•°æ®ï¼Œé‡æ–°æ¸²æŸ“è·¯çº¿è¯¦æƒ…
      if (currentRouteResult) {
        updateRouteInfo(currentRouteResult, routeSimpleMode);
      }
    }

    // è¡Œæ”¿åŒºå›¾å¼€å…³
    function toggleDistrictMap() {
      districtMapEnabled = document.getElementById('toggleDistrictMap')?.checked ?? true;
      console.log('åˆ‡æ¢è¡Œæ”¿åŒºå›¾çŠ¶æ€:', districtMapEnabled);
    }

    // æ›´æ–°è·¯çº¿è¯¦æƒ…æ˜¾ç¤º
    function updateRouteInfo(result, simpleMode = false) {
      const { route, legs, total_distance, total_duration, farthest_points } = result;
      const routeInfoDiv = document.getElementById('route-info');
      
      if (!routeInfoDiv) return;
      
      let html = '';
      
      if (simpleMode) {
        // ç®€ç‰ˆï¼šåªæ˜¾ç¤ºåºå·å’Œç½‘ç‚¹åç§°ï¼Œç«–å‘æ’åºï¼Œé‡‡ç”¨åœ°å›¾æ ‡è®°åç§°æ ·å¼
        html = '<h3 style="color:#3366FF;margin-bottom:15px;">ğŸ—ºï¸ è·¯çº¿è¯¦æƒ…ï¼ˆç®€ç‰ˆï¼‰</h3>';
        html += '<div style="line-height:1.8;margin-bottom:15px;">';
        route.forEach((loc, i) => {
          // ä½¿ç”¨åœ°å›¾æ ‡è®°åç§°çš„æ ·å¼ï¼šç™½è‰²èƒŒæ™¯ã€è“è‰²è¾¹æ¡†ã€é˜´å½±ç­‰
          html += `<div style="padding:3px 0;display:flex;align-items:center;">
            <span style="
              background: white;
              border: 2px solid #2196F3;
              padding: 5px 10px;
              border-radius: 5px;
              font-size: 13px;
              font-weight: bold;
              box-shadow: 0 2px 6px rgba(0,0,0,0.3);
              white-space: nowrap;
              color: #333;
            ">${i + 1}. ${loc.name}</span>
          </div>`;
        });
        html += '</div>';
        
        // æ€»ç½‘ç‚¹æ•°ä¿¡æ¯
        html += `
          <div style="margin-top:15px;padding:12px;background:#E3F2FD;border-radius:6px;font-weight:bold;border-left:4px solid #2196F3;">
            <div style="color:#1976D2;font-size:15px;">ğŸ“Š æ€»ç½‘ç‚¹æ•°ï¼š<span style="color:#FF5722;font-size:16px;">${route.length} ä¸ª</span></div>
            <div style="color:#FF5722;font-size:15px;margin-top:8px;">
              æ€»è·ç¦»ï¼š${formatMeters(total_distance)} Â· æ€»ç”¨æ—¶ï¼š${formatSeconds(total_duration)}
            </div>
          </div>`;

        // æœ€è¿œç½‘ç‚¹ä¿¡æ¯
        if (farthest_points && farthest_points.point1 && farthest_points.point2) {
          html += `
            <div style="margin-top:15px;padding:12px;background:#E8F5E9;border-radius:6px;border-left:4px solid #4CAF50;">
              <div style="color:#2E7D32;font-weight:bold;margin-bottom:8px;font-size:14px;">ğŸ“ æœ€è¿œç½‘ç‚¹ï¼ˆç›´çº¿è·ç¦»ï¼‰</div>
              <div style="color:#388E3C;font-size:15px;margin-bottom:5px;">
                <strong>${farthest_points.point1.name}</strong> â†” <strong>${farthest_points.point2.name}</strong>
              </div>
              <div style="color:#4CAF50;font-size:16px;font-weight:bold;margin-top:5px;">
                ${farthest_points.straight_distance_text}
              </div>
            </div>`;
        }
      } else {
        // å®Œæ•´ç‰ˆï¼šæ˜¾ç¤ºè¯¦ç»†è·¯çº¿ä¿¡æ¯
        html = '<h3 style="color:#3366FF;margin-bottom:10px;">ğŸ—ºï¸ è·¯çº¿è¯¦æƒ…</h3>';
        (legs || []).forEach((lg, i) => {
          html += `
            <div class="route-item">
              <strong>${i + 1}. ${lg.from}</strong> â†’ <strong>${i + 2}. ${lg.to}</strong>
              <div class="distance-info">${lg.distance_text} Â· ${lg.duration_text}</div>
            </div>`;
        });
        html += `
          <div style="margin-top:15px;padding:10px;background:#E3F2FD;border-radius:5px;font-weight:bold;">
            <div style="color:#1976D2;">æ€»ç½‘ç‚¹æ•°ï¼š${route.length} ä¸ª</div>
            <div style="color:#FF5722;font-size:16px;margin-top:5px;">
              æ€»è·ç¦»ï¼š${formatMeters(total_distance)} Â· æ€»ç”¨æ—¶ï¼š${formatSeconds(total_duration)}
            </div>
          </div>`;

        if (farthest_points && farthest_points.point1 && farthest_points.point2) {
          html += `
            <div style="margin-top:15px;padding:10px;background:#E8F5E9;border-radius:5px;border-left:4px solid #00FF00;">
              <div style="color:#2E7D32;font-weight:bold;margin-bottom:5px;">ğŸ“ æœ€è¿œç½‘ç‚¹ï¼ˆç›´çº¿è·ç¦»ï¼‰</div>
              <div style="color:#388E3C;font-size:13px;">
                <strong>${farthest_points.point1.name}</strong> â†” <strong>${farthest_points.point2.name}</strong>
              </div>
              <div style="color:#00FF00;font-size:14px;font-weight:bold;margin-top:5px;">
                ${farthest_points.straight_distance_text}
              </div>
            </div>`;
        }
      }
      
      routeInfoDiv.innerHTML = html;
    }

    function drawFarthestLine(farthest_points) {
      // æ¸…ç†æ—§çš„
      if (farthestLineOverlay) {
        try {
          map.removeOverlay(farthestLineOverlay);
          const idx = overlays.indexOf(farthestLineOverlay);
          if (idx > -1) overlays.splice(idx, 1);
        } catch(e) {
          console.warn('ç§»é™¤æ—§çš„æœ€è¿œè¿çº¿å¤±è´¥:', e);
        }
      }
      if (farthestLabelOverlay) {
        try {
          map.removeOverlay(farthestLabelOverlay);
          const idx = overlays.indexOf(farthestLabelOverlay);
          if (idx > -1) overlays.splice(idx, 1);
        } catch(e) {
          console.warn('ç§»é™¤æ—§çš„æœ€è¿œæ ‡ç­¾å¤±è´¥:', e);
        }
      }
      farthestLineOverlay = null;
      farthestLabelOverlay = null;

      if (!map) {
        console.warn('åœ°å›¾æœªåˆå§‹åŒ–ï¼Œæ— æ³•ç»˜åˆ¶æœ€è¿œè¿çº¿');
        return;
      }

      if (!farthest_points || !farthest_points.point1 || !farthest_points.point2) {
        console.log('æœªæ‰¾åˆ°æœ€è¿œç½‘ç‚¹æ•°æ®:', farthest_points);
        return;
      }

      console.log('å¼€å§‹ç»˜åˆ¶æœ€è¿œç½‘ç‚¹è¿çº¿:', farthest_points);

      const p1 = new BMap.Point(farthest_points.point1.lng, farthest_points.point1.lat);
      const p2 = new BMap.Point(farthest_points.point2.lng, farthest_points.point2.lat);

      console.log('ç‚¹1åæ ‡:', p1.lng, p1.lat, 'åç§°:', farthest_points.point1.name);
      console.log('ç‚¹2åæ ‡:', p2.lng, p2.lat, 'åç§°:', farthest_points.point2.name);

      // ä½¿ç”¨äº®ç»¿è‰² #00E676 (Material Design äº®ç»¿è‰²) æˆ– #00FF00 (çº¯ç»¿è‰²)
      const line = new BMap.Polyline([p1, p2], {
        strokeWeight: 4,  // çº¿æ¡å®½åº¦ï¼ˆç¨å¾®ç»†ä¸€ç‚¹ï¼‰
        strokeOpacity: 1.0,  // å®Œå…¨ä¸é€æ˜
        strokeColor: "#00FF00"  // äº®ç»¿è‰²
      });

      // å°è¯•è®¾ç½®è™šçº¿æ ·å¼ï¼ˆå¦‚æœAPIæ”¯æŒï¼‰
      if (typeof line.setStrokeStyle === 'function') {
        try {
          line.setStrokeStyle("dashed");
          console.log('å·²è®¾ç½®è™šçº¿æ ·å¼');
        } catch(e) {
          console.log('è™šçº¿æ ·å¼è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨å®çº¿');
        }
      }

      map.addOverlay(line);
      overlays.push(line);
      farthestLineOverlay = line;
      console.log('âœ“ æœ€è¿œè¿çº¿å·²æ·»åŠ åˆ°åœ°å›¾');

      // è®¡ç®—ä¸­ç‚¹ç”¨äºæ ‡æ³¨è·ç¦»
      const midPoint = new BMap.Point((p1.lng + p2.lng) / 2, (p1.lat + p2.lat) / 2);

      // æ ‡æ³¨ç›´çº¿è·ç¦»ï¼ˆä½¿ç”¨äº®ç»¿è‰²èƒŒæ™¯ï¼‰
      const label = new BMap.Label(farthest_points.straight_distance_text || "æœ€è¿œç›´çº¿è·ç¦»", {
        offset: new BMap.Size(0, -15)
      });

      label.setStyle({
        background: 'rgba(0, 255, 0, 0.9)',  // äº®ç»¿è‰²èƒŒæ™¯
        color: 'white',
        border: '2px solid white',
        padding: '6px 12px',
        borderRadius: '5px',
        fontSize: '13px',
        fontWeight: 'bold',
        boxShadow: '0 2px 6px rgba(0,0,0,0.4)',
        whiteSpace: 'nowrap',
        zIndex: 1001
      });

      label.setPosition(midPoint);
      map.addOverlay(label);
      overlays.push(label);
      farthestLabelOverlay = label;
      console.log('âœ“ è·ç¦»æ ‡ç­¾å·²æ·»åŠ :', farthest_points.straight_distance_text);

      // æŒ‰å¼€å…³çŠ¶æ€æ˜¾ç¤º/éšè—
      toggleFarthestLine();
    }

    // å®šä¹‰å…¨å±€å›è°ƒå‡½æ•°ï¼Œä¾›ç™¾åº¦åœ°å›¾APIè°ƒç”¨
    window.baiduMapInit = function() {
      if (typeof BMap !== 'undefined') {
        initMap();
      } else {
        showError("ç™¾åº¦åœ°å›¾APIå¯¹è±¡æœªåˆå§‹åŒ–ï¼Œè¯·æ£€æŸ¥AKé…ç½®å’Œç½‘ç»œè¿æ¥");
      }
    };

    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      if (tabName === 'excel') {
        document.querySelector('.tab:first-child').classList.add('active');
        document.getElementById('excel-tab').classList.add('active');
      } else {
        document.querySelector('.tab:last-child').classList.add('active');
        document.getElementById('manual-tab').classList.add('active');
      }
    }

    function initMap() {
      if (typeof BMap === 'undefined') {
        showError("ç™¾åº¦åœ°å›¾APIæœªåŠ è½½æˆåŠŸ");
        return;
      }
      map = new BMap.Map("container");
      const center = new BMap.Point(116.397428, 39.90923);
      map.centerAndZoom(center, 11);
      map.enableScrollWheelZoom(true);
      
      // ç¼©æ”¾/ç§»åŠ¨/æ‹–æ‹½åï¼Œé‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®ï¼ˆä½¿ç”¨é˜²æŠ–æœºåˆ¶ï¼Œç¡®ä¿DOMæ›´æ–°å®Œæˆï¼‰
      let labelUpdateTimer = null;
      const debouncedUpdateLabels = () => {
        if (labelUpdateTimer) clearTimeout(labelUpdateTimer);
        labelUpdateTimer = setTimeout(() => {
          updateLabelPositions();
          labelUpdateTimer = null;
        }, 200); // å¢åŠ å»¶è¿Ÿï¼Œç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
      };
      
      map.addEventListener('zoomend', debouncedUpdateLabels);
      map.addEventListener('moveend', debouncedUpdateLabels);
      map.addEventListener('dragend', debouncedUpdateLabels);
    }

    // ä¿å­˜å½“å‰è·¯çº¿æ•°æ®ï¼ˆç”¨äºç¼©æ”¾ã€å¹³ç§»åé‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®ï¼‰
    let currentRouteData = null;
    let currentLabelOffsets = [];
    let manualAdjustedLabels = new Set(); // è®°å½•å·²æ‰‹åŠ¨è°ƒæ•´è¿‡çš„æ ‡ç­¾ç´¢å¼•

    // è·å–æ ‡ç­¾çš„å®é™…å°ºå¯¸ï¼ˆé€šè¿‡DOMå…ƒç´ ï¼‰
    function getLabelActualSize(label) {
      try {
        if (label && typeof label.getContent === 'function') {
          const labelElement = label.getContent();
          if (labelElement) {
            // å°è¯•å¤šç§æ–¹æ³•è·å–å°ºå¯¸
            if (labelElement.getBoundingClientRect) {
              const rect = labelElement.getBoundingClientRect();
              if (rect.width > 0 && rect.height > 0) {
                return { width: Math.max(rect.width, 80), height: Math.max(rect.height, 30) };
              }
            }
            // å¦‚æœgetBoundingClientRectä¸å¯ç”¨ï¼Œå°è¯•offsetWidth/offsetHeight
            if (labelElement.offsetWidth && labelElement.offsetHeight) {
              return { 
                width: Math.max(labelElement.offsetWidth, 80), 
                height: Math.max(labelElement.offsetHeight, 30) 
              };
            }
            // å°è¯•é€šè¿‡è®¡ç®—æ ·å¼è·å–
            if (window.getComputedStyle) {
              const style = window.getComputedStyle(labelElement);
              const width = parseFloat(style.width) || 120;
              const height = parseFloat(style.height) || 34;
              if (width > 0 && height > 0) {
                return { width: Math.max(width, 80), height: Math.max(height, 30) };
              }
            }
          }
        }
      } catch(e) {
        // å¿½ç•¥é”™è¯¯ï¼Œä½¿ç”¨é»˜è®¤å€¼
      }
      // é»˜è®¤å°ºå¯¸ï¼ˆåŒ…æ‹¬paddingå’Œborderï¼ŒåŸºäºæ ·å¼ï¼špadding: 5px 10px, border: 2pxï¼‰
      return { width: 120, height: 34 };
    }

    // æ·»åŠ æ ‡ç­¾åˆ°æ ‡è®°ç‚¹ï¼ˆåœ¨è§†å›¾è°ƒæ•´å®Œæˆåè°ƒç”¨ï¼‰
    async function addLabelsToMarkers(route, markers) {
      if (!route || !markers || route.length !== markers.length) return;
      
      currentLabelOffsets = [];
      
      // æŒ‰é¡ºåºæ·»åŠ æ ‡ç­¾ï¼Œç¡®ä¿ä¸äº’ç›¸é®æŒ¡ä¸”ä¸é®æŒ¡åœ†åœˆ
      for (let idx = 0; idx < route.length; idx++) {
        const marker = markers[idx];
        const loc = route[idx];
        if (!marker || !loc) continue;
        
        const labelText = loc.remark ? `${idx + 1}. ${loc.remark}` : `${idx + 1}. ${loc.name}`;
        
        // è®¡ç®—æ ‡ç­¾ä½ç½®ï¼ˆä½¿ç”¨å®é™…å°ºå¯¸ï¼Œç¡®ä¿ä¸é®æŒ¡ä»»ä½•åœ†åœˆï¼‰
        const { offsetX, offsetY } = calculateLabelOffset(idx, route.length, route, currentLabelOffsets, null);
        currentLabelOffsets.push({ offsetX, offsetY });
        
        const label = new BMap.Label(labelText, { offset: new BMap.Size(offsetX, offsetY) });
        label.setStyle({
          background: 'white',
          border: '2px solid #2196F3',
          padding: '5px 10px',
          borderRadius: '5px',
          fontSize: '13px',
          fontWeight: 'bold',
          boxShadow: '0 2px 6px rgba(0,0,0,0.3)',
          whiteSpace: 'nowrap',
          zIndex: 10000  // ç½‘ç‚¹åç§°æ ‡ç­¾æœ€é«˜ä¼˜å…ˆçº§ï¼Œç¡®ä¿åœ¨æ‰€æœ‰è·ç¦»æ ‡ç­¾ä¸Šæ–¹
        });
        marker.setLabel(label);
        
        // ç­‰å¾…æ ‡ç­¾æ¸²æŸ“ï¼Œç„¶åä½¿ç”¨å®é™…å°ºå¯¸é‡æ–°è®¡ç®—ä½ç½®
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // ä½¿ç”¨å®é™…å°ºå¯¸é‡æ–°è®¡ç®—ä½ç½®
        const actualSize = getLabelActualSize(label);
        if (actualSize) {
          const newOffsets = currentLabelOffsets.slice(0, idx);
          const { offsetX: newOffsetX, offsetY: newOffsetY } = calculateLabelOffset(idx, route.length, route, newOffsets, label);
          label.setOffset(new BMap.Size(newOffsetX, newOffsetY));
          currentLabelOffsets[idx] = { offsetX: newOffsetX, offsetY: newOffsetY };
        }
        
        // è®¾ç½®z-index
        try {
          const labelElement = label.getContent();
          if (labelElement && labelElement.style) {
            labelElement.style.zIndex = '10000';
            labelElement.style.position = 'relative';
          }
        } catch(e) {
          // å¿½ç•¥é”™è¯¯
        }
        
        // å¯ç”¨æ ‡ç­¾æ‹–æ‹½åŠŸèƒ½ï¼ˆä»…æ‰‹åŠ¨è¾“å…¥æ—¶ï¼‰
        enableLabelDragging(marker, label, idx, route);
      }
      
      console.log('[æ ‡ç­¾æ·»åŠ ] æ‰€æœ‰æ ‡ç­¾å·²æ·»åŠ å®Œæˆ');
      
      // ç­‰å¾…æ‰€æœ‰æ ‡ç­¾å®Œå…¨æ¸²æŸ“
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // è°ƒæ•´è§†å›¾ï¼Œç¡®ä¿æ‰€æœ‰åœ†åœˆå’Œæ ‡ç­¾ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰éƒ½åœ¨å¯è§åŒºåŸŸå†…
      await adjustViewportForAllElements(route, markers);
    }

    // è°ƒæ•´è§†å›¾ï¼Œç¡®ä¿æ‰€æœ‰åœ†åœˆå’Œæ ‡ç­¾ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰éƒ½åœ¨å¯è§åŒºåŸŸå†…
    async function adjustViewportForAllElements(route, markers) {
      if (!route || route.length === 0 || !map) return;
      
      const mapContainer = map.getContainer();
      if (!mapContainer) return;
      const mapRect = mapContainer.getBoundingClientRect();
      
      // æ§åˆ¶é¢æ¿å‚æ•°
      const panelLeft = 20;
      const panelTop = 20;
      const panelWidth = 380;
      const panelRight = panelLeft + panelWidth;
      const viewPadding = 5; // è§†å›¾è¾¹è·
      const effectiveLeft = panelRight + viewPadding; // æœ‰æ•ˆå¯è§†åŒºåŸŸçš„å·¦è¾¹ç•Œ
      const effectiveRight = mapRect.width - viewPadding; // æœ‰æ•ˆå¯è§†åŒºåŸŸçš„å³è¾¹ç•Œ
      const effectiveTop = viewPadding; // æœ‰æ•ˆå¯è§†åŒºåŸŸçš„ä¸Šè¾¹ç•Œ
      const effectiveBottom = mapRect.height - viewPadding; // æœ‰æ•ˆå¯è§†åŒºåŸŸçš„ä¸‹è¾¹ç•Œ
      
      const markerRadius = 20.5; // åœ†åœˆåŠå¾„ï¼ˆåƒç´ ï¼‰
      const borderWidth = 2; // æ ‡ç­¾è¾¹æ¡†å®½åº¦
      const labelPadding = 5; // æ ‡ç­¾é—´è·
      
      // è®¡ç®—æ‰€æœ‰åœ†åœˆå’Œæ ‡ç­¾çš„è¾¹ç•Œæ¡†
      let allBounds = {
        minX: Infinity,
        maxX: -Infinity,
        minY: Infinity,
        maxY: -Infinity
      };
      
      route.forEach((loc, idx) => {
        const pt = new BMap.Point(loc.lng, loc.lat);
        const pixel = map.pointToPixel(pt);
        
        // åœ†åœˆè¾¹ç•Œï¼ˆè€ƒè™‘åŠå¾„å’Œè¾¹è·ï¼‰
        const circleBounds = {
          minX: pixel.x - markerRadius - labelPadding,
          maxX: pixel.x + markerRadius + labelPadding,
          minY: pixel.y - markerRadius - labelPadding,
          maxY: pixel.y + markerRadius + labelPadding
        };
        
        // æ ‡ç­¾è¾¹ç•Œï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (markers && markers[idx]) {
          const label = markers[idx].getLabel();
          if (label && currentLabelOffsets && currentLabelOffsets[idx]) {
            const offset = currentLabelOffsets[idx];
            const labelX = pixel.x + offset.offsetX;
            const labelY = pixel.y + offset.offsetY;
            const labelSize = getLabelActualSize(label);
            const labelTotalWidth = labelSize.width + borderWidth * 2;
            const labelTotalHeight = labelSize.height + borderWidth * 2;
            
            const labelBounds = {
              minX: labelX - labelTotalWidth / 2 - labelPadding,
              maxX: labelX + labelTotalWidth / 2 + labelPadding,
              minY: labelY - labelTotalHeight / 2 - labelPadding,
              maxY: labelY + labelTotalHeight / 2 + labelPadding
            };
            
            // åˆå¹¶åœ†åœˆå’Œæ ‡ç­¾è¾¹ç•Œ
            allBounds.minX = Math.min(allBounds.minX, circleBounds.minX, labelBounds.minX);
            allBounds.maxX = Math.max(allBounds.maxX, circleBounds.maxX, labelBounds.maxX);
            allBounds.minY = Math.min(allBounds.minY, circleBounds.minY, labelBounds.minY);
            allBounds.maxY = Math.max(allBounds.maxY, circleBounds.maxY, labelBounds.maxY);
          } else {
            // åªæœ‰åœ†åœˆ
            allBounds.minX = Math.min(allBounds.minX, circleBounds.minX);
            allBounds.maxX = Math.max(allBounds.maxX, circleBounds.maxX);
            allBounds.minY = Math.min(allBounds.minY, circleBounds.minY);
            allBounds.maxY = Math.max(allBounds.maxY, circleBounds.maxY);
          }
        } else {
          // åªæœ‰åœ†åœˆ
          allBounds.minX = Math.min(allBounds.minX, circleBounds.minX);
          allBounds.maxX = Math.max(allBounds.maxX, circleBounds.maxX);
          allBounds.minY = Math.min(allBounds.minY, circleBounds.minY);
          allBounds.maxY = Math.max(allBounds.maxY, circleBounds.maxY);
        }
      });
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒæ•´è§†å›¾
      const needsAdjustment = 
        allBounds.minX < effectiveLeft || 
        allBounds.maxX > effectiveRight ||
        allBounds.minY < effectiveTop ||
        allBounds.maxY > effectiveBottom;
      
      if (!needsAdjustment) {
        console.log('[è§†å›¾è°ƒæ•´] æ‰€æœ‰å…ƒç´ éƒ½åœ¨æœ‰æ•ˆåŒºåŸŸå†…');
        return;
      }
      
      // è®¡ç®—éœ€è¦ç¼©æ”¾çš„æ¯”ä¾‹
      const currentWidth = allBounds.maxX - allBounds.minX;
      const currentHeight = allBounds.maxY - allBounds.minY;
      const availableWidth = effectiveRight - effectiveLeft;
      const availableHeight = effectiveBottom - effectiveTop;
      
      const scaleX = currentWidth / availableWidth;
      const scaleY = currentHeight / availableHeight;
      const scale = Math.max(scaleX, scaleY);
      
      if (scale > 1) {
        // éœ€è¦ç¼©å°
        const currentZoom = map.getZoom();
        if (currentZoom > 10) {
          const zoomReduction = Math.min(Math.ceil(Math.log2(scale)), currentZoom - 10);
          const newZoom = Math.max(10, currentZoom - zoomReduction);
          if (newZoom < currentZoom) {
            map.setZoom(newZoom);
            await new Promise(resolve => setTimeout(resolve, 500));
            console.log(`[è§†å›¾è°ƒæ•´] ç¼©å°åœ°å›¾ï¼Œç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${newZoom}`);
            
            // ç¼©æ”¾åé‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®
            updateLabelPositions();
            await new Promise(resolve => setTimeout(resolve, 300));
          }
        }
      }
      
      // æ£€æŸ¥ä¸­å¿ƒç‚¹åç§»ï¼Œå¦‚æœéœ€è¦ï¼Œè°ƒæ•´ä¸­å¿ƒç‚¹
      const centerX = (allBounds.minX + allBounds.maxX) / 2;
      const centerY = (allBounds.minY + allBounds.maxY) / 2;
      const targetCenterX = (effectiveLeft + effectiveRight) / 2;
      const targetCenterY = (effectiveTop + effectiveBottom) / 2;
      
      const offsetX = centerX - targetCenterX;
      const offsetY = centerY - targetCenterY;
      
      if (Math.abs(offsetX) > 10 || Math.abs(offsetY) > 10) {
        try {
          const centerPoint = map.getCenter();
          const centerPixel = map.pointToPixel(centerPoint);
          const newCenterPixel = new BMap.Pixel(centerPixel.x - offsetX, centerPixel.y - offsetY);
          const newCenter = map.pixelToPoint(newCenterPixel);
          map.setCenter(newCenter);
          await new Promise(resolve => setTimeout(resolve, 500));
          console.log(`[è§†å›¾è°ƒæ•´] è°ƒæ•´åœ°å›¾ä¸­å¿ƒ`);
          
          // è°ƒæ•´ä¸­å¿ƒåé‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®
          updateLabelPositions();
          await new Promise(resolve => setTimeout(resolve, 300));
        } catch(e) {
          console.warn('[è§†å›¾è°ƒæ•´] è°ƒæ•´ä¸­å¿ƒç‚¹å¤±è´¥:', e);
        }
      }
    }

    // è®¡ç®—æ ‡ç­¾åç§»ï¼Œè‡ªåŠ¨é¿è®©åœ†åœˆä¸å…¶ä»–æ ‡ç­¾ï¼ˆä½¿ç”¨å®é™…å°ºå¯¸ï¼‰
    function calculateLabelOffset(idx, total, route, existingOffsets = [], label = null) {
      // é»˜è®¤åç§»ï¼Œé˜²å¾¡æ€§è¿”å›
      const fallback = { offsetX: (idx % 2 === 0) ? 36 : -36, offsetY: (idx % 4 < 2) ? -22 : 16 };
      if (!map || !route || idx >= route.length) return fallback;

      const pt = new BMap.Point(route[idx].lng, route[idx].lat);
      const pixel = map.pointToPixel(pt);

      // è·å–å®é™…æ ‡ç­¾å°ºå¯¸
      let labelWidth = 120;
      let labelHeight = 34;
      if (label) {
        const actualSize = getLabelActualSize(label);
        labelWidth = actualSize.width;
        labelHeight = actualSize.height;
      }

      // å°ºå¯¸åŠå®‰å…¨è·ç¦»
      const markerRadius = 20.5;         // åœ†åœˆåŠå¾„ï¼ˆå«è¾¹æ¡†ï¼‰
      const borderWidth = 2;             // æ ‡ç­¾è¾¹æ¡†å®½åº¦
      const padding = 5;                 // æ ‡ç­¾ä¹‹é—´çš„æœ€å°é—´è·ï¼ˆè¾¹æ¡†å¤–çš„é—´è·ï¼‰
      const labelPadding = 5;            // æ ‡ç­¾å†…è¾¹è·
      // æ ‡ç­¾å®é™…å ç”¨ç©ºé—´ï¼ˆåŒ…æ‹¬å†…å®¹ã€å†…è¾¹è·ã€è¾¹æ¡†ï¼‰
      const labelTotalWidth = labelWidth + borderWidth * 2;
      const labelTotalHeight = labelHeight + borderWidth * 2;
      const minCenterDist = markerRadius + Math.max(labelTotalWidth, labelTotalHeight) / 2 + padding; // æ ‡ç­¾ä¸­å¿ƒåˆ°åœ†åœˆä¸­å¿ƒçš„æœ€å°å®‰å…¨è·ç¦»

      // è·ç¦»ä¸ç¼©æ”¾ï¼ˆæ ¹æ®ç¼©æ”¾çº§åˆ«è°ƒæ•´ï¼Œç¡®ä¿æ ‡ç­¾å§‹ç»ˆæ¸…æ™°å¯è§ï¼‰
      const zoom = map.getZoom();
      const zoomFactor = Math.pow(1.2, zoom - 12); // ç¼©æ”¾å› å­ï¼Œç¼©æ”¾è¶Šå¤§ï¼Œæ ‡ç­¾è·ç¦»è¶Šè¿œ
      const baseDist = Math.max(minCenterDist, 50 * zoomFactor);  // åŸºç¡€è·ç¦»ï¼ˆè‡³å°‘æ»¡è¶³æœ€å°è·ç¦»ï¼‰
      const minDist = minCenterDist;
      const maxDist = Math.max(baseDist * 1.5, 150 * zoomFactor); // æœ€å¤§è·ç¦»ï¼ˆå…è®¸æ›´è¿œçš„ä½ç½®ï¼‰

      // ç”Ÿæˆå€™é€‰åç§»ä½ç½®ï¼ˆå¢åŠ æ›´å¤šå€™é€‰ä½ç½®ï¼ŒåŒ…æ‹¬æ›´è¿œçš„è·ç¦»ï¼‰
      const candidates = [];
      const baseAngle = (idx / Math.max(1, total)) * 2 * Math.PI;

      // å¤šåœˆå±‚å€™é€‰ä½ç½®ï¼šä»è¿‘åˆ°è¿œ
      const distances = [baseDist, baseDist * 1.2, baseDist * 1.5, baseDist * 1.8, baseDist * 2.2];
      distances.forEach(dist => {
        if (dist < minDist || dist > maxDist) return;
        // åŸºç¡€è§’åº¦ä½ç½®
        candidates.push({ offsetX: Math.cos(baseAngle) * dist, offsetY: Math.sin(baseAngle) * dist });
        // å·¦å³å¾®è°ƒ
        for (let angleOffset of [-Math.PI/8, -Math.PI/12, Math.PI/12, Math.PI/8]) {
          candidates.push({ 
            offsetX: Math.cos(baseAngle + angleOffset) * dist, 
            offsetY: Math.sin(baseAngle + angleOffset) * dist 
          });
        }
      });

      // å››ä¸ªè±¡é™ä½ç½®ï¼ˆå¤šä¸ªè·ç¦»å±‚çº§ï¼‰
      for (let dist of [baseDist, baseDist * 1.3, baseDist * 1.7]) {
        if (dist < minDist || dist > maxDist) continue;
        candidates.push({ offsetX: dist, offsetY: -dist });
        candidates.push({ offsetX: -dist, offsetY: -dist });
        candidates.push({ offsetX: -dist, offsetY: dist });
        candidates.push({ offsetX: dist, offsetY: dist });
      }

      // æ°´å¹³å’Œå‚ç›´æ–¹å‘ï¼ˆå¤šä¸ªè·ç¦»ï¼‰
      for (let dist of [baseDist, baseDist * 1.4, baseDist * 1.8]) {
        if (dist < minDist || dist > maxDist) continue;
        candidates.push({ offsetX: dist, offsetY: 0 });
        candidates.push({ offsetX: -dist, offsetY: 0 });
        candidates.push({ offsetX: 0, offsetY: -dist });
        candidates.push({ offsetX: 0, offsetY: dist });
      }

      // å¯¹è§’çº¿ä½ç½®
      const diagDist = baseDist * 1.2;
      if (diagDist >= minDist && diagDist <= maxDist) {
        candidates.push({ offsetX: diagDist * 0.7, offsetY: -diagDist * 0.7 });
        candidates.push({ offsetX: -diagDist * 0.7, offsetY: -diagDist * 0.7 });
        candidates.push({ offsetX: -diagDist * 0.7, offsetY: diagDist * 0.7 });
        candidates.push({ offsetX: diagDist * 0.7, offsetY: diagDist * 0.7 });
      }

      let best = fallback;
      let bestScore = Number.POSITIVE_INFINITY;

      // è¯„ä¼°æ¯ä¸ªå€™é€‰ä½ç½®
      for (const cand of candidates) {
        const dist = Math.hypot(cand.offsetX, cand.offsetY);
        if (dist < minDist || dist > maxDist) continue;

        const labelX = pixel.x + cand.offsetX;
        const labelY = pixel.y + cand.offsetY;
        // æ ‡ç­¾è¾¹æ¡†æ¡†ï¼ˆåŒ…æ‹¬è¾¹æ¡†å®½åº¦å’Œé—´è·ï¼‰
        const box = {
          left: labelX - labelTotalWidth / 2 - padding,
          right: labelX + labelTotalWidth / 2 + padding,
          top: labelY - labelTotalHeight / 2 - padding,
          bottom: labelY + labelTotalHeight / 2 + padding
        };

        // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦é®æŒ¡ä»»ä½•åœ†åœˆï¼ˆåŒ…æ‹¬è‡ªèº«å’Œæ‰€æœ‰å…¶ä»–åœ†åœˆï¼‰
        let overlapsAnyCircle = false;
        for (let i = 0; i < route.length; i++) {
          const circlePt = new BMap.Point(route[i].lng, route[i].lat);
          const circlePx = map.pointToPixel(circlePt);
          
          // è®¡ç®—æ ‡ç­¾è¾¹ç•Œæ¡†æœ€è¿‘ç‚¹åˆ°åœ†åœˆä¸­å¿ƒçš„è·ç¦»
          const nearestX = Math.max(box.left, Math.min(circlePx.x, box.right));
          const nearestY = Math.max(box.top, Math.min(circlePx.y, box.bottom));
          const distToCircle = Math.hypot(nearestX - circlePx.x, nearestY - circlePx.y);
          
          // å¦‚æœè·ç¦»å°äºåœ†åœˆåŠå¾„+è¾¹æ¡†+å®‰å…¨è¾¹è·ï¼Œè¯´æ˜æ ‡ç­¾è¾¹æ¡†é®æŒ¡äº†åœ†åœˆ
          if (distToCircle < markerRadius + borderWidth + padding) {
            overlapsAnyCircle = true;
            break;
          }
        }
        
        if (overlapsAnyCircle) continue; // å¦‚æœé®æŒ¡ä»»ä½•åœ†åœˆï¼Œç›´æ¥è·³è¿‡

        // æ£€æŸ¥æ ‡ç­¾è¾¹æ¡†æ˜¯å¦å®Œå…¨åœ¨å¯è§è§†å›¾èŒƒå›´å†…ï¼ˆè€ƒè™‘æ§åˆ¶é¢æ¿ï¼‰
        const mapContainer = map.getContainer();
        if (mapContainer) {
          const mapRect = mapContainer.getBoundingClientRect();
          const panelLeft = 20;
          const panelTop = 20;
          const panelWidth = 380;
          const panelRight = panelLeft + panelWidth;
          const viewPadding = 5; // è§†å›¾è¾¹è·
          const effectiveLeft = panelRight + viewPadding; // æ§åˆ¶é¢æ¿å³ä¾§+è¾¹è·
          const effectiveRight = mapRect.width - viewPadding; // åœ°å›¾å³è¾¹ç•Œ-è¾¹è·
          const effectiveTop = viewPadding; // åœ°å›¾ä¸Šè¾¹ç•Œ+è¾¹è·
          const effectiveBottom = mapRect.height - viewPadding; // åœ°å›¾ä¸‹è¾¹ç•Œ-è¾¹è·
          
          // æ£€æŸ¥æ ‡ç­¾è¾¹æ¡†æ˜¯å¦å®Œå…¨åœ¨æœ‰æ•ˆå¯è§†åŒºåŸŸå†…ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
          if (box.left < effectiveLeft || box.right > effectiveRight || 
              box.top < effectiveTop || box.bottom > effectiveBottom) {
            continue; // è¶…å‡ºæœ‰æ•ˆè¾¹ç•Œçš„ä½ç½®ä¸è€ƒè™‘
          }
        }

        // ä¸ä¹‹å‰æ ‡ç­¾ã€åœ†åœˆçš„é‡å è¯„åˆ†
        let overlapScore = 0;
        let hasOverlap = false;

        for (let i = 0; i < Math.min(existingOffsets.length, route.length); i++) {
          const otherPt = new BMap.Point(route[i].lng, route[i].lat);
          const otherPx = map.pointToPixel(otherPt);
          const off = existingOffsets[i];
          const otherX = otherPx.x + off.offsetX;
          const otherY = otherPx.y + off.offsetY;
          
          // è·å–å…¶ä»–æ ‡ç­¾çš„å®é™…å°ºå¯¸ï¼ˆä¼°ç®—ï¼Œå› ä¸ºå¯èƒ½è¿˜æ²¡æœ‰æ¸²æŸ“ï¼‰
          let otherLabelWidth = labelWidth;
          let otherLabelHeight = labelHeight;
          // ä½¿ç”¨ä¼°ç®—çš„æ€»å°ºå¯¸ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
          const otherLabelTotalWidth = otherLabelWidth + borderWidth * 2;
          const otherLabelTotalHeight = otherLabelHeight + borderWidth * 2;
          
          // å…¶ä»–æ ‡ç­¾çš„è¾¹æ¡†æ¡†ï¼ˆåŒ…æ‹¬è¾¹æ¡†å®½åº¦å’Œé—´è·ï¼‰
          const otherBox = {
            left: otherX - otherLabelTotalWidth / 2 - padding,
            right: otherX + otherLabelTotalWidth / 2 + padding,
            top: otherY - otherLabelTotalHeight / 2 - padding,
            bottom: otherY + otherLabelTotalHeight / 2 + padding
          };
          
          // æ ‡ç­¾è¾¹æ¡†ä¸æ ‡ç­¾è¾¹æ¡†é‡å æ£€æµ‹ï¼ˆå®Œå…¨ç¦æ­¢é‡å ï¼‰
          const overlapX = Math.max(0, Math.min(box.right, otherBox.right) - Math.max(box.left, otherBox.left));
          const overlapY = Math.max(0, Math.min(box.bottom, otherBox.bottom) - Math.max(box.top, otherBox.top));
          if (overlapX > 0 && overlapY > 0) {
            hasOverlap = true;
            overlapScore += overlapX * overlapY * 10000; // å¤§å¹…æé«˜é‡å æƒ©ç½š
            break; // æœ‰é‡å ç›´æ¥è·³è¿‡
          }

          // æ ‡ç­¾è¾¹æ¡†åˆ°å…¶ä»–åœ†åœˆçš„è·ç¦»ï¼Œé¿å…è´´å¾—è¿‡è¿‘
          const labelToCircle = Math.hypot(labelX - otherPx.x, labelY - otherPx.y);
          if (labelToCircle < markerRadius + borderWidth + padding) {
            overlapScore += 100000;
            hasOverlap = true;
            break;
          }
        }

        // å¦‚æœæœ‰é‡å ï¼Œç›´æ¥è·³è¿‡
        if (hasOverlap) continue;

        // è®¡ç®—è¯„åˆ†ï¼ˆè·ç¦»é€‚ä¸­ã€æ— é‡å çš„ä½ç½®å¾—åˆ†æ›´é«˜ï¼‰
        const distanceScore = Math.abs(dist - baseDist * 1.2); // åå¥½è·ç¦»é€‚ä¸­çš„ä½ç½®
        const totalScore = overlapScore + distanceScore * 0.1;

        if (totalScore < bestScore) {
          bestScore = totalScore;
          best = { offsetX: Math.round(cand.offsetX), offsetY: Math.round(cand.offsetY) };
          if (overlapScore === 0 && distanceScore < 5) break; // å·²æ‰¾åˆ°ç†æƒ³ä½ç½®ï¼Œæå‰ç»“æŸ
        }
      }

      // å¦‚æœæ‰€æœ‰å€™é€‰ä½ç½®éƒ½æœ‰é‡å ï¼Œè¿”å›fallbackï¼ˆè¿™ç§æƒ…å†µåº”è¯¥å¾ˆå°‘ï¼‰
      if (bestScore >= 10000) {
        console.warn(`æ ‡ç­¾ ${idx} æ— æ³•æ‰¾åˆ°å®Œå…¨æ— é‡å çš„ä½ç½®ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®`);
      }

      return best || fallback;
    }

    // ç¼©æ”¾/å¹³ç§»åæ›´æ–°æ‰€æœ‰æ ‡ç­¾ä½ç½®ï¼ˆä½¿ç”¨æ”¹è¿›çš„ç®—æ³•ç¡®ä¿æ‰€æœ‰æ ‡ç­¾éƒ½ä¸é‡å ï¼‰
    function updateLabelPositions() {
      if (!currentRouteData || !currentRouteData.route || !markers.length) return;
      const route = currentRouteData.route;
      const newOffsets = [];

      // æŒ‰é¡ºåºè®¡ç®—æ¯ä¸ªæ ‡ç­¾çš„ä½ç½®ï¼Œç¡®ä¿ä½¿ç”¨å®é™…å°ºå¯¸
      markers.forEach((marker, idx) => {
        if (idx >= route.length) return;
        const label = marker.getLabel();
        if (!label) return;
        
        // å¦‚æœæ ‡ç­¾å·²ç»è¢«æ‰‹åŠ¨è°ƒæ•´è¿‡ï¼Œå°è¯•ä¿æŒç›¸å¯¹ä½ç½®ï¼ˆä½†ä¹Ÿè¦é¿å…é‡å ï¼‰
        if (manualAdjustedLabels.has(idx) && currentLabelOffsets[idx]) {
          // å¯¹äºæ‰‹åŠ¨è°ƒæ•´è¿‡çš„æ ‡ç­¾ï¼Œå…ˆå°è¯•ä½¿ç”¨åŸä½ç½®
          const savedOffset = currentLabelOffsets[idx];
          // æ£€æŸ¥è¿™ä¸ªä½ç½®æ˜¯å¦ä¼šå¯¼è‡´é‡å 
          const actualSize = getLabelActualSize(label);
          const hasOverlap = checkPositionOverlap(idx, savedOffset.offsetX, savedOffset.offsetY, actualSize, route, newOffsets);
          
          if (!hasOverlap) {
            // å¦‚æœæ²¡æœ‰é‡å ï¼Œä¿æŒåŸä½ç½®
            label.setOffset(new BMap.Size(savedOffset.offsetX, savedOffset.offsetY));
            newOffsets.push({ offsetX: savedOffset.offsetX, offsetY: savedOffset.offsetY });
          } else {
            // å¦‚æœæœ‰é‡å ï¼Œé‡æ–°è®¡ç®—ä½ç½®ï¼ˆä½†å°½é‡æ¥è¿‘åŸä½ç½®ï¼‰
            const { offsetX, offsetY } = calculateLabelOffset(idx, route.length, route, newOffsets, label);
            label.setOffset(new BMap.Size(offsetX, offsetY));
            newOffsets.push({ offsetX, offsetY });
          }
        } else {
          // è‡ªåŠ¨è®¡ç®—æ–°çš„åç§»é‡ï¼ˆä¼ å…¥labelå¯¹è±¡ä»¥è·å–å®é™…å°ºå¯¸ï¼‰
          const { offsetX, offsetY } = calculateLabelOffset(idx, route.length, route, newOffsets, label);
          label.setOffset(new BMap.Size(offsetX, offsetY));
          newOffsets.push({ offsetX, offsetY });
        }

        // ç¡®ä¿å±‚çº§
        try {
          const style = label.getStyle();
          if (style) {
            style.zIndex = 10000;
            label.setStyle(style);
          }
          const el = label.getContent();
          if (el && el.style) el.style.zIndex = '10000';
        } catch(e) {}
      });

      currentLabelOffsets = newOffsets;
    }

    // æ£€æŸ¥æŒ‡å®šä½ç½®æ˜¯å¦ä¼šå¯¼è‡´æ ‡ç­¾é‡å 
    function checkPositionOverlap(idx, offsetX, offsetY, labelSize, route, existingOffsets) {
      const pt = new BMap.Point(route[idx].lng, route[idx].lat);
      const pixel = map.pointToPixel(pt);
      const padding = 5;
      const markerRadius = 20.5;

      const labelX = pixel.x + offsetX;
      const labelY = pixel.y + offsetY;
      const box = {
        left: labelX - labelSize.width / 2 - padding,
        right: labelX + labelSize.width / 2 + padding,
        top: labelY - labelSize.height / 2 - padding,
        bottom: labelY + labelSize.height / 2 + padding
      };

      // æ£€æŸ¥æ˜¯å¦ä¸æ ‡è®°ç‚¹é‡å 
      const nearestX = Math.max(box.left, Math.min(pixel.x, box.right));
      const nearestY = Math.max(box.top, Math.min(pixel.y, box.bottom));
      const distToMarker = Math.hypot(nearestX - pixel.x, nearestY - pixel.y);
      if (distToMarker < markerRadius + padding) {
        return true;
      }

      // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–æ ‡ç­¾é‡å 
      for (let i = 0; i < Math.min(existingOffsets.length, idx); i++) {
        const otherPt = new BMap.Point(route[i].lng, route[i].lat);
        const otherPx = map.pointToPixel(otherPt);
        const off = existingOffsets[i];
        const otherX = otherPx.x + off.offsetX;
        const otherY = otherPx.y + off.offsetY;
        
        // ä½¿ç”¨ä¼°ç®—å°ºå¯¸ï¼ˆå› ä¸ºæˆ‘ä»¬æ²¡æœ‰å…¶ä»–æ ‡ç­¾çš„å®é™…å°ºå¯¸ï¼‰
        const otherSize = { width: 120, height: 34 };
        const otherBox = {
          left: otherX - otherSize.width / 2 - padding,
          right: otherX + otherSize.width / 2 + padding,
          top: otherY - otherSize.height / 2 - padding,
          bottom: otherY + otherSize.height / 2 + padding
        };

        const overlapX = Math.max(0, Math.min(box.right, otherBox.right) - Math.max(box.left, otherBox.left));
        const overlapY = Math.max(0, Math.min(box.bottom, otherBox.bottom) - Math.max(box.top, otherBox.top));
        if (overlapX > 0 && overlapY > 0) {
          return true;
        }

        // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–æ ‡è®°ç‚¹å¤ªè¿‘
        const labelToCircle = Math.hypot(labelX - otherPx.x, labelY - otherPx.y);
        if (labelToCircle < markerRadius + padding) {
          return true;
        }
      }

      return false;
    }

    // å¯ç”¨æ ‡ç­¾æ‹–æ‹½åŠŸèƒ½ï¼ˆä»…æ‰‹åŠ¨è¾“å…¥æ—¶ï¼‰
    function enableLabelDragging(marker, label, idx, route, forceRebind = false) {
      if (!marker || !label || !route || idx >= route.length) return;
      
      // åˆ¤æ–­æ˜¯å¦æ˜¯æ‰‹åŠ¨è¾“å…¥ï¼ˆcurrentLocationsä¸ºç©ºï¼‰
      const isManualInput = currentLocations.length === 0;
      if (!isManualInput) {
        console.log(`æ ‡ç­¾ ${idx} è·³è¿‡æ‹–æ‹½ï¼ˆExcelå¯¼å…¥æ¨¡å¼ï¼‰`);
        return; // åªæœ‰æ‰‹åŠ¨è¾“å…¥æ—¶æ‰å¯ç”¨æ‹–æ‹½
      }
      
      // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿æ ‡ç­¾å…ƒç´ å·²å®Œå…¨æ¸²æŸ“ï¼ˆå¢åŠ å»¶è¿Ÿæ—¶é—´ï¼‰
      setTimeout(() => {
        try {
          // å°è¯•å¤šç§æ–¹æ³•è·å–æ ‡ç­¾å…ƒç´ 
          let labelElement = null;
          
          // æ–¹æ³•1: ä½¿ç”¨ getContent() æ–¹æ³•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if (typeof label.getContent === 'function') {
            labelElement = label.getContent();
          }
          
          // æ–¹æ³•2: å¦‚æœ getContent() å¤±è´¥ï¼Œå°è¯•é€šè¿‡ DOM æŸ¥æ‰¾
          if (!labelElement && map) {
            try {
              const labelPane = map.getPanes().labelPane;
              if (labelPane) {
                // è·å–æ ‡ç­¾çš„æ–‡æœ¬å†…å®¹
                const labelText = route[idx].remark ? `${idx + 1}. ${route[idx].remark}` : `${idx + 1}. ${route[idx].name}`;
                // æŸ¥æ‰¾åŒ…å«è¯¥æ–‡æœ¬çš„å…ƒç´ ï¼ˆæ›´å®½æ¾çš„åŒ¹é…ï¼‰
                const allLabels = labelPane.querySelectorAll('div');
                for (let el of allLabels) {
                  const text = el.textContent || el.innerText || '';
                  if (text.includes(labelText.split('.')[0]) || text.trim() === labelText.trim()) {
                    // éªŒè¯å…ƒç´ æ˜¯å¦æœ‰ style å±æ€§
                    if (el.style && typeof el.style === 'object') {
                      labelElement = el;
                      break;
                    }
                  }
                }
              }
            } catch(e) {
              console.warn(`æ–¹æ³•2æŸ¥æ‰¾æ ‡ç­¾å¤±è´¥:`, e);
            }
          }
          
          // æ–¹æ³•3: å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•é€šè¿‡æ ‡è®°ç‚¹ä½ç½®æŸ¥æ‰¾æœ€è¿‘çš„æ ‡ç­¾
          if (!labelElement && map && marker) {
            try {
              const pt = new BMap.Point(route[idx].lng, route[idx].lat);
              const pixel = map.pointToPixel(pt);
              const labelPane = map.getPanes().labelPane;
              if (labelPane) {
                const allLabels = labelPane.querySelectorAll('div');
                let minDist = Infinity;
                let closestEl = null;
                for (let el of allLabels) {
                  // éªŒè¯å…ƒç´ æ˜¯å¦æœ‰ style å±æ€§
                  if (!el.style || typeof el.style !== 'object') continue;
                  
                  const rect = el.getBoundingClientRect();
                  const mapRect = map.getContainer().getBoundingClientRect();
                  const elX = rect.left - mapRect.left + rect.width / 2;
                  const elY = rect.top - mapRect.top + rect.height / 2;
                  const dist = Math.hypot(elX - pixel.x, elY - pixel.y);
                  if (dist < minDist && dist < 150) { // è·ç¦»æ ‡è®°ç‚¹150åƒç´ å†…
                    minDist = dist;
                    closestEl = el;
                  }
                }
                if (closestEl) {
                  labelElement = closestEl;
                }
              }
            } catch(e) {
              console.warn(`æ–¹æ³•3æŸ¥æ‰¾æ ‡ç­¾å¤±è´¥:`, e);
            }
          }
          
          // æ–¹æ³•4: å°è¯•é€šè¿‡ç™¾åº¦åœ°å›¾å†…éƒ¨ç»“æ„æŸ¥æ‰¾
          if (!labelElement && label && typeof label === 'object') {
            try {
              // å°è¯•è®¿é—®ç™¾åº¦åœ°å›¾ Label çš„å†…éƒ¨å±æ€§
              if (label._div && label._div.style) {
                labelElement = label._div;
              } else if (label._content && label._content.style) {
                labelElement = label._content;
              } else if (label._dom && label._dom.style) {
                labelElement = label._dom;
              }
            } catch(e) {
              // å¿½ç•¥è®¿é—®ç§æœ‰å±æ€§çš„é”™è¯¯
            }
          }
          
          // éªŒè¯å…ƒç´ æ˜¯å¦æœ‰æ•ˆï¼ˆå¿…é¡»æ˜¯ DOM å…ƒç´ ä¸”æœ‰ style å±æ€§ï¼‰
          if (!labelElement || !labelElement.style || typeof labelElement.style !== 'object') {
            console.warn(`æ ‡ç­¾ ${idx} çš„å…ƒç´ æ— æ•ˆï¼Œé‡è¯•...`, {
              hasElement: !!labelElement,
              hasStyle: !!(labelElement && labelElement.style),
              elementType: typeof labelElement
            });
            // å¦‚æœå…ƒç´ è¿˜æœªå‡†å¤‡å¥½ï¼Œå†ç­‰ä¸€ä¼šå„¿é‡è¯•ï¼ˆæœ€å¤šé‡è¯•3æ¬¡ï¼‰
            const retryKey = `_label_${idx}_retry`;
            const retryCount = window[retryKey] || 0;
            if (retryCount < 3) {
              window[retryKey] = retryCount + 1;
              setTimeout(() => {
                enableLabelDragging(marker, label, idx, route, forceRebind);
              }, 500);
            } else {
              console.error(`æ ‡ç­¾ ${idx} æ‹–æ‹½åŠŸèƒ½å¯ç”¨å¤±è´¥ï¼šæ— æ³•æ‰¾åˆ°æœ‰æ•ˆçš„ DOM å…ƒç´ ï¼ˆå·²é‡è¯•${retryCount}æ¬¡ï¼‰`);
              delete window[retryKey];
            }
            return;
          }
          
          // æ¸…é™¤é‡è¯•è®¡æ•°
          const retryKey = `_label_${idx}_retry`;
          if (window[retryKey]) {
            delete window[retryKey];
          }
          
          // è°ƒè¯•ä¿¡æ¯
          console.log(`æ ‡ç­¾ ${idx} å…ƒç´ ç±»å‹:`, labelElement.tagName, labelElement.className);
          
          // æ£€æŸ¥æ˜¯å¦å·²ç»ç»‘å®šè¿‡äº‹ä»¶ï¼ˆé¿å…é‡å¤ç»‘å®šï¼Œé™¤éå¼ºåˆ¶é‡æ–°ç»‘å®šï¼‰
          if (!forceRebind && labelElement.dataset && labelElement.dataset.dragEnabled === 'true') {
            console.log(`æ ‡ç­¾ ${idx} æ‹–æ‹½åŠŸèƒ½å·²å­˜åœ¨ï¼Œè·³è¿‡`);
            return;
          }
          
          if (labelElement.dataset) {
            labelElement.dataset.dragEnabled = 'true';
          }
          
          // è®¾ç½®å¯æ‹–æ‹½æ ·å¼ï¼ˆç¡®ä¿å…ƒç´ æœ‰ style å±æ€§ï¼‰
          if (labelElement.style) {
            labelElement.style.cursor = 'move';
            labelElement.title = 'å¯æ‹–æ‹½è°ƒæ•´ä½ç½®ï¼ˆæ‰‹åŠ¨è¾“å…¥æ¨¡å¼ï¼‰';
            labelElement.style.userSelect = 'none'; // ç¦æ­¢æ–‡æœ¬é€‰æ‹©
            labelElement.style.webkitUserSelect = 'none';
            labelElement.style.mozUserSelect = 'none';
            labelElement.style.msUserSelect = 'none';
          }
          
          // å­˜å‚¨æ‹–æ‹½çŠ¶æ€ï¼ˆä½¿ç”¨é—­åŒ…é¿å…å…¨å±€æ±¡æŸ“ï¼‰
          const dragState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            startOffset: null
          };
          
          // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆå®šä¹‰ä¸ºå‘½åå‡½æ•°ï¼Œæ–¹ä¾¿ç§»é™¤ï¼‰
          const handleMouseMove = (e) => {
            if (!dragState.isDragging || !dragState.startOffset) return;
            e.preventDefault();
            e.stopPropagation();
            
            const dx = e.clientX - dragState.startX;
            const dy = e.clientY - dragState.startY;
            
            // è®¡ç®—æ–°çš„åç§»é‡ï¼ˆç›´æ¥ä½¿ç”¨åƒç´ åç§»ï¼‰
            const newOffsetX = dragState.startOffset.offsetX + dx;
            const newOffsetY = dragState.startOffset.offsetY + dy;
            
            // æ›´æ–°æ ‡ç­¾åç§»
            label.setOffset(new BMap.Size(newOffsetX, newOffsetY));
            
            // æ›´æ–°ä¿å­˜çš„åç§»é‡
            if (currentLabelOffsets[idx]) {
              currentLabelOffsets[idx].offsetX = newOffsetX;
              currentLabelOffsets[idx].offsetY = newOffsetY;
            } else {
              currentLabelOffsets[idx] = { offsetX: newOffsetX, offsetY: newOffsetY };
            }
            // æ ‡è®°ä¸ºå·²æ‰‹åŠ¨è°ƒæ•´
            manualAdjustedLabels.add(idx);
          };
          
          // é¼ æ ‡é‡Šæ”¾äº‹ä»¶ï¼ˆå®šä¹‰ä¸ºå‘½åå‡½æ•°ï¼Œæ–¹ä¾¿ç§»é™¤ï¼‰
          const handleMouseUp = (e) => {
            if (!dragState.isDragging) return;
            e.preventDefault();
            e.stopPropagation();
            
            dragState.isDragging = false;
            
            // å°è¯•è·å–å½“å‰å…ƒç´ å¹¶æ¢å¤æ ·å¼
            let currentElement = labelElement;
            if (typeof label.getContent === 'function') {
              currentElement = label.getContent() || labelElement;
            }
            if (currentElement) {
              currentElement.style.opacity = '1';
              currentElement.style.transition = '';
            }
            
            // ç§»é™¤å…¨å±€äº‹ä»¶ç›‘å¬å™¨
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
            // æ¢å¤åœ°å›¾çš„æ‹–æ‹½åŠŸèƒ½
            if (map) {
              map.enableDragging();
            }
            
            if (currentLabelOffsets[idx]) {
              console.log(`æ ‡ç­¾ ${idx} æ‹–æ‹½ç»“æŸï¼Œæ–°ä½ç½®: (${currentLabelOffsets[idx].offsetX}, ${currentLabelOffsets[idx].offsetY})`);
            }
          };
          
          // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
          const handleMouseDown = (e) => {
            // åªå“åº”å·¦é”®
            if (e.button !== 0 && e.which !== 1) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            console.log(`å¼€å§‹æ‹–æ‹½æ ‡ç­¾ ${idx}`);
            
            // é‡æ–°è·å–å…ƒç´ ï¼ˆå¯èƒ½å·²æ›´æ–°ï¼‰
            let currentElement = labelElement;
            if (typeof label.getContent === 'function') {
              currentElement = label.getContent() || labelElement;
            }
            if (!currentElement) {
              console.warn(`æ ‡ç­¾ ${idx} å…ƒç´ åœ¨æ‹–æ‹½æ—¶ä¸¢å¤±`);
              return;
            }
            
            // è·å–å½“å‰æ ‡ç­¾çš„åç§»é‡
            const currentOffset = label.getOffset();
            dragState.startOffset = { offsetX: currentOffset.width, offsetY: currentOffset.height };
            
            dragState.startX = e.clientX;
            dragState.startY = e.clientY;
            dragState.isDragging = true;
            
            currentElement.style.opacity = '0.8';
            currentElement.style.transition = 'none'; // ç¦ç”¨è¿‡æ¸¡åŠ¨ç”»ï¼Œæ‹–æ‹½æ›´æµç•…
            
            // æ·»åŠ å…¨å±€äº‹ä»¶ç›‘å¬å™¨
            document.addEventListener('mousemove', handleMouseMove, { passive: false });
            document.addEventListener('mouseup', handleMouseUp, { passive: false });
            
            // ä¸´æ—¶ç¦ç”¨åœ°å›¾çš„æ‹–æ‹½åŠŸèƒ½ï¼Œé¿å…å†²çª
            if (map) {
              map.disableDragging();
            }
          };
          
          // ç»‘å®šé¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼ˆä½¿ç”¨æ•è·é˜¶æ®µï¼Œç¡®ä¿èƒ½æ•è·åˆ°äº‹ä»¶ï¼‰
          labelElement.addEventListener('mousedown', handleMouseDown, { passive: false, capture: true });
          
          // ä¹Ÿå°è¯•ç»‘å®šåˆ° labelElement çš„æ‰€æœ‰å­å…ƒç´ ï¼ˆæŸäº›æƒ…å†µä¸‹æ ‡ç­¾å†…å®¹å¯èƒ½åœ¨å­å…ƒç´ ä¸­ï¼‰
          if (labelElement.children && labelElement.children.length > 0) {
            Array.from(labelElement.children).forEach(child => {
              if (child && child.style && typeof child.style === 'object') {
                child.style.cursor = 'move';
                child.style.userSelect = 'none';
                child.addEventListener('mousedown', handleMouseDown, { passive: false, capture: true });
              }
            });
          }
          
          console.log(`æ ‡ç­¾ ${idx} æ‹–æ‹½åŠŸèƒ½å·²å¯ç”¨ï¼ˆæ‰‹åŠ¨è¾“å…¥æ¨¡å¼ï¼‰`);
          
        } catch(e) {
          console.error('å¯ç”¨æ ‡ç­¾æ‹–æ‹½å¤±è´¥:', e, e.stack);
        }
      }, 1000); // å»¶è¿Ÿ1000msï¼Œç¡®ä¿æ ‡ç­¾å®Œå…¨æ¸²æŸ“
    }

    // ç»Ÿä¸€çš„çŠ¶æ€æ›´æ–°å‡½æ•°ï¼Œç¡®ä¿çŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
    function updateStatus(message, type = 'info') {
      const statusInfo = document.getElementById('status-info');
      if (!statusInfo) return;
      
      // ç¡®ä¿çŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
      statusInfo.style.display = 'block';
      
      let statusText = document.getElementById('status-text');
      // å¦‚æœæ‰¾ä¸åˆ°status-textå…ƒç´ ï¼Œåˆ›å»ºå®ƒ
      if (!statusText) {
        statusInfo.innerHTML = '<div id="status-text">' + message + '</div>';
        statusText = document.getElementById('status-text');
      } else {
        statusText.textContent = message;
      }
      
      if (statusText) {
        // è®¾ç½®é»˜è®¤æ ·å¼
        statusInfo.style.background = '#f5f5f5'; // é»˜è®¤èƒŒæ™¯è‰²
        statusText.style.color = '#666'; // é»˜è®¤æ–‡å­—é¢œè‰²
        
        if (type === 'loading') {
          statusInfo.style.background = '#E3F2FD'; // è“è‰²èƒŒæ™¯ï¼ˆåŠ è½½ä¸­ï¼‰
          statusText.style.color = '#1976D2';
        } else if (type === 'success') {
          statusInfo.style.background = '#E8F5E9'; // ç»¿è‰²èƒŒæ™¯ï¼ˆæˆåŠŸï¼‰
          statusText.style.color = '#2E7D32';
        } else if (type === 'error') {
          statusInfo.style.background = '#FFEBEE'; // çº¢è‰²èƒŒæ™¯ï¼ˆé”™è¯¯ï¼‰
          statusText.style.color = '#C62828';
        } else if (type === 'ready') {
          statusInfo.style.background = '#f5f5f5'; // é»˜è®¤èƒŒæ™¯ï¼ˆå°±ç»ªï¼‰
          statusText.style.color = '#666';
        }
      }
    }

    function showLoading(message) {
      updateStatus(message, 'loading');
    }
    
    function clearStatusInfo() {
      // ä¸æ¸…é™¤çŠ¶æ€æ ï¼Œåªé‡ç½®ä¸º"å°±ç»ª"çŠ¶æ€
      updateStatus('å°±ç»ª', 'ready');
    }

    // æ˜¾ç¤ºæˆªå›¾æ¨¡å¼é€‰æ‹©å¯¹è¯æ¡†
    function showScreenshotModeDialog(callback) {
      // åˆ›å»ºé®ç½©å±‚
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
      
      // åˆ›å»ºå¯¹è¯æ¡†
      const dialog = document.createElement('div');
      dialog.className = 'modal-dialog';
      dialog.innerHTML = `
        <div class="modal-title">ğŸ“¸ é€‰æ‹©æˆªå›¾æ¨¡å¼</div>
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-detail" onclick="closeScreenshotDialog(false)">è¯¦ç»†ç‰ˆ</button>
          <button class="modal-btn modal-btn-simple" onclick="closeScreenshotDialog(true)">ç®€æ´ç‰ˆ</button>
        </div>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // ä¿å­˜å›è°ƒå‡½æ•°åˆ°å…¨å±€ï¼Œä¾›æŒ‰é’®è°ƒç”¨
      window._screenshotModeCallback = callback;
      
      // ç‚¹å‡»é®ç½©å±‚å…³é—­
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeScreenshotDialog(false); // é»˜è®¤é€‰æ‹©è¯¦ç»†ç‰ˆ
        }
      });
    }

    // å…³é—­æˆªå›¾æ¨¡å¼å¯¹è¯æ¡†
    function closeScreenshotDialog(useSimpleMode) {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) {
        overlay.remove();
      }
      
      // è°ƒç”¨å›è°ƒå‡½æ•°
      if (window._screenshotModeCallback) {
        window._screenshotModeCallback(useSimpleMode);
        window._screenshotModeCallback = null;
      }
    }
    
    // æ˜¾ç¤ºæ‰¹é‡å¤„ç†è¿›åº¦
    function showBatchProgress(totalGroups) {
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = `
          <div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
            <div id="batchStatus">å‡†å¤‡å¤„ç† ${totalGroups} ä¸ªç½‘ç»„...</div>
            <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
              <div id="batchProgressBar" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
            </div>
          </div>
        `;
      }
    }
    
    // æ›´æ–°æ‰¹é‡å¤„ç†çŠ¶æ€
    function updateBatchStatus(message, current, total) {
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        const batchStatus = document.getElementById('batchStatus');
        const batchProgressBar = document.getElementById('batchProgressBar');
        if (batchStatus) {
          batchStatus.textContent = message;
        }
        if (batchProgressBar) {
          const progress = (current / total * 100).toFixed(0);
          batchProgressBar.style.width = progress + '%';
        }
      }
    }

    function clearMap() {
      if (!map) return;
      markers.forEach(m => map.removeOverlay(m));
      overlays.forEach(o => map.removeOverlay(o));
      markers = [];
      overlays = [];
      currentLocations = [];
      document.getElementById('route-info').innerHTML = '';

      // âœ… æ¸…ç©ºæœ€è¿œçº¿å¼•ç”¨
      farthestLineOverlay = null;
      farthestLabelOverlay = null;
      
      // âœ… æ¸…ç©ºè·ç¦»æ ‡ç­¾å¼•ç”¨
      distanceLabels = [];
      
      // âœ… æ¸…ç©ºæ‰‹åŠ¨è°ƒæ•´æ ‡ç­¾è®°å½•
      manualAdjustedLabels.clear();
    }

    function parseLocationData() {
      const input = document.getElementById('locationInput').value.trim();
      if (!input) {
        showError('è¯·è¾“å…¥ç½‘ç‚¹æ•°æ®ï¼');
        return [];
      }
      const lines = input.split('\n');
      const locations = [];
      const errors = [];

      lines.forEach((line, idx) => {
        const t = line.trim();
        if (!t) return;
        const parts = t.split(',');
        if (parts.length < 3) {
          errors.push(`ç¬¬${idx + 1}è¡Œï¼šæ ¼å¼é”™è¯¯ï¼ˆè‡³å°‘éœ€è¦ ç»åº¦,çº¬åº¦,åç§°ï¼‰`);
          return;
        }
        const lng = parseFloat(parts[0].trim());
        const lat = parseFloat(parts[1].trim());
        const name = parts[2].trim();
        const remark = parts.length > 3 ? parts[3].trim() : '';  // ç¬¬å››åˆ—ï¼šå¤‡æ³¨
        const group = parts.length > 4 ? parts[4].trim() : '';  // ç¬¬äº”åˆ—ï¼šç½‘ç»„
        const employee_id = parts.length > 5 ? parts[5].trim() : '';  // ç¬¬å…­åˆ—ï¼šå·¥å·
        const employee_name = parts.length > 6 ? parts[6].trim() : '';  // ç¬¬ä¸ƒåˆ—ï¼šå§“å
        const district = parts.length > 7 ? parts[7].trim() : '';  // ç¬¬å…«åˆ—ï¼šå¿åŒº
        const adjustment = parts.length > 8 ? parts[8].trim() : '';  // ç¬¬ä¹åˆ—ï¼šè°ƒæ•´
        const mask = parts.length > 9 ? parts[9].trim() : '';  // ç¬¬ååˆ—ï¼šé®ç½©
        if (Number.isNaN(lng) || Number.isNaN(lat)) {
          errors.push(`ç¬¬${idx + 1}è¡Œï¼šç»çº¬åº¦æ ¼å¼é”™è¯¯`);
          return;
        }
        locations.push({ lng, lat, name, remark, group, employee_id, employee_name, district, adjustment, mask });
      });

      if (errors.length) {
        showError(errors.join('<br>'));
        return [];
      }
      return locations;
    }

    // ä¿å­˜åˆ†ç»„æ•°æ®
    let excelGroups = {};
    let excelEmployees = {};  // æŒ‰å·¥å·åˆ†ç»„çš„æ•°æ®
    let excelAdjustments = {};  // æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ•°æ®ï¼ˆç»“æ„ï¼šadjustment -> employee_id -> groups -> locationsï¼‰

    async function handleExcelUpload() {
      const fileInput = document.getElementById('excelFile');
      const file = fileInput.files[0];
      if (!file) return;

      showLoading('ğŸ“¤ æ­£åœ¨ä¸Šä¼ æ–‡ä»¶...');

      const formData = new FormData();
      formData.append('file', file);

      try {
        const resp = await fetch('/upload_excel', { method: 'POST', body: formData });
        const data = await resp.json();
        if (data.error) return showError(data.error);

        currentLocations = data.locations || [];
        excelGroups = data.groups || {};
        excelEmployees = data.employees || {};  // ä¿å­˜æŒ‰å·¥å·åˆ†ç»„çš„æ•°æ®
        excelAdjustments = data.adjustments || {};  // ä¿å­˜æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ•°æ®
        
        // ç¾åŒ–æˆåŠŸå¯¼å…¥çš„å¼¹çª—æ ¼å¼
        let infoHtml = `<div style="
          padding: 16px 20px;
          background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
          color: white;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
          border-left: 4px solid #2E7D32;
        ">
          <div style="font-size: 18px; font-weight: bold; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 24px;">âœ…</span>
            <span>æˆåŠŸå¯¼å…¥ ${currentLocations.length} ä¸ªç½‘ç‚¹</span>
          </div>`;
        
        if (data.group_count > 0) {
          infoHtml += `
          <div style="
            margin-top: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            backdrop-filter: blur(10px);
          ">
            <div style="font-size: 15px; font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
              <span>ğŸ“¦</span>
              <span>å…± ${data.group_count} ä¸ªç½‘ç»„</span>
            </div>
            <div style="font-size: 13px; line-height: 1.6; opacity: 0.95;">
              ${Object.keys(excelGroups).map(g => `<span style="display: inline-block; margin: 2px 4px; padding: 4px 8px; background: rgba(255, 255, 255, 0.2); border-radius: 4px;">${g} (${excelGroups[g].length}ä¸ªç½‘ç‚¹)</span>`).join('')}
            </div>
            <div style="margin-top: 10px; font-size: 13px; font-style: italic; opacity: 0.9;">
              â³ æ­£åœ¨æŒ‰ç½‘ç»„ä¾æ¬¡å¤„ç†...
            </div>
          </div>`;
        }
        
        infoHtml += `</div>`;
        document.getElementById('route-info').innerHTML = infoHtml;

        if (currentLocations.length) {
          document.getElementById('locationInput').value =
            currentLocations.map(l => [l.lng, l.lat, l.name, l.remark || "", l.group || "", l.employee_id || "", l.employee_name || "", l.district || "", l.adjustment || "", l.mask || ""].filter(x => x !== "").join(',')).join('\n');
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰é®ç½©å†…å®¹ï¼Œå¦‚æœæœ‰åˆ™æ˜¾ç¤ºé®ç½©å±‚
        updateMaskOverlay(currentLocations);

        // å¦‚æœæœ‰åˆ†ç»„æ•°æ®ï¼Œæ˜¾ç¤ºè‡ªå®šä¹‰å¯¹è¯æ¡†é€‰æ‹©æˆªå›¾æ¨¡å¼
        if (data.group_count > 0) {
          // åˆ›å»ºè‡ªå®šä¹‰æ¨¡æ€å¯¹è¯æ¡†
          showScreenshotModeDialog((useSimpleMode) => {
            // è®¾ç½®è·¯çº¿ç®€ç‰ˆå¼€å…³çŠ¶æ€
            const routeSimpleCheckbox = document.getElementById('toggleRouteSimple');
            if (routeSimpleCheckbox) {
              routeSimpleCheckbox.checked = useSimpleMode;
              // è§¦å‘changeäº‹ä»¶ï¼Œç¡®ä¿çŠ¶æ€åŒæ­¥
              if (typeof toggleRouteSimple === 'function') {
                toggleRouteSimple();
              }
            }
            
            // å»¶è¿Ÿä¸€ä¸‹å†å¼€å§‹æ‰¹é‡å¤„ç†ï¼Œç¡®ä¿UIçŠ¶æ€å·²æ›´æ–°
            setTimeout(() => {
              // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰è°ƒæ•´å­—æ®µæ•°æ®ï¼Œå¦‚æœæœ‰åˆ™æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„å¤„ç†
              if (data.adjustment_count > 0 && data.adjustment_count > 0) {
                startBatchProcessByAdjustment();
              } else if (data.employee_count > 0) {
                // å¦‚æœæœ‰å·¥å·æ•°æ®ï¼ŒæŒ‰å·¥å·åˆ†ç»„å¤„ç†
                startBatchProcessByEmployee();
              } else {
                // å¦åˆ™æŒ‰ç½‘ç»„å¤„ç†
                startBatchProcess();
              }
            }, 300);
          });
        } else {
          // æ²¡æœ‰åˆ†ç»„ï¼Œç›´æ¥ç»˜åˆ¶æ‰€æœ‰ç‚¹
          await drawPoints(currentLocations);
          document.getElementById('batchProcessSection').style.display = 'none';
        }
      } catch (e) {
        showError('ä¸Šä¼ å¤±è´¥ï¼š' + e);
      }
    }
    
    // æ‰¹é‡å¤„ç†å‡½æ•°
    async function startBatchProcess() {
      if (!excelGroups || Object.keys(excelGroups).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„ç½‘ç»„æ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥Excelæ–‡ä»¶');
        return;
      }
      
      const groups = Object.keys(excelGroups);
      const totalGroups = groups.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡åœ¨çŠ¶æ€åŒºåŸŸ
      showBatchProgress(totalGroups);
      
      const results = [];
      
      for (let i = 0; i < groups.length; i++) {
        const groupName = groups[i];
        const locations = excelGroups[groupName];
        
        // æ›´æ–°è¿›åº¦ï¼ˆåœ¨çŠ¶æ€åŒºåŸŸæ˜¾ç¤ºï¼‰
        updateBatchStatus(`æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, i + 1, totalGroups);
        
        try {
          // 1. æ¸…é™¤åœ°å›¾
          clearMap();
          
          // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
          await drawPoints(locations);
          
          // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // 4. ä¼˜åŒ–è·¯çº¿
          updateBatchStatus(`ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, i + 1, totalGroups);
          const optimizeResp = await fetch('/optimize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: locations })
          });
          const optimizeData = await optimizeResp.json();
          
          if (optimizeData.error) {
            results.push({ group: groupName, success: false, error: optimizeData.error });
            continue;
          }
          
          // 5. ç»˜åˆ¶è·¯çº¿ç»“æœï¼ˆä¸è‡ªåŠ¨æˆªå›¾ï¼Œç”±æ‰¹é‡å¤„ç†æ§åˆ¶ï¼‰
          await drawRouteResult(optimizeData, false);
          
          // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // 7. æˆªå›¾ï¼ˆä½¿ç”¨ç½‘ç»„åç§°ï¼Œå¦‚æœæ²¡æœ‰å·¥å·åˆ™ä¼ ç©ºå­—ç¬¦ä¸²ï¼Œä¼ å…¥å½“å‰ç½‘ç»„çš„locationsä»¥è·å–å¯¹åº”çš„é®ç½©å†…å®¹ï¼‰
          updateBatchStatus(`ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, i + 1, totalGroups);
          try {
            await captureScreenshot(groupName, '', '', '', locations);
            // captureScreenshotå†…éƒ¨å·²ç»å¤„ç†äº†å“åº”ï¼Œè¿™é‡Œå‡è®¾æˆåŠŸ
            results.push({ 
              group: groupName, 
              success: true, 
              location_count: locations.length
            });
          } catch (e) {
            results.push({ 
              group: groupName, 
              success: false, 
              error: 'æˆªå›¾å¤±è´¥: ' + String(e)
            });
          }
          
          // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
          await new Promise(resolve => setTimeout(resolve, 500));
          
        } catch (e) {
          results.push({ group: groupName, success: false, error: String(e) });
        }
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœï¼ˆåœ¨çŠ¶æ€åŒºåŸŸï¼‰
      const successCount = results.filter(r => r.success).length;
      const failCount = results.filter(r => !r.success).length;
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${successCount} ç»„, å¤±è´¥: ${failCount} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (failCount > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        results.filter(r => !r.success).forEach(r => {
          statusHtml += `${r.group}: ${r.error}<br>`;
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        // ä¿æŒçŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
        statusInfo.style.display = 'block';
        // å¯¹äºå¤æ‚çš„æ‰¹é‡å¤„ç†ç»“æœï¼Œç›´æ¥æ›´æ–°innerHTMLï¼Œä½†ä¿æŒçŠ¶æ€æ å¯è§
        statusInfo.innerHTML = statusHtml;
        // 10ç§’åæ¢å¤ä¸º"å°±ç»ª"çŠ¶æ€
        setTimeout(() => {
          // æ¢å¤çŠ¶æ€æ çš„æ ‡å‡†ç»“æ„ï¼ˆåŒ…å«status-textå…ƒç´ ï¼‰
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
      
      // è·¯çº¿è¯¦æƒ…é¡µä¿æŒä¸å˜ï¼Œä¸è¦†ç›–
    }

    // æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ‰¹é‡å¤„ç†å‡½æ•°ï¼ˆé¦–å…ˆæŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„ï¼Œç„¶åæŒ‰å·¥å·ã€ç½‘ç»„åˆ†ç»„ï¼‰
    async function startBatchProcessByAdjustment() {
      if (!excelAdjustments || Object.keys(excelAdjustments).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„è°ƒæ•´å­—æ®µæ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥åŒ…å«è°ƒæ•´å­—æ®µçš„Excelæ–‡ä»¶');
        return;
      }
      
      const adjustments = Object.keys(excelAdjustments);
      const totalAdjustments = adjustments.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡
      showBatchProgress(totalAdjustments);
      
      const allResults = [];
      
      // éå†æ¯ä¸ªè°ƒæ•´å­—æ®µ
      for (let adjIdx = 0; adjIdx < adjustments.length; adjIdx++) {
        const adjustment = adjustments[adjIdx];
        const adjustmentData = excelAdjustments[adjustment];
        const employeeIds = Object.keys(adjustmentData);
        const totalEmployees = employeeIds.length;
        
        updateBatchStatus(`æ­£åœ¨å¤„ç†è°ƒæ•´å­—æ®µ ${adjIdx + 1}/${totalAdjustments}: ${adjustment} - ${totalEmployees}ä¸ªå·¥å·`, adjIdx + 1, totalAdjustments);
        
        // éå†è¯¥è°ƒæ•´å­—æ®µä¸‹çš„æ¯ä¸ªå·¥å·
        for (let empIdx = 0; empIdx < employeeIds.length; empIdx++) {
          const employeeId = employeeIds[empIdx];
          const employeeData = adjustmentData[employeeId];
          const employeeName = employeeData.employee_name || '';
          const groups = Object.keys(employeeData.groups);
          const totalGroups = groups.length;
          
          updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId} (${employeeName}): ${totalGroups}ä¸ªç½‘ç»„`, adjIdx + 1, totalAdjustments);
          
          const employeeResults = [];
          
          // å¦‚æœå‹¾é€‰äº†"ä»…æˆªå–è¡Œæ”¿åŒºå›¾"ï¼Œè·³è¿‡ç½‘ç»„çš„å•ç‹¬æˆªå›¾
          if (!districtMapOnlyEnabled) {
            // å¤„ç†è¯¥å·¥å·ä¸‹çš„æ‰€æœ‰ç½‘ç»„
            for (let i = 0; i < groups.length; i++) {
              const groupName = groups[i];
              const locations = employeeData.groups[groupName];
              
              updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, adjIdx + 1, totalAdjustments);
              
              try {
                // 1. æ¸…é™¤åœ°å›¾
                clearMap();
                
                // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
                await drawPoints(locations);
                
                // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // 4. ä¼˜åŒ–è·¯çº¿
                updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, adjIdx + 1, totalAdjustments);
                const optimizeResp = await fetch('/optimize', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ locations: locations })
                });
                const optimizeData = await optimizeResp.json();
                
                if (optimizeData.error) {
                  employeeResults.push({ group: groupName, success: false, error: optimizeData.error });
                  continue;
                }
                
                // 5. ç»˜åˆ¶è·¯çº¿ç»“æœ
                await drawRouteResult(optimizeData, false);
                
                // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // 7. æˆªå›¾ï¼ˆä½¿ç”¨æ–°çš„å‘½åè§„åˆ™ï¼šç½‘ç»„ç½‘ç‚¹å›¾-å·¥å·-å§“å-è°ƒæ•´ï¼‰
                updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, adjIdx + 1, totalAdjustments);
                try {
                  await captureScreenshot(groupName, employeeId, employeeName, adjustment, locations);
                  employeeResults.push({ 
                    group: groupName, 
                    success: true, 
                    location_count: locations.length
                  });
                } catch (e) {
                  employeeResults.push({ 
                    group: groupName, 
                    success: false, 
                    error: 'æˆªå›¾å¤±è´¥: ' + String(e)
                  });
                }
                
                // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
                await new Promise(resolve => setTimeout(resolve, 500));
                
              } catch (e) {
                employeeResults.push({ group: groupName, success: false, error: String(e) });
              }
            }
          }
          
          // å¦‚æœè¡Œæ”¿åŒºå›¾åŠŸèƒ½å¼€å¯ï¼Œä¸”è¯¥å·¥å·æœ‰ç½‘ç»„ï¼Œç»˜åˆ¶è¡Œæ”¿åŒºå›¾
          if (districtMapEnabled && totalGroups > 0) {
            updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ—ºï¸ æ­£åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºå›¾...`, adjIdx + 1, totalAdjustments);
            try {
              await drawDistrictMapForEmployee(employeeId, employeeName, employeeData.groups, adjustment);
              employeeResults.push({ 
                type: 'district_map',
                success: true
              });
            } catch (e) {
              console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
              employeeResults.push({ 
                type: 'district_map',
                success: false,
                error: String(e)
              });
            }
          }
          
          allResults.push({
            adjustment: adjustment,
            employee_id: employeeId,
            employee_name: employeeName,
            groups: employeeResults
          });
        }
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœ
      const totalSuccess = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => r.success).length, 0);
      const totalFail = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => !r.success).length, 0);
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${totalSuccess} ç»„, å¤±è´¥: ${totalFail} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (totalFail > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        allResults.forEach(emp => {
          emp.groups.filter(r => !r.success).forEach(r => {
            statusHtml += `${emp.adjustment} - ${emp.employee_id} - ${r.group}: ${r.error}<br>`;
          });
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = statusHtml;
        setTimeout(() => {
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
    }

    // æŒ‰å·¥å·åˆ†ç»„çš„æ‰¹é‡å¤„ç†å‡½æ•°
    async function startBatchProcessByEmployee() {
      if (!excelEmployees || Object.keys(excelEmployees).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„å·¥å·æ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥åŒ…å«å·¥å·çš„Excelæ–‡ä»¶');
        return;
      }
      
      const employeeIds = Object.keys(excelEmployees);
      const totalEmployees = employeeIds.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡
      showBatchProgress(totalEmployees);
      
      const allResults = [];
      
      // éå†æ¯ä¸ªå·¥å·
      for (let empIdx = 0; empIdx < employeeIds.length; empIdx++) {
        const employeeId = employeeIds[empIdx];
        const employeeData = excelEmployees[employeeId];
        const employeeName = employeeData.employee_name || '';
        const groups = Object.keys(employeeData.groups);
        const totalGroups = groups.length;
        
        updateBatchStatus(`æ­£åœ¨å¤„ç†å·¥å· ${empIdx + 1}/${totalEmployees}: ${employeeId} (${employeeName}) - ${totalGroups}ä¸ªç½‘ç»„`, empIdx + 1, totalEmployees);
        
        const employeeResults = [];
        
        // å¦‚æœå‹¾é€‰äº†"ä»…æˆªå–è¡Œæ”¿åŒºå›¾"ï¼Œè·³è¿‡ç½‘ç»„çš„å•ç‹¬æˆªå›¾
        if (!districtMapOnlyEnabled) {
          // å¤„ç†è¯¥å·¥å·ä¸‹çš„æ‰€æœ‰ç½‘ç»„
          for (let i = 0; i < groups.length; i++) {
            const groupName = groups[i];
            const locations = employeeData.groups[groupName];
            
            updateBatchStatus(`å·¥å· ${employeeId}: æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, empIdx + 1, totalEmployees);
            
            try {
              // 1. æ¸…é™¤åœ°å›¾
              clearMap();
              
              // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
              await drawPoints(locations);
              
              // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
              await new Promise(resolve => setTimeout(resolve, 500));
              
              // 4. ä¼˜åŒ–è·¯çº¿
              updateBatchStatus(`å·¥å· ${employeeId}: ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, empIdx + 1, totalEmployees);
              const optimizeResp = await fetch('/optimize', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ locations: locations })
              });
              const optimizeData = await optimizeResp.json();
              
              if (optimizeData.error) {
                employeeResults.push({ group: groupName, success: false, error: optimizeData.error });
                continue;
              }
              
              // 5. ç»˜åˆ¶è·¯çº¿ç»“æœ
              await drawRouteResult(optimizeData, false);
              
              // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // 7. æˆªå›¾ï¼ˆä½¿ç”¨æ–°çš„å‘½åè§„åˆ™ï¼šå·¥å·-å§“å-ç½‘ç»„ç½‘ç‚¹å›¾-ç½‘ç»„ï¼‰
              updateBatchStatus(`å·¥å· ${employeeId}: ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, empIdx + 1, totalEmployees);
              try {
                // ä»locationsä¸­è·å–adjustmentå­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                const adjustment = locations.length > 0 && locations[0].adjustment ? locations[0].adjustment : '';
                await captureScreenshot(groupName, employeeId, employeeName, adjustment, locations);
                employeeResults.push({ 
                  group: groupName, 
                  success: true, 
                  location_count: locations.length
                });
              } catch (e) {
                employeeResults.push({ 
                  group: groupName, 
                  success: false, 
                  error: 'æˆªå›¾å¤±è´¥: ' + String(e)
                });
              }
              
              // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
              await new Promise(resolve => setTimeout(resolve, 500));
              
            } catch (e) {
              employeeResults.push({ group: groupName, success: false, error: String(e) });
            }
          }
        }
        
        // å¦‚æœè¡Œæ”¿åŒºå›¾åŠŸèƒ½å¼€å¯ï¼Œä¸”è¯¥å·¥å·æœ‰ç½‘ç»„ï¼Œç»˜åˆ¶è¡Œæ”¿åŒºå›¾
        if (districtMapEnabled && totalGroups > 0) {
          updateBatchStatus(`å·¥å· ${employeeId}: ğŸ—ºï¸ æ­£åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºå›¾...`, empIdx + 1, totalEmployees);
          try {
            // ä»ç¬¬ä¸€ä¸ªç½‘ç»„çš„ç¬¬ä¸€ä¸ªç½‘ç‚¹è·å–adjustmentå­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const firstGroupName = groups[0];
            const firstLocations = employeeData.groups[firstGroupName];
            const adjustment = firstLocations.length > 0 && firstLocations[0].adjustment ? firstLocations[0].adjustment : '';
            await drawDistrictMapForEmployee(employeeId, employeeName, employeeData.groups, adjustment);
            employeeResults.push({ 
              type: 'district_map',
              success: true
            });
          } catch (e) {
            console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
            employeeResults.push({ 
              type: 'district_map',
              success: false,
              error: String(e)
            });
          }
        }
        
        allResults.push({
          employee_id: employeeId,
          employee_name: employeeName,
          groups: employeeResults
        });
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœ
      const totalSuccess = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => r.success).length, 0);
      const totalFail = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => !r.success).length, 0);
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${totalSuccess} ç»„, å¤±è´¥: ${totalFail} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (totalFail > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        allResults.forEach(emp => {
          emp.groups.filter(r => !r.success).forEach(r => {
            statusHtml += `${emp.employee_id} - ${r.group}: ${r.error}<br>`;
          });
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = statusHtml;
        setTimeout(() => {
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
    }

    // ç»˜åˆ¶å·¥å·çš„è¡Œæ”¿åŒºå›¾
    async function drawDistrictMapForEmployee(employeeId, employeeName, groups, adjustment = '') {
      try {
        // æ”¶é›†è¯¥å·¥å·ä¸‹æ‰€æœ‰ç½‘ç‚¹çš„åæ ‡
        const allLocations = [];
        Object.values(groups).forEach(groupLocs => {
          allLocations.push(...groupLocs);
        });
        
        if (allLocations.length === 0) return;
      
      // æ”¶é›†æ‰€æœ‰ç½‘ç»„ä¸­çš„å¿åŒºå­—æ®µï¼ˆç”¨äºç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼‰
      const districtsFromField = new Set();
      allLocations.forEach(loc => {
        if (loc.district && loc.district.trim()) {
          districtsFromField.add(loc.district.trim());
        }
      });
      
      console.log(`[è¡Œæ”¿åŒºå›¾] ä»å¿åŒºå­—æ®µè·å–åˆ°çš„è¡Œæ”¿åŒº: ${Array.from(districtsFromField).join(', ')}`);
      
      // å¦‚æœæä¾›äº†å¿åŒºå­—æ®µï¼Œç›´æ¥ä½¿ç”¨å¿åŒºå­—æ®µï¼›å¦åˆ™ä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼ˆæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒºï¼‰
      let districtsMap = {};
      let useDistrictField = districtsFromField.size > 0;
      
      if (useDistrictField) {
        // ä½¿ç”¨å¿åŒºå­—æ®µæä¾›çš„è¡Œæ”¿åŒºåç§°
        console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨å¿åŒºå­—æ®µç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼Œå…± ${districtsFromField.size} ä¸ªè¡Œæ”¿åŒº`);
        Array.from(districtsFromField).forEach(districtName => {
          districtsMap[districtName] = [];  // åªéœ€è¦è¡Œæ”¿åŒºåç§°ï¼Œä¸éœ€è¦åæ ‡ä¿¡æ¯
        });
      } else {
        // å¦‚æœæ²¡æœ‰å¿åŒºå­—æ®µï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼šè°ƒç”¨APIæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒº
        console.log(`[è¡Œæ”¿åŒºå›¾] æœªæä¾›å¿åŒºå­—æ®µï¼ŒæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒºä¿¡æ¯`);
        
        try {
          const resp = await fetch('/get_district_boundary', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: allLocations })
          });
          const data = await resp.json();
          
          if (data.error || !data.success) {
            console.error('è·å–è¡Œæ”¿åŒºä¿¡æ¯å¤±è´¥:', data.error || 'æœªçŸ¥é”™è¯¯');
            return;
          }
          
          // æŒ‰è¡Œæ”¿åŒºåˆ†ç»„
          data.districts.forEach(dist => {
            const districtName = dist.district;
            if (districtName && districtName !== 'æœªçŸ¥åŒºåŸŸ' && districtName !== 'æŸ¥è¯¢å¤±è´¥') {
              if (!districtsMap[districtName]) {
                districtsMap[districtName] = [];
              }
              districtsMap[districtName].push(dist);
            }
          });
          
          console.log(`[è¡Œæ”¿åŒºå›¾] æŸ¥è¯¢åˆ°çš„è¡Œæ”¿åŒº: ${Object.keys(districtsMap).join(', ')}`);
        } catch (e) {
          console.error('æŸ¥è¯¢è¡Œæ”¿åŒºä¿¡æ¯å¤±è´¥:', e);
          return;
        }
      }
      
      if (Object.keys(districtsMap).length === 0) {
        console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆè¡Œæ”¿åŒºï¼Œè·³è¿‡è¡Œæ”¿åŒºè¾¹ç•Œç»˜åˆ¶`);
        return;
      }
      
      // æ¸…é™¤åœ°å›¾
      clearMap();
      
      // å®šä¹‰é¢œè‰²æ•°ç»„ï¼ˆç”¨äºä¸åŒè¡Œæ”¿åŒºè¾¹æ¡†ï¼Œä½¿ç”¨æ˜æ˜¾åŒºåˆ†çš„é¢œè‰²ï¼‰
      const districtColors = [
        '#FF0000',  // çº¢è‰² - æœ€æ˜æ˜¾
        '#0000FF',  // è“è‰² - ä¸çº¢è‰²å¯¹æ¯”æ˜æ˜¾
        '#00FF00',  // ç»¿è‰² - ä¸çº¢è“å¯¹æ¯”æ˜æ˜¾
        '#FF00FF',  // æ´‹çº¢è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FFFF00',  // é»„è‰² - æ˜äº®é†’ç›®
        '#00FFFF',  // é’è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FF8000',  // æ©™è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#8000FF',  // ç´«è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FF0080',  // ç²‰çº¢è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#0080FF'   // å¤©è“è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
      ];
      const groupColors = [
        '#2196F3', '#FF5722', '#4CAF50', '#FF9800', '#9C27B0',
        '#00BCD4', '#795548', '#607D8B', '#E91E63', '#009688'
      ];
      
      // å‡½æ•°ï¼šå°†é¢œè‰²å˜äº®ï¼ˆå¢åŠ äº®åº¦ï¼‰
      function brightenColor(hex, percent = 30) {
        // ç§»é™¤ # å·
        hex = hex.replace('#', '');
        
        // è½¬æ¢ä¸º RGB
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        // å¢åŠ äº®åº¦
        const newR = Math.min(255, Math.floor(r + (255 - r) * percent / 100));
        const newG = Math.min(255, Math.floor(g + (255 - g) * percent / 100));
        const newB = Math.min(255, Math.floor(b + (255 - b) * percent / 100));
        
        // è½¬æ¢å›åå…­è¿›åˆ¶
        return '#' + 
          newR.toString(16).padStart(2, '0') + 
          newG.toString(16).padStart(2, '0') + 
          newB.toString(16).padStart(2, '0');
      }
      
      // å…ˆç»˜åˆ¶æ‰€æœ‰ç½‘ç»„çš„è·¯çº¿å’Œç½‘ç‚¹ï¼ˆä¸åŒç½‘ç»„ç”¨ä¸åŒé¢œè‰²ï¼‰
      let groupIndex = 0;
      
      console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹ç»˜åˆ¶æ‰€æœ‰ç½‘ç»„çš„è·¯çº¿å’Œç½‘ç‚¹ï¼Œå…± ${Object.keys(groups).length} ä¸ªç½‘ç»„`);
      
      // ä½¿ç”¨Promiseæ•°ç»„æ¥ç­‰å¾…æ‰€æœ‰è·¯çº¿åŠ è½½å®Œæˆ
      const routePromises = [];
      
      for (const [groupName, groupLocs] of Object.entries(groups)) {
        const groupColor = groupColors[groupIndex % groupColors.length];
        groupIndex++;
        
        console.log(`[è¡Œæ”¿åŒºå›¾] ç»˜åˆ¶ç½‘ç»„ ${groupName}ï¼Œå…± ${groupLocs.length} ä¸ªç½‘ç‚¹ï¼Œé¢œè‰²: ${groupColor}`);
        
        // ä¼˜åŒ–è·¯çº¿ä»¥è·å–é¡ºåº
        let optimizedLocs = groupLocs;
        const optimizePromise = (async () => {
          try {
            const optimizeResp = await fetch('/optimize', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ locations: groupLocs })
            });
            const optimizeData = await optimizeResp.json();
            
            if (!optimizeData.error && optimizeData.route) {
              optimizedLocs = optimizeData.route;
            }
            return optimizeData;
          } catch (e) {
            console.error(`ä¼˜åŒ–ç½‘ç»„ ${groupName} è·¯çº¿å¤±è´¥:`, e);
            return null;
          }
        })();
        
        // å…ˆç»˜åˆ¶è·¯çº¿ï¼ˆåŠ ç²—ï¼Œé¢œè‰²åˆ†æ˜ï¼‰ï¼Œç¡®ä¿è·¯çº¿åœ¨åº•å±‚
        const routePromise = optimizePromise.then(async (optimizeData) => {
          if (optimizeData && !optimizeData.error && optimizeData.polyline) {
            try {
              const routePoints = optimizeData.polyline.map(p => new BMap.Point(p[0], p[1]));
              const polyline = new BMap.Polyline(routePoints, {
                strokeColor: groupColor,
                strokeWeight: 4,  // è·¯çº¿çº¿æ¡ï¼ˆç¨å¾®ç»†ä¸€ç‚¹ï¼‰
                strokeOpacity: 0.9
              });
              map.addOverlay(polyline);
              overlays.push(polyline);
              
              // ç­‰å¾…è·¯çº¿æ¸²æŸ“åˆ°åœ°å›¾ä¸Š
              await new Promise(resolve => setTimeout(resolve, 200));
              console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ ç½‘ç»„ ${groupName} è·¯çº¿å·²ç»˜åˆ¶å¹¶æ¸²æŸ“å®Œæˆ`);
            } catch (e) {
              console.error(`[è¡Œæ”¿åŒºå›¾] ç»˜åˆ¶ç½‘ç»„ ${groupName} è·¯çº¿å¤±è´¥:`, e);
            }
          }
          return optimizeData;
        });
        
        routePromises.push(routePromise);
        
        // åç»˜åˆ¶ç½‘ç‚¹ï¼ˆä½¿ç”¨ç™¾åº¦åœ°å›¾é»˜è®¤Markeræ ·å¼ï¼‰ï¼Œç¡®ä¿æ ‡è®°åœ¨ä¸Šå±‚æ˜¾ç¤º
        optimizePromise.then((optimizeData) => {
          const locsToUse = (optimizeData && !optimizeData.error && optimizeData.route) ? optimizeData.route : groupLocs;
          locsToUse.forEach((loc, idx) => {
            const pt = new BMap.Point(loc.lng, loc.lat);
            
            // ä½¿ç”¨ç™¾åº¦åœ°å›¾JS APIè‡ªå¸¦çš„é»˜è®¤Markeræ ·å¼
            const marker = new BMap.Marker(pt);
            map.addOverlay(marker);
            markers.push(marker);
          });
          console.log(`[è¡Œæ”¿åŒºå›¾] ç½‘ç»„ ${groupName} å·²ç»˜åˆ¶ ${locsToUse.length} ä¸ªç½‘ç‚¹æ ‡è®°`);
        });
      }
      
      // ç­‰å¾…æ‰€æœ‰ç½‘ç»„è·¯çº¿åŠ è½½å’Œæ¸²æŸ“å®Œæˆ
      console.log(`[è¡Œæ”¿åŒºå›¾] ç­‰å¾…æ‰€æœ‰ ${routePromises.length} ä¸ªç½‘ç»„çš„è·¯çº¿åŠ è½½å®Œæˆ...`);
      await Promise.all(routePromises);
      console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æ‰€æœ‰è·¯çº¿å·²åŠ è½½å®Œæˆ`);
      
      // é¢å¤–ç­‰å¾…ç¡®ä¿åœ°å›¾å®Œå…¨æ¸²æŸ“
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // ç°åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼ˆåœ¨è·¯çº¿å’Œç½‘ç‚¹ä¹‹ä¸Šï¼‰
      // å¦‚æœæä¾›äº†å¿åŒºå­—æ®µï¼Œç»˜åˆ¶æ‰€æœ‰ç½‘ç»„æ‰€åœ¨å¿åŒºçš„è¾¹ç•Œï¼›å¦åˆ™ç»˜åˆ¶æŸ¥è¯¢åˆ°çš„è¡Œæ”¿åŒºè¾¹ç•Œ
      console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹ç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼Œå…± ${Object.keys(districtsMap).length} ä¸ªè¡Œæ”¿åŒº`);
      
      const districtPolygons = [];
      const boundaryPromises = [];
      let colorIndex = 0;
      
      for (const [districtName, districtLocs] of Object.entries(districtsMap)) {
          const color = districtColors[colorIndex % districtColors.length];
          colorIndex++;
          
          console.log(`[è¡Œæ”¿åŒºå›¾] å¤„ç†è¡Œæ”¿åŒº: ${districtName}`);
          
          // å¦‚æœä½¿ç”¨å¿åŒºå­—æ®µï¼Œç›´æ¥ä½¿ç”¨å­—æ®µå€¼ï¼›å¦åˆ™å°è¯•ä¸åŒçš„åç§°æ ¼å¼
          let nameVariants = [];
          
          if (useDistrictField) {
            // ä½¿ç”¨å¿åŒºå­—æ®µæä¾›çš„åç§°ï¼Œç›´æ¥ä½¿ç”¨
            nameVariants.push(districtName);
            // ä¹Ÿå¯ä»¥å°è¯•ä¸€äº›å¸¸è§å˜ä½“ï¼ˆå»æ‰çœã€å¸‚ç­‰å‰ç¼€ï¼‰
            const nameWithoutProvince = districtName.replace(/^[^çœ]+çœ/, '').replace(/^[^å¸‚]+å¸‚/, '');
            if (nameWithoutProvince && nameWithoutProvince !== districtName) {
              nameVariants.push(nameWithoutProvince);
            }
            // å°è¯•å»æ‰"åŒº"ã€"å¿"ã€"å¸‚"åç¼€åçš„åç§°
            const nameWithoutSuffix = districtName.replace(/[åŒºå¿å¸‚]$/, '');
            if (nameWithoutSuffix && nameWithoutSuffix !== districtName) {
              nameVariants.push(nameWithoutSuffix);
            }
          } else {
            // å¦‚æœæ²¡æœ‰å¿åŒºå­—æ®µï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼šå°è¯•ä¸åŒçš„åç§°æ ¼å¼
            if (districtLocs && districtLocs.length > 0) {
              const firstDist = districtLocs[0];
              
              // ä¼˜å…ˆå°è¯•åŒºå¿åï¼ˆæœ€å¸¸ç”¨ï¼‰
              if (firstDist.district_level) {
                nameVariants.push(firstDist.district_level);  // "å»ºé‚ºåŒº"
              }
              
              // å°è¯•å¸‚+åŒºå¿
              if (firstDist.city && firstDist.district_level) {
                const cityName = firstDist.city.replace('å¸‚', '');
                nameVariants.push(cityName + firstDist.district_level);  // "å—äº¬å»ºé‚ºåŒº"
                nameVariants.push(firstDist.city + firstDist.district_level);  // "å—äº¬å¸‚å»ºé‚ºåŒº"
              }
            }
            
            // æœ€åå°è¯•å®Œæ•´æ ¼å¼
            nameVariants.push(districtName);  // "æ±Ÿè‹å—äº¬å¸‚å»ºé‚ºåŒº"
          }
          
          // å»é‡
          const uniqueVariants = [...new Set(nameVariants)];
          console.log(`[è¡Œæ”¿åŒºå›¾] å°†å°è¯•çš„åç§°æ ¼å¼:`, uniqueVariants);
          
          // ä½¿ç”¨PromiseåŒ…è£…Boundary APIè°ƒç”¨ï¼ˆå‚è€ƒxzqh.htmlçš„å®ç°æ–¹å¼ï¼‰
          const boundaryPromise = new Promise((resolve) => {
            let boundaryFound = false;
            let attemptIndex = 0;
            let polygonsForThisDistrict = [];  // è®°å½•è¿™ä¸ªè¡Œæ”¿åŒºç»˜åˆ¶çš„å¤šè¾¹å½¢
            
            const tryGetBoundary = (nameToTry) => {
              console.log(`[è¡Œæ”¿åŒºå›¾] å°è¯•è·å–è¾¹ç•Œ: ${nameToTry}`);
              const boundary = new BMap.Boundary();
              boundary.get(nameToTry, (rs) => {
                console.log(`[è¡Œæ”¿åŒºå›¾] Boundary APIè¿”å›ç»“æœ:`, rs);
                if (rs && rs.boundaries && rs.boundaries.length > 0) {
                  console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æˆåŠŸè·å– ${nameToTry} çš„è¾¹ç•Œï¼Œå…± ${rs.boundaries.length} ä¸ªè¾¹ç•Œ`);
                  boundaryFound = true;
                  
                  // å‚è€ƒxzqh.htmlï¼šç›´æ¥ä½¿ç”¨boundaries[i]ä½œä¸ºå‚æ•°ä¼ ç»™Polygon
                  for (let i = 0; i < rs.boundaries.length; i++) {
                    try {
                      const polygon = new BMap.Polygon(rs.boundaries[i], {
                        strokeWeight: 3,
                        strokeColor: color,
                        strokeOpacity: 0.9,
                        fillOpacity: 0,  // ä¸å¡«å……ï¼Œåªæ˜¾ç¤ºè¾¹ç•Œçº¿
                        strokeStyle: "solid"
                      });
                      map.addOverlay(polygon);
                      overlays.push(polygon);  // æ·»åŠ åˆ°overlaysæ•°ç»„ï¼Œç¡®ä¿clearMap()èƒ½æ¸…é™¤
                      districtPolygons.push(polygon);
                      polygonsForThisDistrict.push(polygon);  // è®°å½•è¿™ä¸ªè¡Œæ”¿åŒºçš„å¤šè¾¹å½¢
                      console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æˆåŠŸç»˜åˆ¶å¤šè¾¹å½¢ ${i + 1}/${rs.boundaries.length} (${districtName})`);
                    } catch (polyErr) {
                      console.error(`[è¡Œæ”¿åŒºå›¾] âŒ ç»˜åˆ¶å¤šè¾¹å½¢ ${i + 1} å¤±è´¥:`, polyErr);
                    }
                  }
                  
                  // éªŒè¯å¤šè¾¹å½¢æ˜¯å¦çœŸçš„æ·»åŠ æˆåŠŸ
                  if (polygonsForThisDistrict.length > 0) {
                    console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ ${districtName} æˆåŠŸç»˜åˆ¶ ${polygonsForThisDistrict.length} ä¸ªå¤šè¾¹å½¢`);
                  } else {
                    console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ${districtName} è™½ç„¶è·å–åˆ°è¾¹ç•Œï¼Œä½†æ²¡æœ‰æˆåŠŸç»˜åˆ¶ä»»ä½•å¤šè¾¹å½¢`);
                  }
                  
                  resolve();
                } else {
                  // å¦‚æœå½“å‰åç§°æ ¼å¼å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª
                  attemptIndex++;
                  if (attemptIndex < uniqueVariants.length && !boundaryFound) {
                    console.log(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ${nameToTry} æœªæ‰¾åˆ°è¾¹ç•Œ (boundaries: ${rs?.boundaries?.length || 0})ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæ ¼å¼...`);
                    tryGetBoundary(uniqueVariants[attemptIndex]);
                  } else {
                    console.log(`[è¡Œæ”¿åŒºå›¾] âŒ æ‰€æœ‰æ ¼å¼éƒ½å¤±è´¥ï¼Œæ— æ³•è·å– ${districtName} çš„è¾¹ç•Œ`);
                    console.log(`[è¡Œæ”¿åŒºå›¾] å°è¯•è¿‡çš„åç§°æ ¼å¼:`, uniqueVariants);
                    console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ${districtName} çš„è¾¹ç•Œç»˜åˆ¶å¤±è´¥ï¼Œè¯¥è¡Œæ”¿åŒºå°†æ²¡æœ‰è¾¹ç•Œæ˜¾ç¤º`);
                    resolve();  // å³ä½¿å¤±è´¥ä¹Ÿresolveï¼Œä¸é˜»å¡å…¶ä»–è¡Œæ”¿åŒºçš„ç»˜åˆ¶
                  }
                }
              });
            };
            
            // å¼€å§‹å°è¯•ç¬¬ä¸€ä¸ªåç§°æ ¼å¼
            if (uniqueVariants.length > 0) {
              tryGetBoundary(uniqueVariants[0]);
            } else {
              // å¦‚æœæ²¡æœ‰å¯ç”¨çš„åç§°å˜ä½“ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹åç§°
              tryGetBoundary(districtName);
            }
          });
          boundaryPromises.push(boundaryPromise);
        }
        
        // ç­‰å¾…æ‰€æœ‰è¾¹ç•Œç»˜åˆ¶å®Œæˆ
        console.log(`[è¡Œæ”¿åŒºå›¾] ç­‰å¾…æ‰€æœ‰ ${boundaryPromises.length} ä¸ªè¡Œæ”¿åŒºçš„è¾¹ç•Œç»˜åˆ¶å®Œæˆ...`);
        await Promise.all(boundaryPromises);
        console.log(`[è¡Œæ”¿åŒºå›¾] æ‰€æœ‰è¾¹ç•ŒPromiseå·²å®Œæˆï¼Œå·²ç»˜åˆ¶ ${districtPolygons.length} ä¸ªå¤šè¾¹å½¢`);
        
        // é¢å¤–ç­‰å¾…ï¼Œç¡®ä¿æ‰€æœ‰å¤šè¾¹å½¢éƒ½å·²ç»æ¸²æŸ“åˆ°åœ°å›¾ä¸Š
        // ç™¾åº¦åœ°å›¾çš„addOverlayæ˜¯å¼‚æ­¥çš„ï¼Œéœ€è¦ç­‰å¾…åœ°å›¾æ¸²æŸ“å®Œæˆ
        console.log(`[è¡Œæ”¿åŒºå›¾] ç­‰å¾…åœ°å›¾æ¸²æŸ“å¤šè¾¹å½¢ï¼ˆç¬¬1æ¬¡ç­‰å¾…ï¼Œ2ç§’ï¼‰...`);
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // éªŒè¯å¤šè¾¹å½¢æ˜¯å¦çœŸçš„æ·»åŠ åˆ°äº†åœ°å›¾ä¸Š
        const polygonOverlaysAfterFirstWait = overlays.filter(overlay => {
          try {
            return overlay && overlay.getPath && typeof overlay.getPath === 'function';
          } catch (e) {
            return false;
          }
        });
        console.log(`[è¡Œæ”¿åŒºå›¾] ç¬¬1æ¬¡ç­‰å¾…åï¼Œåœ°å›¾ä¸Šæœ‰ ${polygonOverlaysAfterFirstWait.length} ä¸ªå¤šè¾¹å½¢`);
        
        // å¦‚æœå¤šè¾¹å½¢æ•°é‡ä¸è¶³ï¼Œå†ç­‰å¾…ä¸€æ¬¡
        const expectedDistrictsCountForWait = Object.keys(districtsMap).length;
        if (polygonOverlaysAfterFirstWait.length < expectedDistrictsCountForWait && polygonOverlaysAfterFirstWait.length < districtPolygons.length) {
          console.log(`[è¡Œæ”¿åŒºå›¾] å¤šè¾¹å½¢æ•°é‡ä¸è¶³ï¼Œå†æ¬¡ç­‰å¾…3ç§’ä»¥ç¡®ä¿æ¸²æŸ“å®Œæˆ...`);
          await new Promise(resolve => setTimeout(resolve, 3000));
        }
        
        // éªŒè¯å¤šè¾¹å½¢æ˜¯å¦çœŸçš„æ·»åŠ åˆ°äº†åœ°å›¾ä¸Šï¼ˆé€šè¿‡æ£€æŸ¥overlaysæ•°ç»„ï¼‰
        const polygonOverlays = overlays.filter(overlay => {
          try {
            // æ£€æŸ¥æ˜¯å¦æ˜¯Polygonç±»å‹
            return overlay && overlay.getPath && typeof overlay.getPath === 'function';
          } catch (e) {
            return false;
          }
        });
        console.log(`[è¡Œæ”¿åŒºå›¾] éªŒè¯ï¼šåœ°å›¾ä¸Šå…±æœ‰ ${polygonOverlays.length} ä¸ªå¤šè¾¹å½¢è¦†ç›–ç‰©`);
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰é¢„æœŸçš„è¡Œæ”¿åŒºéƒ½æœ‰å¯¹åº”çš„å¤šè¾¹å½¢
        const expectedDistrictsCount = Object.keys(districtsMap).length;
        if (polygonOverlays.length < expectedDistrictsCount) {
          console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ è­¦å‘Šï¼šé¢„æœŸ ${expectedDistrictsCount} ä¸ªè¡Œæ”¿åŒºï¼Œä½†åªç»˜åˆ¶äº† ${polygonOverlays.length} ä¸ªå¤šè¾¹å½¢`);
          console.warn(`[è¡Œæ”¿åŒºå›¾] å·²ç»˜åˆ¶çš„å¤šè¾¹å½¢æ•°é‡: ${districtPolygons.length}ï¼Œåœ°å›¾ä¸Šçš„å¤šè¾¹å½¢æ•°é‡: ${polygonOverlays.length}`);
          
          // åˆ—å‡ºå·²ç»˜åˆ¶çš„è¡Œæ”¿åŒº
          const drawnDistricts = new Set();
          districtPolygons.forEach((polygon, idx) => {
            try {
              const path = polygon.getPath();
              if (path && path.length > 0) {
                drawnDistricts.add(`å¤šè¾¹å½¢${idx + 1}`);
              }
            } catch (e) {
              // å¿½ç•¥é”™è¯¯
            }
          });
          console.log(`[è¡Œæ”¿åŒºå›¾] å·²ç»˜åˆ¶çš„å¤šè¾¹å½¢: ${Array.from(drawnDistricts).join(', ')}`);
        } else {
          console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æ‰€æœ‰ ${expectedDistrictsCount} ä¸ªè¡Œæ”¿åŒºéƒ½æœ‰å¯¹åº”çš„å¤šè¾¹å½¢`);
        }
        
        // å†æ¬¡ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾å®Œå…¨æ¸²æŸ“
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // æ”¶é›†æ‰€æœ‰è¾¹ç•Œç‚¹ï¼Œç”¨äºæœ€ç»ˆè°ƒæ•´è§†é‡
        const allBoundaryPoints = [];
        districtPolygons.forEach((polygon, idx) => {
          try {
            const path = polygon.getPath();
            if (path && path.length > 0) {
              path.forEach(point => {
                allBoundaryPoints.push(point);
              });
              console.log(`[è¡Œæ”¿åŒºå›¾] å¤šè¾¹å½¢ ${idx + 1} æœ‰ ${path.length} ä¸ªç‚¹`);
            } else {
              console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ å¤šè¾¹å½¢ ${idx + 1} æ²¡æœ‰è·¯å¾„ç‚¹`);
            }
          } catch (e) {
            console.error(`[è¡Œæ”¿åŒºå›¾] è·å–è¾¹ç•Œç‚¹å¤±è´¥ (å¤šè¾¹å½¢ ${idx + 1}):`, e);
          }
        });
        console.log(`[è¡Œæ”¿åŒºå›¾] æ€»å…±æ”¶é›†åˆ° ${allBoundaryPoints.length} ä¸ªè¾¹ç•Œç‚¹`);
        
        // å¦‚æœè¾¹ç•Œç‚¹æ•°é‡ä¸º0ï¼Œè¯´æ˜æ²¡æœ‰æˆåŠŸç»˜åˆ¶ä»»ä½•è¾¹ç•Œï¼Œç»™å‡ºè­¦å‘Š
        if (allBoundaryPoints.length === 0) {
          console.error(`[è¡Œæ”¿åŒºå›¾] âŒ é”™è¯¯ï¼šæ²¡æœ‰æ”¶é›†åˆ°ä»»ä½•è¾¹ç•Œç‚¹ï¼å¯èƒ½æ‰€æœ‰è¾¹ç•Œç»˜åˆ¶éƒ½å¤±è´¥äº†`);
          console.error(`[è¡Œæ”¿åŒºå›¾] é¢„æœŸè¡Œæ”¿åŒºæ•°é‡: ${expectedDistrictsCount}ï¼Œå®é™…ç»˜åˆ¶çš„å¤šè¾¹å½¢æ•°é‡: ${districtPolygons.length}`);
          // å¯ä»¥é€‰æ‹©æ˜¯å¦ç»§ç»­æˆªå›¾ï¼Œæˆ–è€…æŠ›å‡ºé”™è¯¯
          // è¿™é‡Œé€‰æ‹©ç»§ç»­ï¼Œä½†ä¼šç»™å‡ºæ˜ç¡®çš„è­¦å‘Š
        }
        
        // åˆå¹¶æ‰€æœ‰ç‚¹ï¼ˆç½‘ç‚¹ + è¾¹ç•Œç‚¹ï¼‰ç”¨äºè°ƒæ•´è§†é‡
        const allPoints = allLocations.map(loc => new BMap.Point(loc.lng, loc.lat));
        const combinedPoints = [...allPoints, ...allBoundaryPoints];
        
        // ç­‰å¾…ä¸€ä¸‹ç¡®ä¿æ‰€æœ‰è¦†ç›–ç‰©éƒ½å·²æ·»åŠ 
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // è°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬è¡Œæ”¿è¾¹ç•Œï¼‰
        // ç›®æ ‡ï¼šç¡®ä¿æ‰€æœ‰å¿åŒºçš„æ‰€æœ‰è¾¹æ¡†éƒ½åœ¨è§†é‡èŒƒå›´å†…
        const maxZoom = 15;  // æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼Œé¿å…è¿‡è¿‘
        const minZoom = 8;   // æœ€å°ç¼©æ”¾çº§åˆ«ï¼Œç¡®ä¿èƒ½åŒ…å«æ›´å¤§çš„åŒºåŸŸ
        
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        const viewPadding = 50;  // è§†é‡è¾¹è·ï¼Œç¡®ä¿è¾¹ç•Œä¸ä¼šè¢«è£åˆ‡
        
        // è®¡ç®—æ‰€æœ‰ç‚¹çš„è¾¹ç•Œæ¡†
        const calculateBounds = (points) => {
          if (points.length === 0) return null;
          
          let minLng = points[0].lng;
          let maxLng = points[0].lng;
          let minLat = points[0].lat;
          let maxLat = points[0].lat;
          
          points.forEach(pt => {
            minLng = Math.min(minLng, pt.lng);
            maxLng = Math.max(maxLng, pt.lng);
            minLat = Math.min(minLat, pt.lat);
            maxLat = Math.max(maxLat, pt.lat);
          });
          
          return { minLng, maxLng, minLat, maxLat };
        };
        
        // æ£€æŸ¥æ‰€æœ‰è¾¹ç•Œç‚¹æ˜¯å¦éƒ½åœ¨è§†é‡å†…ï¼ˆè€ƒè™‘æ§åˆ¶é¢æ¿å’Œè¾¹è·ï¼‰
        const checkAllPointsVisible = (points, bounds) => {
          if (!bounds || points.length === 0) return false;
          
          const mapRect = map.getContainer().getBoundingClientRect();
          const effectiveLeft = panelRight + viewPadding;
          const effectiveRight = mapRect.width - viewPadding;
          const effectiveTop = viewPadding;
          const effectiveBottom = mapRect.height - viewPadding;
          
          // å°†æ‰€æœ‰è¾¹ç•Œç‚¹è½¬æ¢ä¸ºå±å¹•åæ ‡ï¼Œæ£€æŸ¥æ˜¯å¦éƒ½åœ¨æœ‰æ•ˆè§†é‡å†…
          for (const pt of points) {
            try {
              const pixel = map.pointToPixel(pt);
              const screenX = pixel.x;
              const screenY = pixel.y;
              
              // æ£€æŸ¥æ˜¯å¦åœ¨æœ‰æ•ˆè§†é‡åŒºåŸŸå†…
              if (screenX < effectiveLeft || screenX > effectiveRight || 
                  screenY < effectiveTop || screenY > effectiveBottom) {
                return false;
              }
            } catch (e) {
              // è½¬æ¢å¤±è´¥ï¼Œè®¤ä¸ºä¸åœ¨è§†é‡å†…
              return false;
            }
          }
          
          return true;
        };
        
        // æ ¹æ®è¾¹ç•Œæ¡†è®¾ç½®åœ°å›¾è§†é‡
        const setViewportFromBounds = (bounds, padding = 0.1) => {
          // padding æ˜¯ç›¸å¯¹äºè¾¹ç•Œæ¡†çš„ç™¾åˆ†æ¯”è¾¹è·ï¼ˆä¾‹å¦‚ 0.1 è¡¨ç¤ºå¢åŠ 10%çš„è¾¹è·ï¼‰
          const lngRange = bounds.maxLng - bounds.minLng;
          const latRange = bounds.maxLat - bounds.minLat;
          
          // è®¡ç®—å¸¦è¾¹è·çš„è¾¹ç•Œ
          const paddedMinLng = bounds.minLng - lngRange * padding;
          const paddedMaxLng = bounds.maxLng + lngRange * padding;
          const paddedMinLat = bounds.minLat - latRange * padding;
          const paddedMaxLat = bounds.maxLat + latRange * padding;
          
          // è®¡ç®—ä¸­å¿ƒç‚¹
          const centerLng = (paddedMinLng + paddedMaxLng) / 2;
          const centerLat = (paddedMinLat + paddedMaxLat) / 2;
          const center = new BMap.Point(centerLng, centerLat);
          
          // è®¾ç½®ä¸­å¿ƒ
          map.setCenter(center);
          
          // è®¡ç®—åˆé€‚çš„ç¼©æ”¾çº§åˆ«
          const mapRect = map.getContainer().getBoundingClientRect();
          const effectiveWidth = mapRect.width - panelRight - viewPadding * 2;
          const effectiveHeight = mapRect.height - viewPadding * 2;
          
          // è®¡ç®—éœ€è¦çš„ç¼©æ”¾çº§åˆ«
          const lngZoom = Math.log2(360 * effectiveWidth / 256 / (paddedMaxLng - paddedMinLng));
          const latZoom = Math.log2(360 * effectiveHeight / 256 / (paddedMaxLat - paddedMinLat));
          let zoom = Math.floor(Math.min(lngZoom, latZoom));
          
          // é™åˆ¶åœ¨åˆç†èŒƒå›´å†…ï¼ˆåˆå§‹è®¾ç½®æ—¶ç¨å¾®ä¿å®ˆä¸€ç‚¹ï¼Œåé¢ä¼šå°è¯•æ”¾å¤§ï¼‰
          zoom = Math.max(minZoom, Math.min(maxZoom, zoom));
          
          // ç¨å¾®ç¼©å°ä¸€ç‚¹ä½œä¸ºåˆå§‹å€¼ï¼Œåé¢ä¼šå°è¯•åœ¨å¯è§çš„å‰æä¸‹å°½å¯èƒ½æ”¾å¤§
          zoom = Math.max(minZoom, zoom - 1);
          
          map.setZoom(zoom);
        };
        
        if (allBoundaryPoints.length > 0) {
          // ä¼˜å…ˆä½¿ç”¨è¾¹ç•Œç‚¹è®¡ç®—è§†é‡ï¼Œç¡®ä¿æ‰€æœ‰å¿åŒºè¾¹æ¡†éƒ½åœ¨è§†é‡å†…
          console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨è¾¹ç•Œç‚¹è°ƒæ•´è§†é‡ï¼Œç¡®ä¿æ‰€æœ‰ ${allBoundaryPoints.length} ä¸ªè¾¹ç•Œç‚¹éƒ½åœ¨è§†é‡å†…`);
          
          // è®¡ç®—è¾¹ç•Œæ¡†ï¼ˆåªä½¿ç”¨è¾¹ç•Œç‚¹ï¼Œå› ä¸ºè¿™æ˜¯æœ€é‡è¦çš„ï¼‰
          const bounds = calculateBounds(allBoundaryPoints);
          
          if (bounds) {
            // è®¾ç½®åˆå§‹è§†é‡ï¼ˆä½¿ç”¨è¾¹ç•Œç‚¹ï¼Œå¸¦10%è¾¹è·ï¼‰
            setViewportFromBounds(bounds, 0.15);  // 15%çš„è¾¹è·ï¼Œç¡®ä¿æ‰€æœ‰è¾¹ç•Œéƒ½åœ¨è§†é‡å†…
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // éªŒè¯æ‰€æœ‰è¾¹ç•Œç‚¹æ˜¯å¦éƒ½åœ¨è§†é‡å†…
            let currentZoom = map.getZoom();
            let allVisible = checkAllPointsVisible(allBoundaryPoints, bounds);
            let attempts = 0;
            const maxAttempts = 10;
            
            // å¦‚æœä¸åœ¨è§†é‡å†…ï¼Œé€æ­¥ç¼©å°ç›´åˆ°æ‰€æœ‰ç‚¹éƒ½åœ¨è§†é‡å†…
            while (!allVisible && currentZoom > minZoom && attempts < maxAttempts) {
              currentZoom = Math.max(minZoom, currentZoom - 1);
              map.setZoom(currentZoom);
              await new Promise(resolve => setTimeout(resolve, 300));
              
              // é‡æ–°è®¡ç®—è¾¹ç•Œæ¡†ï¼ˆå› ä¸ºè§†é‡å˜äº†ï¼‰
              const newBounds = calculateBounds(allBoundaryPoints);
              allVisible = checkAllPointsVisible(allBoundaryPoints, newBounds);
              
              console.log(`[è¡Œæ”¿åŒºå›¾] å°è¯•ç¼©æ”¾çº§åˆ« ${currentZoom}ï¼Œæ‰€æœ‰è¾¹ç•Œç‚¹å¯è§: ${allVisible}`);
              attempts++;
            }
            
            if (allVisible) {
              console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æ‰€æœ‰è¾¹ç•Œç‚¹éƒ½åœ¨è§†é‡å†…ï¼Œå½“å‰ç¼©æ”¾çº§åˆ«: ${currentZoom}`);
              
              // åœ¨ç¡®ä¿æ‰€æœ‰è¾¹ç•Œç‚¹å¯è§çš„å‰æä¸‹ï¼Œé€æ­¥å°è¯•å¢å¤§ç¼©æ”¾çº§åˆ«ï¼Œæ‰¾åˆ°æœ€å¤§å¯ç”¨ç¼©æ”¾çº§åˆ«
              let bestZoom = currentZoom;
              console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹å°è¯•æ”¾å¤§ï¼Œä»ç¼©æ”¾çº§åˆ« ${currentZoom} å¼€å§‹ï¼Œæœ€å¤§ç¼©æ”¾çº§åˆ«: ${maxZoom}`);
              
              // ä»å½“å‰ç¼©æ”¾çº§åˆ«å¼€å§‹ï¼Œé€æ­¥å°è¯•å¢å¤§
              for (let testZoom = currentZoom + 1; testZoom <= maxZoom; testZoom++) {
                map.setZoom(testZoom);
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // æ£€æŸ¥æ‰€æœ‰è¾¹ç•Œç‚¹æ˜¯å¦ä»ç„¶å¯è§
                const newBounds = calculateBounds(allBoundaryPoints);
                const stillVisible = checkAllPointsVisible(allBoundaryPoints, newBounds);
                
                if (stillVisible) {
                  bestZoom = testZoom;
                  console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šæ‰€æœ‰è¾¹ç•Œç‚¹ä»ç„¶å¯è§ï¼Œå¯ä»¥ç»§ç»­æ”¾å¤§`);
                } else {
                  // å¦‚æœæ”¾å¤§åä¸å¯è§ï¼Œå›é€€åˆ°ä¸Šä¸€ä¸ªå¯ç”¨çš„ç¼©æ”¾çº§åˆ«
                  console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šéƒ¨åˆ†è¾¹ç•Œç‚¹ä¸å¯è§ï¼Œå›é€€åˆ° ${bestZoom}`);
                  map.setZoom(bestZoom);
                  await new Promise(resolve => setTimeout(resolve, 300));
                  break;
                }
              }
              
              currentZoom = bestZoom;
              console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${currentZoom}ï¼ˆç¡®ä¿æ‰€æœ‰è¾¹ç•Œç‚¹å¯è§çš„æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼‰`);
            } else {
              console.log(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ç»è¿‡ ${attempts} æ¬¡å°è¯•ï¼Œéƒ¨åˆ†è¾¹ç•Œç‚¹å¯èƒ½ä¸åœ¨è§†é‡å†…ï¼Œå½“å‰ç¼©æ”¾çº§åˆ«: ${currentZoom}`);
            }
            
            // å¦‚æœè¿˜æœ‰ç½‘ç‚¹ï¼Œä¹Ÿæ£€æŸ¥ç½‘ç‚¹æ˜¯å¦åœ¨è§†é‡å†…ï¼ˆå¯é€‰ï¼‰
            if (allPoints.length > 0) {
              const newBounds = calculateBounds(allBoundaryPoints);
              let allPointsVisible = checkAllPointsVisible(allPoints, newBounds);
              
              // å¦‚æœç½‘ç‚¹ä¸åœ¨è§†é‡å†…ï¼Œç¨å¾®ç¼©å°ä¸€ç‚¹ï¼Œä½†è¦ç¡®ä¿ä»ç„¶å°½å¯èƒ½å¤§
              if (!allPointsVisible && currentZoom > minZoom) {
                currentZoom = Math.max(minZoom, currentZoom - 1);
                map.setZoom(currentZoom);
                await new Promise(resolve => setTimeout(resolve, 300));
                console.log(`[è¡Œæ”¿åŒºå›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«ä»¥åŒ…å«æ‰€æœ‰ç½‘ç‚¹: ${currentZoom}`);
                
                // å†æ¬¡éªŒè¯æ‰€æœ‰è¾¹ç•Œç‚¹ä»ç„¶å¯è§
                const finalBounds = calculateBounds(allBoundaryPoints);
                const boundaryStillVisible = checkAllPointsVisible(allBoundaryPoints, finalBounds);
                if (!boundaryStillVisible) {
                  // å¦‚æœç¼©å°åè¾¹ç•Œç‚¹ä¸å¯è§ï¼Œè¿™æ˜¯ä¸åº”è¯¥å‘ç”Ÿçš„ï¼Œè®°å½•è­¦å‘Š
                  console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ç¼©å°åè¾¹ç•Œç‚¹ä¸å¯è§ï¼Œéœ€è¦è¿›ä¸€æ­¥è°ƒæ•´`);
                }
              }
            }
          } else {
            // å¦‚æœè¾¹ç•Œæ¡†è®¡ç®—å¤±è´¥ï¼Œå›é€€åˆ°ä½¿ç”¨setViewport
            console.log(`[è¡Œæ”¿åŒºå›¾] è¾¹ç•Œæ¡†è®¡ç®—å¤±è´¥ï¼Œä½¿ç”¨setViewport`);
            map.setViewport(allBoundaryPoints);
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // ç¼©å°ä¸€ç‚¹ç¡®ä¿è¾¹ç•Œå¯è§
            let currentZoom = map.getZoom();
            if (currentZoom > minZoom) {
              currentZoom = Math.max(minZoom, currentZoom - 1);
              map.setZoom(currentZoom);
              await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            // å°è¯•åœ¨å¯è§çš„å‰æä¸‹å°½å¯èƒ½æ”¾å¤§
            let bestZoom = currentZoom;
            console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹å°è¯•æ”¾å¤§ï¼Œä»ç¼©æ”¾çº§åˆ« ${currentZoom} å¼€å§‹`);
            for (let testZoom = currentZoom + 1; testZoom <= maxZoom; testZoom++) {
              map.setZoom(testZoom);
              await new Promise(resolve => setTimeout(resolve, 300));
              
              // ç®€å•æ£€æŸ¥ï¼šä½¿ç”¨getBoundséªŒè¯æ˜¯å¦æ‰€æœ‰ç‚¹éƒ½åœ¨è§†é‡å†…
              try {
                const mapBounds = map.getBounds();
                let allInBounds = true;
                for (const pt of allBoundaryPoints) {
                  if (!mapBounds.containsPoint(pt)) {
                    allInBounds = false;
                    break;
                  }
                }
                
                if (allInBounds) {
                  bestZoom = testZoom;
                  console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šæ‰€æœ‰è¾¹ç•Œç‚¹ä»ç„¶å¯è§ï¼Œå¯ä»¥ç»§ç»­æ”¾å¤§`);
                } else {
                  console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šéƒ¨åˆ†è¾¹ç•Œç‚¹ä¸å¯è§ï¼Œå›é€€åˆ° ${bestZoom}`);
                  map.setZoom(bestZoom);
                  await new Promise(resolve => setTimeout(resolve, 300));
                  break;
                }
              } catch (e) {
                // å¦‚æœæ£€æŸ¥å¤±è´¥ï¼Œä¿æŒå½“å‰ç¼©æ”¾çº§åˆ«
                console.log(`[è¡Œæ”¿åŒºå›¾] æ£€æŸ¥å¤±è´¥ï¼Œå›é€€åˆ° ${bestZoom}`);
                map.setZoom(bestZoom);
                await new Promise(resolve => setTimeout(resolve, 300));
                break;
              }
            }
            console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${bestZoom}ï¼ˆç¡®ä¿æ‰€æœ‰è¾¹ç•Œç‚¹å¯è§çš„æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼‰`);
          }
          
          await new Promise(resolve => setTimeout(resolve, 500));
        } else if (allPoints.length > 0) {
          // å¦‚æœæ²¡æœ‰è¾¹ç•Œç‚¹ï¼Œä½¿ç”¨ç½‘ç‚¹è°ƒæ•´è§†é‡
          console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨ç½‘ç‚¹è°ƒæ•´è§†é‡ï¼Œå…± ${allPoints.length} ä¸ªç‚¹`);
          map.setViewport(allPoints);
          await new Promise(resolve => setTimeout(resolve, 500));
          let currentZoom = map.getZoom();
          
          if (currentZoom > maxZoom) {
            map.setZoom(maxZoom);
            console.log(`[è¡Œæ”¿åŒºå›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${maxZoom}ï¼ˆé™åˆ¶æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼‰`);
          } else {
            console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ«åˆé€‚: ${currentZoom}ï¼ˆç½‘ç‚¹æ•°é‡: ${allPoints.length}ï¼‰`);
          }
        }
        
        // ç­‰å¾…æ¸²æŸ“å®Œæˆ
        console.log('[è¡Œæ”¿åŒºå›¾] ç­‰å¾…åœ°å›¾æ¸²æŸ“å®Œæˆ...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // æœ€åéªŒè¯ï¼šæ£€æŸ¥æ˜¯å¦æœ‰è¾¹ç•Œå¤šè¾¹å½¢ï¼ˆåœ¨æˆªå›¾å‰ï¼‰
        const finalPolygonOverlays = overlays.filter(overlay => {
          try {
            return overlay && overlay.getPath && typeof overlay.getPath === 'function';
          } catch (e) {
            return false;
          }
        });
        const expectedDistrictsFinal = Object.keys(districtsMap).length;
        
        console.log(`[è¡Œæ”¿åŒºå›¾] æˆªå›¾å‰æœ€ç»ˆéªŒè¯ï¼šåœ°å›¾ä¸Šæœ‰ ${finalPolygonOverlays.length} ä¸ªè¾¹ç•Œå¤šè¾¹å½¢ï¼Œé¢„æœŸ ${expectedDistrictsFinal} ä¸ªè¡Œæ”¿åŒº`);
        
        if (finalPolygonOverlays.length === 0 && expectedDistrictsFinal > 0) {
          console.error(`[è¡Œæ”¿åŒºå›¾] âŒ ä¸¥é‡è­¦å‘Šï¼šæ²¡æœ‰ç»˜åˆ¶ä»»ä½•è¾¹ç•Œå¤šè¾¹å½¢å°±å¼€å§‹æˆªå›¾ï¼`);
          console.error(`[è¡Œæ”¿åŒºå›¾] é¢„æœŸ ${expectedDistrictsFinal} ä¸ªè¡Œæ”¿åŒºçš„è¾¹ç•Œï¼Œä½†åœ°å›¾ä¸Šæ²¡æœ‰ä»»ä½•å¤šè¾¹å½¢`);
          console.log(`[è¡Œæ”¿åŒºå›¾] ç­‰å¾…é¢å¤–3ç§’ï¼Œå¸Œæœ›è¾¹ç•Œèƒ½å¤Ÿæ¸²æŸ“...`);
          await new Promise(resolve => setTimeout(resolve, 3000));
          
          // å†æ¬¡æ£€æŸ¥
          const retryPolygonOverlays = overlays.filter(overlay => {
            try {
              return overlay && overlay.getPath && typeof overlay.getPath === 'function';
            } catch (e) {
              return false;
            }
          });
          console.log(`[è¡Œæ”¿åŒºå›¾] é‡è¯•åæ£€æŸ¥ï¼šåœ°å›¾ä¸Šæœ‰ ${retryPolygonOverlays.length} ä¸ªè¾¹ç•Œå¤šè¾¹å½¢`);
          
          if (retryPolygonOverlays.length === 0) {
            console.error(`[è¡Œæ”¿åŒºå›¾] âŒ é”™è¯¯ï¼šç»è¿‡é¢å¤–ç­‰å¾…åä»ç„¶æ²¡æœ‰è¾¹ç•Œå¤šè¾¹å½¢ï¼Œä½†å°†ç»§ç»­æˆªå›¾`);
            console.error(`[è¡Œæ”¿åŒºå›¾] è¿™å¯èƒ½å¯¼è‡´æˆªå›¾ä¸åŒ…å«ä»»ä½•åŒºè¾¹æ¡†ï¼Œè¯·æ£€æŸ¥ï¼š`);
            console.error(`[è¡Œæ”¿åŒºå›¾] 1. è¡Œæ”¿åŒºåç§°æ˜¯å¦æ­£ç¡®`);
            console.error(`[è¡Œæ”¿åŒºå›¾] 2. ç™¾åº¦åœ°å›¾APIæ˜¯å¦æ­£å¸¸`);
            console.error(`[è¡Œæ”¿åŒºå›¾] 3. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸`);
          }
        } else if (finalPolygonOverlays.length < expectedDistrictsFinal) {
          console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ è­¦å‘Šï¼šé¢„æœŸ ${expectedDistrictsFinal} ä¸ªè¡Œæ”¿åŒºï¼Œä½†åªç»˜åˆ¶äº† ${finalPolygonOverlays.length} ä¸ªè¾¹ç•Œ`);
          console.warn(`[è¡Œæ”¿åŒºå›¾] éƒ¨åˆ†è¡Œæ”¿åŒºçš„è¾¹ç•Œå¯èƒ½æœªç»˜åˆ¶æˆåŠŸï¼Œä½†å°†ç»§ç»­æˆªå›¾`);
        }
        
        console.log('[è¡Œæ”¿åŒºå›¾] å¼€å§‹æˆªå›¾...');
        // æˆªå›¾ï¼ˆä½¿ç”¨ç‰¹æ®Šæ ‡è®°è¡¨ç¤ºè¿™æ˜¯è¡Œæ”¿åŒºå›¾ï¼‰
        // è¡Œæ”¿åŒºå›¾ä¸éœ€è¦adjustmentå­—æ®µ
        await captureScreenshot('__DISTRICT_MAP__', employeeId, employeeName, adjustment);
        console.log('[è¡Œæ”¿åŒºå›¾] æˆªå›¾å®Œæˆ');
        
        // æˆªå›¾å®Œæˆåï¼Œæ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰è¦†ç›–ç‰©ï¼ˆè·¯çº¿ã€è¾¹æ¡†ã€ç½‘ç‚¹åœ†åœˆï¼‰ï¼Œé¿å…å½±å“ä¸‹ä¸€ä¸ªå‘˜å·¥
        console.log('[è¡Œæ”¿åŒºå›¾] æ¸…é™¤åœ°å›¾è¦†ç›–ç‰©ï¼Œå‡†å¤‡ä¸‹ä¸€ä¸ªå‘˜å·¥çš„æ•°æ®...');
        clearMap();
        // ç­‰å¾…æ¸…é™¤å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
        console.log('[è¡Œæ”¿åŒºå›¾] åœ°å›¾å·²æ¸…é™¤ï¼Œå¯ä»¥å¤„ç†ä¸‹ä¸€ä¸ªå‘˜å·¥çš„æ•°æ®');
        
    } catch (e) {
      console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
      // å³ä½¿å‡ºé”™ä¹Ÿè¦æ¸…é™¤åœ°å›¾ï¼Œé¿å…å½±å“ä¸‹ä¸€ä¸ªå‘˜å·¥
      try {
        clearMap();
      } catch (clearErr) {
        console.error('æ¸…é™¤åœ°å›¾å¤±è´¥:', clearErr);
      }
      throw e;
    }
  }

  // ä»…æˆªå–è¡Œæ”¿åŒºå›¾ï¼ˆç»˜åˆ¶ç½‘ç‚¹ã€è·¯çº¿å’ŒåŒºè¾¹æ¡†ï¼‰- æ‰‹åŠ¨è°ƒç”¨
  async function captureDistrictMapOnly() {
    try {
      // è·å–å½“å‰åœ°å›¾ä¸Šçš„æ‰€æœ‰ç½‘ç‚¹æ•°æ®
      const locations = currentLocations.length > 0 ? currentLocations : parseLocationData();
      
      if (locations.length === 0) {
        showError('è¯·å…ˆå¯¼å…¥æˆ–è¾“å…¥ç½‘ç‚¹æ•°æ®ï¼');
        return;
      }
      
      // æŒ‰ç½‘ç»„åˆ†ç»„
      const groups = groupLocationsByGroup(locations);
      
      if (Object.keys(groups).length === 0) {
        showError('æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„ç½‘ç»„æ•°æ®ï¼');
        return;
      }
      
      // æ”¶é›†å·¥å·å’Œå§“åï¼ˆå¦‚æœæœ‰ï¼‰
      const firstLoc = locations[0];
      const employeeId = firstLoc.employee_id || '';
      const employeeName = firstLoc.employee_name || '';
      const adjustment = firstLoc.adjustment || '';
      
      // ä½¿ç”¨drawDistrictMapForEmployeeçš„é€»è¾‘æ¥ç»˜åˆ¶
      await drawDistrictMapForEmployee(employeeId, employeeName, groups, adjustment);
      
    } catch (e) {
      console.error('ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
      showError('ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¤±è´¥: ' + e.message);
    }
  }

    function colorByIndex(i, total) {
      return '#2196F3';
    }

    function createNumberMarker(point, number, total) {
      const markerContent = document.createElement('div');
      const bgColor = colorByIndex(number - 1, total);
      markerContent.style.cssText = `
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background: ${bgColor};
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        border: 3px solid white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        position: absolute;
        z-index: ${20000 + number};
        pointer-events: none;
        cursor: pointer;
      `;
      markerContent.innerHTML = String(number);
      markerContent.setAttribute('data-marker-number', number);

      const icon = new BMap.Icon(
        "data:image/svg+xml;base64," + btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="1" height="1"></svg>`),
        new BMap.Size(1, 1)
      );

      const marker = new BMap.Marker(point, {
        icon,
        offset: new BMap.Size(0, 0),
        enableDragging: false
      });
      marker.setLabel(new BMap.Label('', { offset: new BMap.Size(-9999, -9999) }));

      function NumberMarkerOverlay(point, content, number) {
        this._point = point;
        this._content = content;
        this._number = number;  // ä¿å­˜numberå€¼ï¼Œä¾›drawæ–¹æ³•ä½¿ç”¨
      }
      
      NumberMarkerOverlay.prototype = new BMap.Overlay();
      NumberMarkerOverlay.prototype.initialize = function(map) {
        this._map = map;
        const pane = map.getPanes().markerPane || map.getPanes().labelPane;
        if (pane) {
          pane.appendChild(this._content);
          this._pane = pane;
        }
        return this._content;
      };
      
      NumberMarkerOverlay.prototype.draw = function() {
        if (this._content && this._map) {
          try {
            const pixel = this._map.pointToOverlayPixel(this._point);
            this._content.style.position = 'absolute';
            this._content.style.left = (pixel.x - 17.5) + 'px';
            this._content.style.top = (pixel.y - 17.5) + 'px';
            this._content.style.display = 'flex';
            this._content.style.visibility = 'visible';
            // ä¸ºæ¯ä¸ªæ ‡è®°è®¾ç½®å”¯ä¸€çš„z-indexï¼Œç¡®ä¿æ‰€æœ‰æ•°å­—éƒ½èƒ½æ˜¾ç¤ºï¼ˆåé¢çš„æ•°å­—z-indexæ›´é«˜ï¼‰
            this._content.style.zIndex = (20000 + this._number).toString();
          } catch(e) {
            console.warn('ç»˜åˆ¶æ ‡è®°å¤±è´¥:', e);
          }
        }
      };
      
      const overlay = new NumberMarkerOverlay(point, markerContent, number);

      map.addOverlay(overlay);
      overlays.push(overlay);
      
      setTimeout(() => {
        if (overlay.draw) {
          overlay.draw();
        }
      }, 100);

      return marker;
    }

    async function drawPoints(locations) {
      clearMap();
      if (!map || !locations.length) return;
      
      // ä¿å­˜å½“å‰æ•°æ®ï¼Œç”¨äºç¼©æ”¾åé‡æ–°è®¡ç®—
      currentRouteData = { route: locations };
      currentLabelOffsets = [];
      
      // æ›´æ–°é®ç½©å±‚æ˜¾ç¤º
      updateMaskOverlay(locations);

      const pts = [];
      locations.forEach((loc, idx) => {
        const pt = new BMap.Point(loc.lng, loc.lat);
        pts.push(pt);

        const marker = createNumberMarker(pt, idx + 1, locations.length);
        map.addOverlay(marker);
        markers.push(marker);

        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        const infoHtml = `
          <div style="padding:10px;">
            <h4 style="margin:0 0 10px 0;color:#3366FF;">ç¬¬ ${idx + 1} ç«™ï¼š${loc.name}</h4>
            ${loc.remark ? `<p style="margin:5px 0;font-size:14px;color:#FF9800;font-weight:bold;">${loc.remark}</p>` : '<p style="margin:5px 0;font-size:12px;color:#999;">æ— å¤‡æ³¨</p>'}
            <p style="margin:5px 0;font-size:12px;color:#666;">ç»åº¦: ${loc.lng}</p>
            <p style="margin:5px 0;font-size:12px;color:#666;">çº¬åº¦: ${loc.lat}</p>
          </div>`;
        marker.addEventListener('click', () => {
          const win = new BMap.InfoWindow(infoHtml);
          map.openInfoWindow(win, pt);
        });
      });

      // è°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰ç½‘ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡
      if (pts.length > 0) {
        // å…ˆè®¾ç½®viewporté€‚åº”æ‰€æœ‰ç½‘ç‚¹
        map.setViewport(pts);
        
        // ç­‰å¾…è§†é‡è°ƒæ•´å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç½‘ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        
        let hasOverlap = false;
        for (const pt of pts) {
          // å°†åœ°å›¾åæ ‡è½¬æ¢ä¸ºå±å¹•åƒç´ åæ ‡
          const pixel = map.pointToPixel(pt);
          const screenX = pixel.x;
          const screenY = pixel.y;
          
          // æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶é¢æ¿åŒºåŸŸå†…
          if (screenX >= panelLeft && screenX <= panelRight && screenY >= panelTop) {
            hasOverlap = true;
            console.log(`[åœ°å›¾è§†å›¾] æ£€æµ‹åˆ°ç½‘ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡: (${screenX}, ${screenY})`);
            break;
          }
        }
        
        // åªæœ‰å½“æœ‰ç½‘ç‚¹è¢«é®æŒ¡æ—¶ï¼Œæ‰ç¼©å°åœ°å›¾
        if (hasOverlap) {
          const currentZoom = map.getZoom();
          if (currentZoom > 10) {
            // ç¼©å°1ä¸ªçº§åˆ«ï¼Œç¡®ä¿å·¦ä¾§ç½‘ç‚¹ä¸è¢«æ§åˆ¶é¢æ¿é®æŒ¡
            const adjustedZoom = Math.max(10, currentZoom - 1);
            map.setZoom(adjustedZoom);
            await new Promise(resolve => setTimeout(resolve, 500));
            console.log(`[åœ°å›¾è§†å›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${adjustedZoom}ï¼ˆé¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          }
        } else {
          console.log(`[åœ°å›¾è§†å›¾] æ‰€æœ‰ç½‘ç‚¹æœªè¢«æ§åˆ¶é¢æ¿é®æŒ¡ï¼Œä¿æŒå½“å‰ç¼©æ”¾çº§åˆ«: ${map.getZoom()}`);
        }
      }

      // ç­‰å¾…è§†å›¾è°ƒæ•´å®Œæˆåï¼Œæ·»åŠ æ ‡ç­¾
      await addLabelsToMarkers(locations, markers);
    }

    async function drawRouteResult(result, autoScreenshot = true) {
      console.log('drawRouteResult æ¥æ”¶åˆ°çš„æ•°æ®:', result);
      const { route, polyline, legs, total_distance, total_duration, farthest_points } = result;
      
      // ä¿å­˜å½“å‰è·¯çº¿æ•°æ®ï¼Œç”¨äºç¼©æ”¾åé‡æ–°è®¡ç®—
      currentRouteData = result;
      currentLabelOffsets = [];
      
      // æ›´æ–°é®ç½©å±‚æ˜¾ç¤ºï¼ˆä»å½“å‰è·¯çº¿ç»“æœä¸­è·å–é®ç½©å†…å®¹ï¼‰
      if (route && route.length > 0) {
        updateMaskOverlay(route);
      }

      clearMap();
      if (!map || !route.length) return;

      // ç¬¬ä¸€æ­¥ï¼šç»˜åˆ¶è·¯çº¿å’Œè·ç¦»æ ‡è®°ï¼ˆå…ˆç»˜åˆ¶åº•å±‚å…ƒç´ ï¼‰
      if (polyline && polyline.length) {
        const routePts = polyline.map(p => new BMap.Point(p[0], p[1]));
        const line = new BMap.Polyline(routePts, { strokeWeight: 4, strokeOpacity: 0.9, strokeColor: "#2196F3" });
        map.addOverlay(line);
        overlays.push(line);
        
        // ç»˜åˆ¶è·ç¦»æ ‡è®°ï¼ˆåº•å±‚ï¼Œz-index: 1000ï¼‰
        distanceLabels = [];  // æ¸…ç©ºä¹‹å‰çš„è·ç¦»æ ‡ç­¾å¼•ç”¨
        if (legs && legs.length > 0) {
          legs.forEach((leg) => {
            if (leg.mid_point && leg.mid_point.length === 2) {
              const midPoint = new BMap.Point(leg.mid_point[0], leg.mid_point[1]);
              const label = new BMap.Label(leg.distance_text, { offset: new BMap.Size(10, -10) });
              label.setStyle({
                background: 'rgba(255, 152, 0, 0.95)',
                color: 'white',
                border: '2px solid white',
                padding: '5px 10px',
                borderRadius: '5px',
                fontSize: '12px',
                fontWeight: 'bold',
                boxShadow: '0 2px 6px rgba(0,0,0,0.4)',
                whiteSpace: 'nowrap',
                zIndex: 1000  // è·ç¦»æ ‡è®°åœ¨åº•å±‚ï¼ˆä½äºç½‘ç‚¹åç§°æ ‡ç­¾çš„10000ï¼‰
              });
              label.setPosition(midPoint);
              map.addOverlay(label);
              overlays.push(label);
              distanceLabels.push(label);  // ä¿å­˜å¼•ç”¨ï¼Œç”¨äºæ§åˆ¶æ˜¾ç¤º/éšè—
            }
          });
        }
        
        // æ ¹æ®å¼€å…³çŠ¶æ€è®¾ç½®è·ç¦»æ ‡ç­¾çš„æ˜¾ç¤º
        toggleDistanceLabels();

        // è°ƒæ•´è§†é‡ä»¥é€‚åº”è·¯çº¿ï¼Œæ£€æŸ¥æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        map.setViewport(routePts);
        
        // ç­‰å¾…è§†é‡è°ƒæ•´å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è·¯çº¿ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        
        let hasOverlap = false;
        for (const pt of routePts) {
          // å°†åœ°å›¾åæ ‡è½¬æ¢ä¸ºå±å¹•åƒç´ åæ ‡
          const pixel = map.pointToPixel(pt);
          const screenX = pixel.x;
          const screenY = pixel.y;
          
          // æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶é¢æ¿åŒºåŸŸå†…
          if (screenX >= panelLeft && screenX <= panelRight && screenY >= panelTop) {
            hasOverlap = true;
            console.log(`[åœ°å›¾è§†å›¾] æ£€æµ‹åˆ°è·¯çº¿ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡: (${screenX}, ${screenY})`);
            break;
          }
        }
        
        // åªæœ‰å½“æœ‰è·¯çº¿ç‚¹è¢«é®æŒ¡æ—¶ï¼Œæ‰ç¼©å°åœ°å›¾
        if (hasOverlap) {
          const currentZoom = map.getZoom();
          if (currentZoom > 10) {
            // ç¼©å°1ä¸ªçº§åˆ«ï¼Œç¡®ä¿å·¦ä¾§å†…å®¹ä¸è¢«æ§åˆ¶é¢æ¿é®æŒ¡
            const adjustedZoom = Math.max(10, currentZoom - 1);
            map.setZoom(adjustedZoom);
            console.log(`[åœ°å›¾è§†å›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${adjustedZoom}ï¼ˆé¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          }
        } else {
          console.log(`[åœ°å›¾è§†å›¾] æ‰€æœ‰è·¯çº¿ç‚¹æœªè¢«æ§åˆ¶é¢æ¿é®æŒ¡ï¼Œä¿æŒå½“å‰ç¼©æ”¾çº§åˆ«: ${map.getZoom()}`);
        }
      }

      // ç¬¬äºŒæ­¥ï¼šå…ˆåªç»˜åˆ¶æ ‡è®°ç‚¹ï¼ˆåœ†åœˆï¼‰ï¼Œä¸æ·»åŠ æ ‡ç­¾
      const pts = [];
      route.forEach((loc, idx) => {
        const pt = new BMap.Point(loc.lng, loc.lat);
        pts.push(pt);

        const marker = createNumberMarker(pt, idx + 1, route.length);
        map.addOverlay(marker);
        markers.push(marker);

        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        const infoHtml = `
          <div style="padding:10px;">
            <h4 style="margin:0 0 10px 0;color:#3366FF;">ç¬¬ ${idx + 1} ç«™ï¼š${loc.name}</h4>
            ${loc.remark ? `<p style="margin:5px 0;font-size:14px;color:#FF9800;font-weight:bold;">${loc.remark}</p>` : '<p style="margin:5px 0;font-size:12px;color:#999;">æ— å¤‡æ³¨</p>'}
            <p style="margin:5px 0;font-size:12px;color:#666;">ç»åº¦: ${loc.lng}</p>
            <p style="margin:5px 0;font-size:12px;color:#666;">çº¬åº¦: ${loc.lat}</p>
          </div>`;
        marker.addEventListener('click', () => {
          const win = new BMap.InfoWindow(infoHtml);
          map.openInfoWindow(win, pt);
        });
      });

      // å¦‚æœæ²¡æœ‰è·¯çº¿ï¼Œè°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰ç½‘ç‚¹
      if (!polyline || !polyline.length) {
        // è°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰ç½‘ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        map.setViewport(pts);
        
        // ç­‰å¾…è§†é‡è°ƒæ•´å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç½‘ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        
        let hasOverlap = false;
        for (const pt of pts) {
          // å°†åœ°å›¾åæ ‡è½¬æ¢ä¸ºå±å¹•åƒç´ åæ ‡
          const pixel = map.pointToPixel(pt);
          const screenX = pixel.x;
          const screenY = pixel.y;
          
          // æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶é¢æ¿åŒºåŸŸå†…
          if (screenX >= panelLeft && screenX <= panelRight && screenY >= panelTop) {
            hasOverlap = true;
            console.log(`[åœ°å›¾è§†å›¾] æ£€æµ‹åˆ°ç½‘ç‚¹è¢«æ§åˆ¶é¢æ¿é®æŒ¡: (${screenX}, ${screenY})`);
            break;
          }
        }
        
        // åªæœ‰å½“æœ‰ç½‘ç‚¹è¢«é®æŒ¡æ—¶ï¼Œæ‰ç¼©å°åœ°å›¾
        if (hasOverlap) {
          const currentZoom = map.getZoom();
          if (currentZoom > 10) {
            // ç¼©å°1ä¸ªçº§åˆ«ï¼Œç¡®ä¿å·¦ä¾§ç½‘ç‚¹ä¸è¢«æ§åˆ¶é¢æ¿é®æŒ¡
            const adjustedZoom = Math.max(10, currentZoom - 1);
            map.setZoom(adjustedZoom);
            await new Promise(resolve => setTimeout(resolve, 500));
            console.log(`[åœ°å›¾è§†å›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${adjustedZoom}ï¼ˆé¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          }
        } else {
          console.log(`[åœ°å›¾è§†å›¾] æ‰€æœ‰ç½‘ç‚¹æœªè¢«æ§åˆ¶é¢æ¿é®æŒ¡ï¼Œä¿æŒå½“å‰ç¼©æ”¾çº§åˆ«: ${map.getZoom()}`);
        }
      }

      // ç¬¬ä¸‰æ­¥ï¼šç­‰å¾…è§†å›¾è°ƒæ•´å®Œæˆåï¼Œæ·»åŠ æ ‡ç­¾
      await addLabelsToMarkers(route, markers);

      // å¼ºåˆ¶åˆ·æ–°æ ‡è®°ç‚¹æ ‡ç­¾ï¼Œç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚ï¼ˆåœ¨æ‰€æœ‰è·ç¦»æ ‡ç­¾ä¸Šæ–¹ï¼‰
      setTimeout(() => {
        markers.forEach((marker, idx) => {
          try {
            const currentLabel = marker.getLabel();
            if (currentLabel) {
              // é‡æ–°è®¾ç½®æ ‡ç­¾æ ·å¼ï¼Œç¡®ä¿zIndexç”Ÿæ•ˆ
              const style = currentLabel.getStyle();
              if (style) {
                style.zIndex = 10000;  // æœ€é«˜ä¼˜å…ˆçº§
                currentLabel.setStyle(style);
              }
              // é€šè¿‡DOMç›´æ¥è®¾ç½®z-index
              try {
                const labelElement = currentLabel.getContent();
                if (labelElement && labelElement.style) {
                  labelElement.style.zIndex = '10000';
                  labelElement.style.position = 'relative';
                }
              } catch(e) {
                // å¿½ç•¥DOMæ“ä½œé”™è¯¯
              }
              // é‡æ–°å¯ç”¨æ‹–æ‹½åŠŸèƒ½ï¼ˆå¦‚æœæ˜¯æ‰‹åŠ¨è¾“å…¥ï¼Œå¼ºåˆ¶é‡æ–°ç»‘å®šï¼‰
              if (currentRouteData && currentRouteData.route) {
                enableLabelDragging(marker, currentLabel, idx, currentRouteData.route, true);
              }
            }
          } catch(e) {
            // å¿½ç•¥é”™è¯¯
          }
        });
        // é‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®ï¼Œé¿å…é®æŒ¡
        updateLabelPositions();
      }, 200);

      // âœ… ç¬¬ä¸‰æ­¥ï¼šå»¶è¿Ÿç»˜åˆ¶"æœ€è¿œç›´çº¿"ï¼ˆç¡®ä¿åœ¨è·¯çº¿ç»˜åˆ¶å®Œæˆåï¼‰
      setTimeout(() => {
        drawFarthestLine(farthest_points);
      }, 100);

      // å¼ºåˆ¶é‡ç»˜è‡ªå®šä¹‰ overlayï¼ˆåœ†åœˆæ•°å­—ï¼‰
      setTimeout(() => {
        overlays.forEach(overlay => {
          if (overlay && overlay.draw) {
            try { overlay.draw(); } catch(e) {}
          }
        });
      }, 200);

      // ä¿å­˜å½“å‰è·¯çº¿ç»“æœ
      currentRouteResult = result;
      
      // è·å–å½“å‰ç®€ç‰ˆæ¨¡å¼çŠ¶æ€
      routeSimpleMode = document.getElementById('toggleRouteSimple')?.checked ?? true;
      
      // æ›´æ–°è·¯çº¿è¯¦æƒ…æ˜¾ç¤º
      updateRouteInfo(result, routeSimpleMode);
      
      // è‡ªåŠ¨æ»šåŠ¨æ§åˆ¶é¢æ¿åˆ°åº•éƒ¨å’Œå³éƒ¨
      setTimeout(() => {
        const panel = document.getElementById('control-panel');
        if (panel) {
          panel.scrollTo({
            top: panel.scrollHeight,
            left: panel.scrollWidth,
            behavior: 'smooth'
          });
          
          // åªæœ‰åœ¨ autoScreenshot ä¸º true æ—¶æ‰è‡ªåŠ¨æˆªå›¾ï¼ˆæ‰¹é‡å¤„ç†æ—¶ä¸ä¼šè‡ªåŠ¨æˆªå›¾ï¼Œé¿å…é‡å¤ï¼‰
          if (autoScreenshot) {
            // æ»šåŠ¨å®Œæˆåï¼Œå»¶è¿Ÿæ‰§è¡Œæˆªå›¾ï¼ˆç¡®ä¿å†…å®¹å®Œå…¨æ˜¾ç¤ºï¼‰
            // ä¼ å…¥å½“å‰è·¯çº¿çš„routeä½œä¸ºlocationsï¼Œä»¥è·å–å¯¹åº”çš„é®ç½©å†…å®¹
            const routeForMask = result.route || [];
            setTimeout(() => {
              captureScreenshot('', '', '', '', routeForMask);
            }, 1500);  // ç­‰å¾…æ»šåŠ¨åŠ¨ç”»å®Œæˆåå†æˆªå›¾
          }
        }
      }, 100);
    }

    function formatMeters(m) {
      if (m >= 1000) return (m / 1000).toFixed(2) + " å…¬é‡Œ";
      return Math.round(m) + " ç±³";
    }
    function formatSeconds(s) {
      s = Math.round(s);
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      if (h > 0) return `${h}å°æ—¶${m}åˆ†é’Ÿ`;
      return `${m}åˆ†é’Ÿ`;
    }

    // æŒ‰ç½‘ç»„åˆ†ç»„å¤„ç†
    // æŒ‰å·¥å·åˆ†ç»„
    function groupLocationsByEmployee(locations) {
      const employees = {};
      locations.forEach(loc => {
        const employeeId = loc.employee_id || '';
        if (employeeId && employeeId.trim()) {
          if (!employees[employeeId]) {
            employees[employeeId] = {
              employee_id: employeeId,
              employee_name: loc.employee_name || '',
              groups: {}
            };
          }
          const group = loc.group || 'æœªåˆ†ç»„';
          if (!employees[employeeId].groups[group]) {
            employees[employeeId].groups[group] = [];
          }
          employees[employeeId].groups[group].push(loc);
        }
      });
      return employees;
    }

    function groupLocationsByGroup(locations) {
      const groups = {};
      for (const loc of locations) {
        const group = (loc.group || '').trim();
        const groupKey = group || 'æœªåˆ†ç»„';
        if (!groups[groupKey]) {
          groups[groupKey] = [];
        }
        groups[groupKey].push(loc);
      }
      return groups;
    }

    async function calculateRoute() {
      const locations = currentLocations.length ? currentLocations : parseLocationData();
      if (locations.length < 2) return showError('è‡³å°‘éœ€è¦2ä¸ªç½‘ç‚¹ï¼');

      // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å·¥å·ï¼Œå¦‚æœæœ‰å·¥å·åˆ™æŒ‰å·¥å·åˆ†ç»„å¤„ç†
      const employees = groupLocationsByEmployee(locations);
      if (employees && Object.keys(employees).length > 0) {
        excelEmployees = employees;
        startBatchProcessByEmployee();
        return;
      }

      // æŒ‰ç½‘ç»„åˆ†ç»„
      const groups = groupLocationsByGroup(locations);
      const groupKeys = Object.keys(groups);
      
      // å¦‚æœæœ‰å¤šä¸ªç½‘ç»„ï¼Œè‡ªåŠ¨æŒ‰ç»„ä¾æ¬¡å¤„ç†
      if (groupKeys.length > 1 || (groupKeys.length === 1 && groupKeys[0] !== 'æœªåˆ†ç»„')) {
        excelGroups = groups;
        startBatchProcess();
        return;
      }

      // å•ä¸ªç»„æˆ–æ— åˆ†ç»„ï¼Œç›´æ¥å¤„ç†
      // åˆ¤æ–­æ˜¯å¦æ˜¯æ‰‹åŠ¨è¾“å…¥ï¼ˆcurrentLocationsä¸ºç©ºï¼Œè¯´æ˜æ˜¯ä»æ–‡æœ¬æ¡†è§£æçš„ï¼‰
      const isManualInput = currentLocations.length === 0;
      showLoading('ğŸ“ æ­£åœ¨æŒ‰åºè®¡ç®—é©¾è½¦è·¯çº¿...');
      try {
        const resp = await fetch('/calculate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ locations })
        });
        const data = await resp.json();
        if (data.error) return showError(data.error);
        // æ‰‹åŠ¨è¾“å…¥æ—¶ä¸è‡ªåŠ¨æˆªå›¾
        await drawRouteResult(data, !isManualInput);
      } catch (e) {
        showError('è®¡ç®—å¤±è´¥ï¼š' + e);
      }
    }

    async function optimizeRoute() {
      const locations = currentLocations.length ? currentLocations : parseLocationData();
      if (locations.length < 2) return showError('è‡³å°‘éœ€è¦2ä¸ªç½‘ç‚¹ï¼');

      // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å·¥å·ï¼Œå¦‚æœæœ‰å·¥å·åˆ™æŒ‰å·¥å·åˆ†ç»„å¤„ç†
      const employees = groupLocationsByEmployee(locations);
      if (employees && Object.keys(employees).length > 0) {
        excelEmployees = employees;
        startBatchProcessByEmployee();
        return;
      }

      // æŒ‰ç½‘ç»„åˆ†ç»„
      const groups = groupLocationsByGroup(locations);
      const groupKeys = Object.keys(groups);
      
      // å¦‚æœæœ‰å¤šä¸ªç½‘ç»„ï¼Œè‡ªåŠ¨æŒ‰ç»„ä¾æ¬¡å¤„ç†
      if (groupKeys.length > 1 || (groupKeys.length === 1 && groupKeys[0] !== 'æœªåˆ†ç»„')) {
        excelGroups = groups;
        startBatchProcess();
        return;
      }

      // å•ä¸ªç»„æˆ–æ— åˆ†ç»„ï¼Œç›´æ¥å¤„ç†
      // åˆ¤æ–­æ˜¯å¦æ˜¯æ‰‹åŠ¨è¾“å…¥ï¼ˆcurrentLocationsä¸ºç©ºï¼Œè¯´æ˜æ˜¯ä»æ–‡æœ¬æ¡†è§£æçš„ï¼‰
      const isManualInput = currentLocations.length === 0;
      const startName = document.getElementById('startPoint').value.trim() || null;
      showLoading('ğŸ”„ æ­£åœ¨ä¼˜åŒ–é¡ºåºå¹¶è§„åˆ’é©¾è½¦è·¯çº¿...');

      try {
        const resp = await fetch('/optimize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ locations, start_name: startName })
        });
        const data = await resp.json();
        if (data.error) return showError(data.error);
        // æ‰‹åŠ¨è¾“å…¥æ—¶ä¸è‡ªåŠ¨æˆªå›¾
        await drawRouteResult(data, !isManualInput);
      } catch (e) {
        showError('ä¼˜åŒ–å¤±è´¥ï¼š' + e);
      }
    }

    // æ‰‹åŠ¨æˆªå›¾åŠŸèƒ½ï¼ˆå¸¦æ»šåŠ¨æ§åˆ¶é¢æ¿ï¼‰
    async function manualCaptureScreenshot() {
      // å…ˆæ»šåŠ¨æ§åˆ¶é¢æ¿åˆ°åº•éƒ¨ï¼Œç¡®ä¿æ˜¾ç¤ºæœ€æ–°å†…å®¹
      const panel = document.getElementById('control-panel');
      
      // è·å–å½“å‰æ˜¾ç¤ºçš„è·¯çº¿æ•°æ®ï¼ˆå¦‚æœæœ‰ï¼‰æˆ–å½“å‰ç½‘ç‚¹æ•°æ®
      let locationsForMask = null;
      if (currentRouteResult && currentRouteResult.route) {
        // å¦‚æœæœ‰å½“å‰è·¯çº¿ç»“æœï¼Œä½¿ç”¨è·¯çº¿çš„ç½‘ç‚¹æ•°æ®
        locationsForMask = currentRouteResult.route;
      } else {
        // å¦åˆ™ä½¿ç”¨å½“å‰ç½‘ç‚¹æ•°æ®
        locationsForMask = currentLocations.length ? currentLocations : parseLocationData();
      }
      
      if (panel) {
        // æ»šåŠ¨æ§åˆ¶é¢æ¿åˆ°åº•éƒ¨å’Œå³éƒ¨ï¼Œç¡®ä¿æ˜¾ç¤ºæœ€æ–°å†…å®¹
        panel.scrollTo({
          top: panel.scrollHeight,
          left: panel.scrollWidth,
          behavior: 'smooth'
        });
        // ç­‰å¾…æ»šåŠ¨å®Œæˆåå†æˆªå›¾ï¼Œä¼ å…¥å½“å‰æ•°æ®çš„locationsä»¥è·å–å¯¹åº”çš„é®ç½©å†…å®¹
        setTimeout(() => {
          captureScreenshot('', '', '', '', locationsForMask);
        }, 800);
      } else {
        captureScreenshot('', '', '', '', locationsForMask);
      }
    }

    // æ›´æ–°é®ç½©å±‚æ˜¾ç¤ºï¼ˆä»ç½‘ç‚¹æ•°æ®ä¸­è¯»å–é®ç½©å†…å®¹ï¼‰
    function updateMaskOverlay(locations) {
      const maskOverlay = document.getElementById('mask-overlay');
      if (!maskOverlay) return;
      
      // æŸ¥æ‰¾æœ€åä¸€ä¸ªæœ‰é®ç½©å†…å®¹çš„ç½‘ç‚¹
      let maskText = '';
      for (let i = locations.length - 1; i >= 0; i--) {
        if (locations[i].mask && locations[i].mask.trim()) {
          maskText = locations[i].mask.trim();
          break;
        }
      }
      
      // æ›´æ–°é®ç½©å±‚ï¼ˆæ‚¬æµ®åœ¨æ§åˆ¶é¢æ¿ä¸Šæ–¹ï¼‰
      if (maskText) {
        maskOverlay.textContent = maskText;
        maskOverlay.style.display = 'block';
        // è°ƒæ•´æ§åˆ¶é¢æ¿ä½ç½®ï¼Œé¿å…è¢«é®ç½©å±‚é®æŒ¡
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          const maskHeight = maskOverlay.offsetHeight || 50;
          controlPanel.style.top = (20 + maskHeight + 10) + 'px';
        }
      } else {
        maskOverlay.style.display = 'none';
        maskOverlay.textContent = '';
        // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          controlPanel.style.top = '20px';
        }
      }
    }

    // æˆªå›¾åŠŸèƒ½
    async function captureScreenshot(groupName = '', employeeId = '', employeeName = '', adjustment = '', locationsForMask = null) {
      // è·å–å½“å‰çš„UIçŠ¶æ€ï¼ˆå¤é€‰æ¡†çŠ¶æ€ï¼‰
      const uiState = {
        showFarthestLine: document.getElementById('toggleFarthest')?.checked ?? true,
        showDistanceLabels: document.getElementById('toggleDistanceLabels')?.checked ?? false,
        showRouteSimple: document.getElementById('toggleRouteSimple')?.checked ?? true
      };
      
      // åˆ¤æ–­æ˜¯å¦ä¸ºè¡Œæ”¿åŒºå›¾
      const isDistrictMap = groupName === '__DISTRICT_MAP__';
      const isDistrictMapOnly = groupName === '__DISTRICT_MAP_ONLY__';
      
      // è·å–é®ç½©å†…å®¹
      let maskText = '';
      if (isDistrictMap) {
        // å¦‚æœæ˜¯è¡Œæ”¿åŒºå›¾ï¼Œæ˜¾ç¤º"å·¥å·-å§“å-è¡Œæ”¿åŒºå›¾"
        if (employeeId && employeeId.trim() && employeeName && employeeName.trim()) {
          maskText = `${employeeId}-${employeeName}-è¡Œæ”¿åŒºå›¾`;
        } else {
          maskText = 'è¡Œæ”¿åŒºå›¾';
        }
      } else if (isDistrictMapOnly) {
        // å¦‚æœæ˜¯ä»…è¡Œæ”¿åŒºå›¾ï¼Œæ˜¾ç¤º"ä»…è¡Œæ”¿åŒºå›¾"
        maskText = 'ä»…è¡Œæ”¿åŒºå›¾';
      } else {
        // æ™®é€šç½‘ç»„å›¾ï¼Œä¼˜å…ˆä»ä¼ å…¥çš„locationsä¸­è·å–é®ç½©å†…å®¹ï¼ˆå½“å‰ç»˜åˆ¶çš„ç½‘ç»„æ•°æ®ï¼‰
        let locationsToCheck = locationsForMask;
        if (!locationsToCheck || locationsToCheck.length === 0) {
          // å¦‚æœæ²¡æœ‰ä¼ å…¥locationsï¼Œåˆ™ä½¿ç”¨å…¨å±€çš„currentLocationsæˆ–è§£æè¾“å…¥
          locationsToCheck = currentLocations.length ? currentLocations : parseLocationData();
        }
        
        // ä»locationsä¸­æŸ¥æ‰¾æœ€åä¸€ä¸ªæœ‰é®ç½©å†…å®¹çš„ç½‘ç‚¹
        for (let i = locationsToCheck.length - 1; i >= 0; i--) {
          if (locationsToCheck[i].mask && locationsToCheck[i].mask.trim()) {
            maskText = locationsToCheck[i].mask.trim();
            break;
          }
        }
      }
      
      // ç¡®ä¿é®ç½©å±‚æ˜¾ç¤ºï¼ˆå¦‚æœæœ‰é®ç½©å†…å®¹ï¼‰
      if (maskText) {
        // ç›´æ¥è®¾ç½®é®ç½©å†…å®¹
        const maskOverlay = document.getElementById('mask-overlay');
        if (maskOverlay) {
          maskOverlay.textContent = maskText;
          maskOverlay.style.display = 'block';
          // è°ƒæ•´æ§åˆ¶é¢æ¿ä½ç½®ï¼Œé¿å…è¢«é®ç½©å±‚é®æŒ¡
          const controlPanel = document.getElementById('control-panel');
          if (controlPanel) {
            const maskHeight = maskOverlay.offsetHeight || 50;
            controlPanel.style.top = (20 + maskHeight + 10) + 'px';
          }
        }
        // ç­‰å¾…é®ç½©å±‚æ˜¾ç¤ºå®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
      } else {
        // å¦‚æœæ²¡æœ‰é®ç½©å†…å®¹ï¼Œéšè—é®ç½©å±‚
        const maskOverlay = document.getElementById('mask-overlay');
        if (maskOverlay) {
          maskOverlay.style.display = 'none';
        }
        // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          controlPanel.style.top = '20px';
        }
      }
      const displayName = isDistrictMap ? 'è¡Œæ”¿åŒºå›¾' : (isDistrictMapOnly ? 'ä»…è¡Œæ”¿åŒºå›¾' : (groupName ? 'ç½‘ç»„ ' + groupName : ''));
      
      // æ˜¾ç¤ºæˆªå›¾æç¤ºåœ¨çŠ¶æ€åŒºåŸŸï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
      updateStatus(`ğŸ“¸ æ­£åœ¨æˆªå›¾${displayName}...`, 'loading');
      
      // è®¾ç½®è¶…æ—¶å¤„ç†ï¼ˆ30ç§’è¶…æ—¶ï¼‰
      const timeoutId = setTimeout(() => {
        updateStatus('âŒ æˆªå›¾è¶…æ—¶ï¼ˆ30ç§’ï¼‰ï¼Œè¯·æ£€æŸ¥Edgeæµè§ˆå™¨å’Œç½‘ç»œè¿æ¥', 'error');
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
      }, 30000);
      
      try {
        const controller = new AbortController();
        const timeoutSignal = setTimeout(() => controller.abort(), 30000);
        
        const resp = await fetch('/capture_screenshot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ui_state: uiState,
            group_name: groupName,
            employee_id: employeeId,
            employee_name: employeeName,
            adjustment: adjustment,
            mask_text: maskText
          }),
          signal: controller.signal
        });
        
        clearTimeout(timeoutSignal);
        clearTimeout(timeoutId);
        
        const data = await resp.json();
        
        // æ›´æ–°çŠ¶æ€åŒºåŸŸï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
        if (data.error) {
          updateStatus(`âŒ æˆªå›¾å¤±è´¥ï¼š${data.error}`, 'error');
          // æˆªå›¾å®Œæˆåï¼Œéšè—é®ç½©å±‚
          const maskOverlay = document.getElementById('mask-overlay');
          if (maskOverlay) {
            maskOverlay.style.display = 'none';
            maskOverlay.textContent = '';
          }
          // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
          const controlPanel = document.getElementById('control-panel');
          if (controlPanel) {
            controlPanel.style.top = '20px';
          }
          // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
          setTimeout(() => {
            updateStatus('å°±ç»ª', 'ready');
          }, 10000);
          return;
        }
        
        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        updateStatus(`âœ… æˆªå›¾å·²ä¿å­˜: ${data.filename}`, 'success');
        
        // æˆªå›¾å®Œæˆåï¼Œéšè—é®ç½©å±‚
        const maskOverlay = document.getElementById('mask-overlay');
        if (maskOverlay) {
          maskOverlay.style.display = 'none';
          maskOverlay.textContent = '';
        }
        // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          controlPanel.style.top = '20px';
        }
        
        // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
        
        console.log('æˆªå›¾ä¿å­˜æˆåŠŸ:', data.filepath);
      } catch (e) {
        clearTimeout(timeoutId);
        
        // æ›´æ–°çŠ¶æ€åŒºåŸŸæ˜¾ç¤ºé”™è¯¯ï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
        if (e.name === 'AbortError') {
          updateStatus('âŒ æˆªå›¾è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥Edgeæµè§ˆå™¨å’Œç½‘ç»œè¿æ¥', 'error');
        } else {
          updateStatus(`âŒ æˆªå›¾å¤±è´¥ï¼š${e.message || String(e)}`, 'error');
        }
        // æˆªå›¾å®Œæˆåï¼Œéšè—é®ç½©å±‚
        const maskOverlay = document.getElementById('mask-overlay');
        if (maskOverlay) {
          maskOverlay.style.display = 'none';
          maskOverlay.textContent = '';
        }
        // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          controlPanel.style.top = '20px';
        }
        // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
        console.error('æˆªå›¾è¯·æ±‚å¤±è´¥:', e);
      }
    }
  </script>
</body>
</html>