<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç½‘ç‚¹è·¯çº¿ä¼˜åŒ–ç³»ç»Ÿï¼ˆç™¾åº¦åœ°å›¾ç‰ˆï¼‰</title>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: "Microsoft YaHei", "PingFang SC", Arial, sans-serif; }
    #container { width: 100%; height: 100vh; }
    #control-panel {
      position: absolute; top: 20px; left: 20px; background: white;
      padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      max-width: 380px; z-index: 1000; max-height: 85vh; overflow-y: auto; overflow-x: auto;
    }
    h2 { margin-bottom: 15px; color: #333; font-size: 18px; }
    .input-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; font-size: 13px; }
    textarea, input[type="text"], input[type="file"] {
      width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;
      font-size: 12px; font-family: inherit;
    }
    textarea { resize: vertical; }
    input[type="file"] { padding: 8px; }
    .btn {
      padding: 10px 20px; margin: 5px 5px 5px 0; border: none; border-radius: 5px;
      cursor: pointer; font-size: 13px; font-weight: bold; transition: all 0.3s;
    }
    .btn-primary { background: #3366FF; color: white; }
    .btn-primary:hover { background: #2850CC; }
    .btn-success { background: #4CAF50; color: white; }
    .btn-success:hover { background: #388E3C; }
    .btn-clear { background: #9E9E9E; color: white; }
    .btn-clear:hover { background: #757575; }
    .btn-screenshot { background: #FF9800; color: white; }
    .btn-screenshot:hover { background: #F57C00; }
    @keyframes pulse {
      0% { transform: scale(1); box-shadow: 0 0 5px #FF9800; }
      50% { transform: scale(1.05); box-shadow: 0 0 20px #FF9800; }
      100% { transform: scale(1); box-shadow: 0 0 5px #FF9800; }
    }
    #route-info { margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 5px; font-size: 13px; }
    .route-item { padding: 8px; margin: 5px 0; background: white; border-left: 4px solid #3366FF; border-radius: 3px; }
    .distance-info { color: #FF5722; font-weight: bold; }
    .loading { text-align: center; color: #666; padding: 10px; }
    .error-box {
      background: #FFEBEE; padding: 10px; border-radius: 5px; margin-top: 10px;
      font-size: 12px; color: #C62828; border-left: 4px solid #F44336;
    }
    .tabs { display: flex; margin-bottom: 15px; border-bottom: 2px solid #ddd; }
    .tab {
      padding: 10px 20px; cursor: pointer; border: none; background: none;
      font-size: 14px; color: #666; transition: all 0.3s;
    }
    .tab.active { color: #3366FF; border-bottom: 3px solid #3366FF; margin-bottom: -2px; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .excel-template {
      background: #E3F2FD; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 12px;
    }
    .excel-template code { background: white; padding: 2px 6px; border-radius: 3px; font-family: monospace; }

    /* marker åœ†ç‚¹æ ·å¼ï¼ˆç”¨DOMå åŠ ï¼Œä¿æŒä½ åŸå…ˆâ€œç¼–å·åœ†ç‚¹â€é£æ ¼ï¼‰ */
    .num-marker {
      width: 35px; height: 35px; border-radius: 50%;
      color: white; display: flex; align-items: center; justify-content: center;
      font-weight: bold; font-size: 16px;
      border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }

    /* è‡ªå®šä¹‰æ¨¡æ€å¯¹è¯æ¡†æ ·å¼ */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .modal-dialog {
      background: white;
      border-radius: 12px;
      padding: 30px 40px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      min-width: 320px;
      text-align: center;
    }

    .modal-title {
      font-size: 18px;
      font-weight: bold;
      color: #333;
      margin-bottom: 25px;
    }

    .modal-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
    }

    .modal-btn {
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 120px;
    }

    .modal-btn-detail {
      background: #F44336;
      color: white;
    }

    .modal-btn-detail:hover {
      background: #D32F2F;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
    }

    .modal-btn-simple {
      background: #4CAF50;
      color: white;
    }

    .modal-btn-simple:hover {
      background: #388E3C;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }
  </style>
</head>

<body>
  <!-- é®ç½©å±‚ï¼ˆæ‚¬æµ®åœ¨æ§åˆ¶é¢æ¿ä¸Šæ–¹ï¼‰ -->
  <div id="mask-overlay" style="
    position: absolute;
    top: 20px;
    left: 20px;
    width: 380px;
    background: rgba(255, 255, 255, 0.95);
    padding: 15px 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 1001;
    display: none;
    font-size: 18px;
    font-weight: bold;
    color: #333;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 200px;
    overflow-y: auto;
    border-radius: 10px;
    border: 2px solid #3366FF;
  "></div>

  <div id="control-panel">
    <h2>ğŸ“ ç½‘ç‚¹è·¯çº¿ä¼˜åŒ–ç³»ç»Ÿï¼ˆç™¾åº¦åœ°å›¾ï¼‰</h2>

    <div class="tabs">
      <button class="tab active" onclick="switchTab('excel')">ğŸ“Š Excelå¯¼å…¥</button>
      <button class="tab" onclick="switchTab('manual')">âœï¸ æ‰‹åŠ¨è¾“å…¥</button>
    </div>

    <div id="excel-tab" class="tab-content active">
      <div class="excel-template">
        <strong>ğŸ“‹ Excelæ ¼å¼è¦æ±‚ï¼š</strong><br>
        åˆ—åï¼š<code>ç»åº¦</code> <code>çº¬åº¦</code> <code>ç½‘ç‚¹åç§°</code> <code>å¤‡æ³¨(å¯é€‰)</code> <code>ç½‘ç»„(å¯é€‰)</code> <code>å·¥å·(å¯é€‰)</code> <code>å§“å(å¯é€‰)</code> <code>å¿åŒº(å¯é€‰)</code> <code>è°ƒæ•´(å¯é€‰)</code> <code>é®ç½©(å¯é€‰)</code>
      </div>

      <div class="input-group">
        <label>é€‰æ‹©Excelæ–‡ä»¶</label>
        <input type="file" id="excelFile" accept=".xlsx,.xls" onchange="handleExcelUpload()">
      </div>
      
      <div class="input-group" id="batchProcessSection" style="display: none;">
        <button class="btn btn-success" onclick="startBatchProcess()" style="width: 100%;">
          ğŸ”„ æ‰¹é‡å¤„ç†ï¼ˆæŒ‰ç½‘ç»„ï¼‰
        </button>
      </div>
    </div>

    <div id="manual-tab" class="tab-content">
      <div class="input-group">
        <label>ç½‘ç‚¹æ•°æ®ï¼ˆæ ¼å¼ï¼šç»åº¦,çº¬åº¦,åç§°,å¤‡æ³¨å¯é€‰,ç½‘ç»„å¯é€‰,å·¥å·å¯é€‰,å§“åå¯é€‰,å¿åŒºå¯é€‰,è°ƒæ•´å¯é€‰,é®ç½©å¯é€‰ï¼‰</label>
        <textarea id="locationInput" rows="8"
          placeholder="116.397428,39.90923,åŒ—äº¬è¥ä¸šéƒ¨,å¤‡æ³¨A
116.404,39.915,æœé˜³æ”¯è¡Œ
116.326,39.989,æµ·æ·€æ”¯è¡Œ,é‡ç‚¹æ‹œè®¿">116.397428,39.90923,åŒ—äº¬è¥ä¸šéƒ¨,èµ·ç‚¹
116.404,39.915,æœé˜³æ”¯è¡Œ
116.326,39.989,æµ·æ·€æ”¯è¡Œ,é‡ç‚¹æ‹œè®¿
116.368,39.867,ä¸°å°æ”¯è¡Œ
116.481,39.990,é¡ºä¹‰æ”¯è¡Œ
        </textarea>
      </div>
    </div>

    <div class="input-group">
      <label>èµ·å§‹ç½‘ç‚¹ï¼ˆå¯é€‰ï¼šå¡«â€œç½‘ç‚¹åç§°â€åŒ¹é…ï¼‰</label>
      <input type="text" id="startPoint" placeholder="ç•™ç©ºåˆ™é»˜è®¤ä½¿ç”¨ç¬¬1è¡Œä½œä¸ºèµ·ç‚¹ï¼ˆä¼˜åŒ–æ—¶ä¹Ÿå¯è‡ªåŠ¨ï¼‰">
    </div>

    <div>
      <button class="btn btn-primary" onclick="optimizeRoute()">ğŸ”„ ä¼˜åŒ–è·¯çº¿</button>
      <button class="btn btn-success" onclick="calculateRoute()">ğŸ“ æŒ‰åºè®¡ç®—</button>
      <button class="btn btn-clear" onclick="clearMap()">ğŸ—‘ï¸ æ¸…é™¤</button>
    </div>

    <!-- æ‰‹åŠ¨è°ƒæ•´åæˆªå›¾ -->
    <div id="manual-screenshot-panel" style="margin-top: 10px; padding: 10px; background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); border-radius: 8px; border: 1px solid #90caf9;">
      <div style="font-size: 12px; color: #1565c0; margin-bottom: 8px; font-weight: bold;">
        ğŸ’¡ æ‰‹åŠ¨è°ƒæ•´æ ‡ç­¾ä½ç½®
      </div>
      <div style="font-size: 11px; color: #666; margin-bottom: 8px; line-height: 1.5;">
        å¯æ‹–æ‹½è°ƒæ•´ï¼š<span style="color: #2196F3;">å¤‡æ³¨æ ‡ç­¾</span>ã€<span style="color: #FF9800;">è·ç¦»æ ‡ç­¾</span>
      </div>
      <button class="btn btn-screenshot" onclick="manualCaptureScreenshot()" style="width: 100%;">
        ğŸ“¸ æ‰‹åŠ¨è°ƒæ•´åæˆªå›¾
      </button>
    </div>

    <!-- çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸï¼ˆå›ºå®šä½ç½®ï¼Œæ˜¾ç¤ºè®¡ç®—è·¯çº¿ã€æˆªå›¾ç­‰çŠ¶æ€ï¼‰ -->
    <div id="status-info" style="margin-top: 10px; min-height: 40px; padding: 8px; background: #f5f5f5; border-radius: 5px; font-size: 12px; color: #666; text-align: center;">
      <div id="status-text">å°±ç»ª</div>
    </div>

    <!-- âœ… æœ€è¿œçº¿å¼€å…³ -->
    <div style="margin-top:10px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleFarthest" checked onchange="toggleFarthestLine()">
        æ˜¾ç¤ºæœ€è¿œä¸¤ç‚¹ç›´çº¿ï¼ˆç»¿è‰²ï¼‰
      </label>
    </div>

    <!-- âœ… è·ç¦»æ ‡ç­¾å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleDistanceLabels" onchange="toggleDistanceLabels()">
        æ˜¾ç¤ºè·¯çº¿è·ç¦»æ ‡ç­¾ï¼ˆé»„è‰²ï¼‰
      </label>
    </div>

    <!-- âœ… è·¯çº¿ç®€ç‰ˆå¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleRouteSimple" checked onchange="toggleRouteSimple()">
        è·¯çº¿ç®€ç‰ˆ
      </label>
    </div>

    <!-- âœ… è°ƒè¯•æ¨¡å¼å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#d32f2f;font-weight:bold;">
        <input type="checkbox" id="toggleDebugMode" onchange="toggleDebugMode()">
        ğŸ”§ è°ƒè¯•æ¨¡å¼ï¼ˆå…³é—­è‡ªåŠ¨æˆªå›¾ï¼‰
      </label>
    </div>

    <!-- âœ… è¡Œæ”¿åŒºå›¾å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleDistrictMap" checked onchange="toggleDistrictMap()">
        è¡Œæ”¿åŒºå›¾
      </label>
    </div>

    <!-- âœ… ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¼€å…³ -->
    <div style="margin-top:8px;">
      <label style="display:flex;align-items:center;gap:8px;font-size:13px;color:#555;font-weight:normal;">
        <input type="checkbox" id="toggleDistrictMapOnly" onchange="toggleDistrictMapOnly()">
        ä»…æˆªå–è¡Œæ”¿åŒºå›¾ï¼ˆè·³è¿‡ç½‘ç»„æˆªå›¾ï¼‰
      </label>
    </div>

    <div id="route-info"></div>
  </div>

  <div id="container"></div>

  <!-- é…ç½®æ–‡ä»¶ï¼šä¼˜å…ˆåŠ è½½config-custom.jsï¼Œå¦‚æœæ²¡æœ‰åˆ™åŠ è½½static/config.js -->
  <script>
    // æå‰å®šä¹‰ showError å‡½æ•°ï¼Œä¾›åŠ è½½è„šæœ¬ä½¿ç”¨
    function showError(message) {
      const routeInfo = document.getElementById('route-info');
      if (routeInfo) {
        routeInfo.innerHTML = '<div class="error-box">âŒ ' + message + '</div>';
      } else {
        alert('é”™è¯¯ï¼š' + message);
      }
    }

    (function () {
      // ä¼˜å…ˆå°è¯•åŠ è½½config-custom.jsï¼ˆæ‰“åŒ…åä½äºexeåŒç›®å½•ï¼‰
      // å¦‚æœå¤±è´¥ï¼Œåˆ™åŠ è½½static/config.js
      let configLoaded = false;
      
      // å°è¯•åŠ è½½config-custom.js
      const customConfigScript = document.createElement("script");
      customConfigScript.src = "/config-custom.js";
      customConfigScript.onload = function() {
        console.log("[é…ç½®] æˆåŠŸåŠ è½½ config-custom.js");
        configLoaded = true;
        loadBaiduMap();
      };
      customConfigScript.onerror = function() {
        console.log("[é…ç½®] config-custom.js ä¸å­˜åœ¨ï¼Œå°è¯•åŠ è½½ static/config.js");
        // å¦‚æœconfig-custom.jsä¸å­˜åœ¨ï¼ŒåŠ è½½static/config.js
        const defaultConfigScript = document.createElement("script");
        defaultConfigScript.src = "/static/config.js";
        defaultConfigScript.onload = function() {
          console.log("[é…ç½®] æˆåŠŸåŠ è½½ static/config.js");
          configLoaded = true;
          loadBaiduMap();
        };
        defaultConfigScript.onerror = function() {
          showError("é…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ config-custom.js æˆ– static/config.js æ˜¯å¦å­˜åœ¨");
        };
        document.head.appendChild(defaultConfigScript);
      };
      document.head.appendChild(customConfigScript);
      
      function loadBaiduMap() {
        function waitForConfig(callback, maxAttempts = 50) {
          if (window.BMAP_CONFIG) {
            callback();
            return;
          }
          if (maxAttempts <= 0) {
            showError("é…ç½®æ–‡ä»¶åŠ è½½è¶…æ—¶ï¼è¯·æ£€æŸ¥é…ç½®æ–‡ä»¶æ˜¯å¦å­˜åœ¨");
            return;
          }
          setTimeout(() => waitForConfig(callback, maxAttempts - 1), 100);
        }

        waitForConfig(function() {
          const ak = window.BMAP_CONFIG.jsAk;
          if (!ak || ak.includes("æ›¿æ¢")) {
            showError("âš ï¸ è¯·åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½®æœ‰æ•ˆçš„ jsAk");
            console.warn("âš ï¸ è¯·åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½® jsAk");
            return;
          }

          const script = document.createElement("script");
          script.src = "https://api.map.baidu.com/api?v=3.0&ak=" + encodeURIComponent(ak) + "&callback=baiduMapInit";
          script.onerror = function () {
            showError("ç™¾åº¦åœ°å›¾JSåŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š<br>1. jsAkæ˜¯å¦æ­£ç¡®<br>2. åŸŸåç™½åå•/Refereré™åˆ¶<br>3. ç½‘ç»œæ˜¯å¦æ­£å¸¸<br>4. æµè§ˆå™¨æ§åˆ¶å°æ˜¯å¦æœ‰è¯¦ç»†é”™è¯¯ä¿¡æ¯");
          };
          document.head.appendChild(script);
        });
      }
    })();
  </script>

  <script>
    let map;
    let markers = [];
    let overlays = []; // label / polyline / è‡ªå®šä¹‰overlay
    let currentLocations = []; // Excelå¯¼å…¥ç»“æœ

    // âœ… æœ€è¿œçº¿ï¼šå¯å¼€å…³å¯¹è±¡å¼•ç”¨
    let farthestLineOverlay = null;
    let farthestLabelOverlay = null;
    let farthestVisible = true;

    // âœ… è·ç¦»æ ‡ç­¾ï¼šå¯å¼€å…³å¯¹è±¡å¼•ç”¨
    let distanceLabels = [];  // ä¿å­˜æ‰€æœ‰è·ç¦»æ ‡ç­¾å¼•ç”¨
    let distanceLabelsVisible = false;  // è·ç¦»æ ‡ç­¾æ˜¾ç¤ºçŠ¶æ€ï¼ˆé»˜è®¤å…³é—­ï¼‰

    // âœ… è°ƒè¯•æ¨¡å¼ï¼šå…³é—­è‡ªåŠ¨æˆªå›¾ï¼Œå¯ç”¨ç¼–è¾‘åŠŸèƒ½
    let debugMode = false;
    
    // è°ƒè¯•æ¨¡å¼ä¸‹ç­‰å¾…æ‰‹åŠ¨æˆªå›¾çš„å›è°ƒ
    let debugModeScreenshotResolver = null;
    let debugModeCurrentGroupInfo = null; // å½“å‰æ­£åœ¨å¤„ç†çš„ç½‘ç»„ä¿¡æ¯
    
    // æ§åˆ¶é¢æ¿ç¼–è¾‘ä¿æŠ¤æ ‡å¿—ï¼ˆè°ƒè¯•æ¨¡å¼ä¸‹ä½¿ç”¨ï¼‰
    let controlPanelEdited = false;
    
    function toggleDebugMode() {
      debugMode = document.getElementById('toggleDebugMode')?.checked ?? false;
      console.log('è°ƒè¯•æ¨¡å¼:', debugMode ? 'å¼€å¯ï¼ˆè‡ªåŠ¨æˆªå›¾å·²ç¦ç”¨ï¼ŒåŒå‡»å¯ç¼–è¾‘ï¼‰' : 'å…³é—­');
      if (debugMode) {
        updateStatus('ğŸ”§ è°ƒè¯•æ¨¡å¼å·²å¼€å¯ï¼šè‡ªåŠ¨æˆªå›¾ç¦ç”¨ï¼ŒåŒå‡»å¯ç¼–è¾‘å†…å®¹', 'warning');
      }
      
      // æ›´æ–°æ‰‹åŠ¨æˆªå›¾æŒ‰é’®çš„æ‚¬æµ®çŠ¶æ€
      updateManualScreenshotPanelStyle();
      
      // æ›´æ–°å·²æœ‰å…ƒç´ çš„ç¼–è¾‘åŠŸèƒ½
      updateExistingElementsDebugMode();
    }
    
    // æ›´æ–°æ‰‹åŠ¨æˆªå›¾æŒ‰é’®é¢æ¿æ ·å¼ï¼ˆè°ƒè¯•æ¨¡å¼ä¸‹æ‚¬æµ®ï¼‰
    function updateManualScreenshotPanelStyle() {
      const panel = document.getElementById('manual-screenshot-panel');
      if (!panel) return;
      
      if (debugMode) {
        // è°ƒè¯•æ¨¡å¼ï¼šæ‚¬æµ®åœ¨æ§åˆ¶é¢æ¿ä¹‹ä¸Š
        panel.style.position = 'fixed';
        panel.style.bottom = '20px';
        panel.style.left = '20px';
        panel.style.width = '280px';
        panel.style.zIndex = '99999';
        panel.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
        panel.style.marginTop = '0';
      } else {
        // æ­£å¸¸æ¨¡å¼ï¼šæ¢å¤é»˜è®¤æ ·å¼
        panel.style.position = '';
        panel.style.bottom = '';
        panel.style.left = '';
        panel.style.width = '';
        panel.style.zIndex = '';
        panel.style.boxShadow = '';
        panel.style.marginTop = '10px';
      }
    }
    
    // æ›´æ–°å·²æœ‰å…ƒç´ çš„è°ƒè¯•æ¨¡å¼åŠŸèƒ½
    function updateExistingElementsDebugMode() {
      // 1. æ›´æ–°åœ†åœˆæ ‡è®°çš„ç¼–è¾‘åŠŸèƒ½
      if (map) {
        try {
          const markerPane = map.getPanes().markerPane;
          if (markerPane) {
            const circleMarkers = markerPane.querySelectorAll('div[data-marker-number]');
            circleMarkers.forEach(markerContent => {
              // æ›´æ–° pointer-events
              markerContent.style.pointerEvents = debugMode ? 'auto' : 'none';
              
              if (debugMode && !markerContent._debugEditEnabled) {
                markerContent._debugEditEnabled = true;
                markerContent.title = 'åŒå‡»ç¼–è¾‘æ•°å­—';
                
                markerContent.ondblclick = (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  
                  const currentNumber = markerContent.innerText || markerContent.getAttribute('data-marker-number');
                  
                  const input = document.createElement('input');
                  input.type = 'text';
                  input.value = currentNumber;
                  input.style.cssText = `
                    width: 30px;
                    height: 30px;
                    border: none;
                    border-radius: 50%;
                    background: #fff3e0;
                    color: #333;
                    font-weight: bold;
                    font-size: 14px;
                    text-align: center;
                    outline: 2px solid #FF9800;
                    padding: 0;
                  `;
                  
                  markerContent.innerHTML = '';
                  markerContent.appendChild(input);
                  input.focus();
                  input.select();
                  
                  const saveEdit = () => {
                    const newValue = input.value.trim() || currentNumber;
                    markerContent.innerHTML = newValue;
                    console.log(`[è°ƒè¯•æ¨¡å¼] åœ†åœˆæ ‡è®°å·²ç¼–è¾‘: ${currentNumber} -> ${newValue}`);
                  };
                  
                  input.onblur = saveEdit;
                  input.onkeydown = (ke) => {
                    if (ke.key === 'Enter') {
                      ke.preventDefault();
                      input.blur();
                    } else if (ke.key === 'Escape') {
                      input.value = currentNumber;
                      input.blur();
                    }
                  };
                };
              } else if (!debugMode) {
                markerContent.title = '';
                markerContent.ondblclick = null;
              }
            });
          }
        } catch(e) {
          console.warn('æ›´æ–°åœ†åœˆæ ‡è®°ç¼–è¾‘åŠŸèƒ½å¤±è´¥:', e);
        }
        
        // 2. æ›´æ–°å¤‡æ³¨æ ‡ç­¾çš„ç¼–è¾‘åŠŸèƒ½
        try {
          const labelPane = map.getPanes().labelPane;
          if (labelPane) {
            // æŸ¥æ‰¾å¤‡æ³¨æ ‡ç­¾ï¼ˆè“è‰²è¾¹æ¡†ï¼‰
            const allLabels = labelPane.querySelectorAll('div');
            allLabels.forEach(labelElement => {
              if (!labelElement || !labelElement.style) return;
              
              // è¯†åˆ«å¤‡æ³¨æ ‡ç­¾ï¼šè“è‰²è¾¹æ¡†
              const borderColor = labelElement.style.borderColor || window.getComputedStyle(labelElement).borderColor;
              const isRemarkLabel = borderColor && (borderColor.includes('33, 102, 255') || borderColor.includes('rgb(33') || borderColor.includes('#2196F3'));
              
              if (!isRemarkLabel) return;
              
              labelElement.style.pointerEvents = 'auto';
              
              if (debugMode && !labelElement._debugEditEnabled) {
                labelElement._debugEditEnabled = true;
                labelElement.title = 'æ‹–æ‹½ç§»åŠ¨ï¼ŒåŒå‡»ç¼–è¾‘å†…å®¹';
                
                labelElement.ondblclick = (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  
                  const currentText = labelElement.innerText || labelElement.textContent || '';
                  
                  const input = document.createElement('input');
                  input.type = 'text';
                  input.value = currentText;
                  input.style.cssText = `
                    width: ${Math.max(120, labelElement.offsetWidth + 20)}px;
                    padding: 5px 10px;
                    border: 2px solid #FF9800;
                    border-radius: 5px;
                    font-size: 13px;
                    font-weight: bold;
                    background: #fff3e0;
                    outline: none;
                  `;
                  
                  const originalContent = labelElement.innerHTML;
                  labelElement.innerHTML = '';
                  labelElement.appendChild(input);
                  input.focus();
                  input.select();
                  
                  const saveEdit = () => {
                    const newText = input.value.trim();
                    if (newText && newText !== currentText) {
                      labelElement.innerHTML = newText;
                      console.log(`[è°ƒè¯•æ¨¡å¼] å¤‡æ³¨æ ‡ç­¾å·²ç¼–è¾‘: "${newText}"`);
                    } else {
                      labelElement.innerHTML = originalContent;
                    }
                  };
                  
                  input.onblur = saveEdit;
                  input.onkeydown = (ke) => {
                    if (ke.key === 'Enter') {
                      ke.preventDefault();
                      input.blur();
                    } else if (ke.key === 'Escape') {
                      input.value = currentText;
                      input.blur();
                    }
                  };
                };
              } else if (!debugMode) {
                labelElement.title = 'æ‹–æ‹½è°ƒæ•´ä½ç½®';
              }
            });
          }
        } catch(e) {
          console.warn('æ›´æ–°å¤‡æ³¨æ ‡ç­¾ç¼–è¾‘åŠŸèƒ½å¤±è´¥:', e);
        }
      }
      
      // 3. æ›´æ–°æ§åˆ¶é¢æ¿çš„ç¼–è¾‘åŠŸèƒ½ï¼ˆä¸é‡æ–°æ¸²æŸ“ï¼Œåªæ›´æ–°å·²æœ‰å…ƒç´ çš„ç¼–è¾‘å±æ€§ï¼‰
      if (currentRouteResult) {
        const routeInfoDiv = document.getElementById('route-info');
        if (routeInfoDiv) {
          // æŸ¥æ‰¾æ‰€æœ‰å¯ç¼–è¾‘çš„spanå…ƒç´ ï¼Œæ›´æ–°å…¶contenteditableå±æ€§
          const editableSpans = routeInfoDiv.querySelectorAll('span');
          editableSpans.forEach(span => {
            if (span.innerText && span.innerText.match(/^\d+\./)) {
              // è¿™æ˜¯ç½‘ç‚¹æ ‡ç­¾
              if (debugMode) {
                span.setAttribute('contenteditable', 'true');
                span.style.cursor = 'text';
                span.style.outline = 'none';
              } else {
                span.removeAttribute('contenteditable');
                span.style.cursor = '';
              }
            }
          });
        }
      }
      
      console.log(`[è°ƒè¯•æ¨¡å¼] å·²æ›´æ–°æ‰€æœ‰å…ƒç´ çš„ç¼–è¾‘åŠŸèƒ½: ${debugMode ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
    }

    function toggleFarthestLine() {
      farthestVisible = document.getElementById('toggleFarthest')?.checked ?? true;
      console.log('åˆ‡æ¢æœ€è¿œè¿çº¿æ˜¾ç¤ºçŠ¶æ€:', farthestVisible);

      if (farthestLineOverlay) {
        if (typeof farthestLineOverlay.setVisible === 'function') {
          farthestLineOverlay.setVisible(farthestVisible);
        } else {
          // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
          try {
            if (!farthestVisible) {
              map.removeOverlay(farthestLineOverlay);
            } else {
              map.addOverlay(farthestLineOverlay);
            }
          } catch(e) {
            console.warn('åˆ‡æ¢æœ€è¿œè¿çº¿æ˜¾ç¤ºå¤±è´¥:', e);
          }
        }
      }

      if (farthestLabelOverlay) {
        if (typeof farthestLabelOverlay.setVisible === 'function') {
          farthestLabelOverlay.setVisible(farthestVisible);
        } else {
          // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
          try {
            if (!farthestVisible) {
              map.removeOverlay(farthestLabelOverlay);
            } else {
              map.addOverlay(farthestLabelOverlay);
            }
          } catch(e) {
            console.warn('åˆ‡æ¢æœ€è¿œæ ‡ç­¾æ˜¾ç¤ºå¤±è´¥:', e);
          }
        }
        
        // å½“æ ‡ç­¾æ˜¾ç¤ºæ—¶ï¼Œå¯ç”¨æ‹–æ‹½åŠŸèƒ½
        if (farthestVisible) {
          const label = farthestLabelOverlay;
          const initialOffset = label._initialOffset || { x: 0, y: -15 };
          
          setTimeout(() => {
            try {
              const isValidDOMElement = (el) => el && typeof el === 'object' && el.nodeType === 1 && el.style;
              let labelElement = null;
              
              // éå†æ ‡ç­¾å¯¹è±¡çš„å±æ€§æŸ¥æ‰¾DOMå…ƒç´ 
              for (let key in label) {
                if (label[key] && isValidDOMElement(label[key])) {
                  labelElement = label[key];
                  break;
                }
              }
              
              // å¦‚æœé€šè¿‡å±æ€§æ‰¾ä¸åˆ°ï¼Œå°è¯•é€šè¿‡DOMæŸ¥æ‰¾ï¼ˆç»¿è‰²èƒŒæ™¯ï¼‰
              if (!labelElement && map) {
                try {
                  const labelPane = map.getPanes().labelPane;
                  if (labelPane) {
                    const allLabels = labelPane.querySelectorAll('div');
                    for (let el of allLabels) {
                      if (!isValidDOMElement(el)) continue;
                      const bgColor = window.getComputedStyle(el).backgroundColor;
                      // æœ€è¿œè·ç¦»æ ‡ç­¾ç‰¹å¾ï¼šç»¿è‰²èƒŒæ™¯ rgba(0, 255, 0, ...)
                      if (bgColor && bgColor.includes('0') && bgColor.includes('255') && !bgColor.includes('152')) {
                        labelElement = el;
                        break;
                      }
                    }
                  }
                } catch(e) {}
              }
              
              if (labelElement && !labelElement._dragEnabled) {
                labelElement._dragEnabled = true;
                labelElement.style.cursor = 'move';
                labelElement.style.userSelect = 'none';
                labelElement.style.pointerEvents = 'auto';
                labelElement.style.position = 'relative';
                labelElement.title = 'æ‹–æ‹½è°ƒæ•´ä½ç½®';
                
                let isDragging = false;
                let startX = 0, startY = 0, startOffsetX = 0, startOffsetY = 0;
                
                const onMouseDown = (e) => {
                  if (e.button !== 0) return;
                  e.preventDefault();
                  e.stopPropagation();
                  e.stopImmediatePropagation();
                  
                  isDragging = true;
                  startX = e.clientX;
                  startY = e.clientY;
                  try {
                    const offset = label.getOffset();
                    startOffsetX = offset.width || initialOffset.x;
                    startOffsetY = offset.height || initialOffset.y;
                  } catch(err) {
                    startOffsetX = initialOffset.x;
                    startOffsetY = initialOffset.y;
                  }
                  labelElement.style.opacity = '0.7';
                  labelElement.style.zIndex = '99999';
                  map && map.disableDragging();
                  
                  document.addEventListener('mousemove', onMouseMove);
                  document.addEventListener('mouseup', onMouseUp);
                };
                
                const onMouseMove = (ev) => {
                  if (!isDragging) return;
                  ev.preventDefault();
                  const dx = ev.clientX - startX;
                  const dy = ev.clientY - startY;
                  try { 
                    label.setOffset(new BMap.Size(startOffsetX + dx, startOffsetY + dy)); 
                  } catch(err) {}
                };
                
                const onMouseUp = () => {
                  isDragging = false;
                  labelElement.style.opacity = '1';
                  document.removeEventListener('mousemove', onMouseMove);
                  document.removeEventListener('mouseup', onMouseUp);
                  map && map.enableDragging();
                  console.log('æœ€è¿œè·ç¦»æ ‡ç­¾å·²æ‹–æ‹½åˆ°æ–°ä½ç½®');
                };
                
                // ç»‘å®šäº‹ä»¶
                labelElement.onmousedown = onMouseDown;
                
                // åŒæ—¶ç»‘å®šåˆ°å­å…ƒç´ 
                Array.from(labelElement.children || []).forEach(child => {
                  if (child && child.style) {
                    child.style.cursor = 'move';
                    child.style.pointerEvents = 'auto';
                    child.onmousedown = onMouseDown;
                  }
                });
                
                console.log('æœ€è¿œè·ç¦»æ ‡ç­¾æ‹–æ‹½åŠŸèƒ½å·²å¯ç”¨');
              }
            } catch(e) {
              console.warn('å¯ç”¨æœ€è¿œè·ç¦»æ ‡ç­¾æ‹–æ‹½å¤±è´¥:', e);
            }
          }, 500);
        }
      }
    }

    function toggleDistanceLabels() {
      distanceLabelsVisible = document.getElementById('toggleDistanceLabels')?.checked ?? false;
      console.log('åˆ‡æ¢è·ç¦»æ ‡ç­¾æ˜¾ç¤ºçŠ¶æ€:', distanceLabelsVisible);

      distanceLabels.forEach((label, idx) => {
        if (label) {
          if (typeof label.setVisible === 'function') {
            label.setVisible(distanceLabelsVisible);
          } else {
            // å¦‚æœä¸æ”¯æŒsetVisibleï¼Œåˆ™ç§»é™¤/æ·»åŠ 
            try {
              if (!distanceLabelsVisible) {
                map.removeOverlay(label);
              } else {
                map.addOverlay(label);
              }
            } catch(e) {
              console.warn('åˆ‡æ¢è·ç¦»æ ‡ç­¾æ˜¾ç¤ºå¤±è´¥:', e);
            }
          }
          
          // å½“æ ‡ç­¾æ˜¾ç¤ºæ—¶ï¼Œå°è¯•å¯ç”¨æ‹–æ‹½åŠŸèƒ½
          if (distanceLabelsVisible) {
            // ä½¿ç”¨ä¿å­˜çš„åç§»ä¿¡æ¯å¯ç”¨æ‹–æ‹½
            const initialOffset = label._initialOffset || { x: 10, y: -10 };
            const legIdx = label._legIdx !== undefined ? label._legIdx : idx;
            
            setTimeout(() => {
              try {
                // è·å–æ ‡ç­¾çš„DOMå…ƒç´ å¹¶å¯ç”¨æ‹–æ‹½
                const isValidDOMElement = (el) => el && typeof el === 'object' && el.nodeType === 1 && el.style;
                let labelElement = null;
                
                // éå†æ ‡ç­¾å¯¹è±¡çš„å±æ€§æŸ¥æ‰¾DOMå…ƒç´ 
                for (let key in label) {
                  if (label[key] && isValidDOMElement(label[key])) {
                    labelElement = label[key];
                    break;
                  }
                }
                
                // å¦‚æœé€šè¿‡å±æ€§æ‰¾ä¸åˆ°ï¼Œå°è¯•é€šè¿‡DOMæŸ¥æ‰¾
                if (!labelElement && map) {
                  try {
                    const labelPane = map.getPanes().labelPane;
                    if (labelPane) {
                      const allLabels = labelPane.querySelectorAll('div');
                      const distLabels = [];
                      for (let el of allLabels) {
                        if (!isValidDOMElement(el)) continue;
                        const bgColor = window.getComputedStyle(el).backgroundColor;
                        if (bgColor && bgColor.includes('255') && bgColor.includes('152')) {
                          distLabels.push(el);
                        }
                      }
                      if (distLabels.length > idx) {
                        labelElement = distLabels[idx];
                      }
                    }
                  } catch(e) {}
                }
                
                if (labelElement && !labelElement._dragEnabled) {
                  labelElement._dragEnabled = true;
                  labelElement.style.cursor = 'move';
                  labelElement.style.userSelect = 'none';
                  labelElement.style.pointerEvents = 'auto';
                  labelElement.style.position = 'relative';
                  labelElement.title = 'æ‹–æ‹½è°ƒæ•´ä½ç½®';
                  
                  let isDragging = false;
                  let startX = 0, startY = 0, startOffsetX = 0, startOffsetY = 0;
                  
                  const onMouseDown = (e) => {
                    if (e.button !== 0) return;
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    try {
                      const offset = label.getOffset();
                      startOffsetX = offset.width || initialOffset.x;
                      startOffsetY = offset.height || initialOffset.y;
                    } catch(err) {
                      startOffsetX = initialOffset.x;
                      startOffsetY = initialOffset.y;
                    }
                    labelElement.style.opacity = '0.7';
                    labelElement.style.zIndex = '99999';
                    map && map.disableDragging();
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                  };
                  
                  const onMouseMove = (ev) => {
                    if (!isDragging) return;
                    ev.preventDefault();
                    const dx = ev.clientX - startX;
                    const dy = ev.clientY - startY;
                    try { 
                      label.setOffset(new BMap.Size(startOffsetX + dx, startOffsetY + dy)); 
                    } catch(err) {}
                  };
                  
                  const onMouseUp = () => {
                    isDragging = false;
                    labelElement.style.opacity = '1';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    map && map.enableDragging();
                    console.log(`è·ç¦»æ ‡ç­¾ ${legIdx + 1} å·²æ‹–æ‹½åˆ°æ–°ä½ç½®`);
                  };
                  
                  // ç»‘å®šäº‹ä»¶
                  labelElement.onmousedown = onMouseDown;
                  
                  // åŒæ—¶ç»‘å®šåˆ°å­å…ƒç´ 
                  Array.from(labelElement.children || []).forEach(child => {
                    if (child && child.style) {
                      child.style.cursor = 'move';
                      child.style.pointerEvents = 'auto';
                      child.onmousedown = onMouseDown;
                    }
                  });
                  
                  console.log(`è·ç¦»æ ‡ç­¾ ${legIdx + 1} æ‹–æ‹½åŠŸèƒ½å·²å¯ç”¨`);
                }
              } catch(e) {
                console.warn('å¯ç”¨è·ç¦»æ ‡ç­¾æ‹–æ‹½å¤±è´¥:', e);
              }
            }, 800);
          }
        }
      });
    }

    // è·¯çº¿ç®€ç‰ˆå¼€å…³çŠ¶æ€ï¼ˆé»˜è®¤å¼€å¯ï¼‰
    let routeSimpleMode = true;
    // ä¿å­˜å½“å‰è·¯çº¿ç»“æœ
    let currentRouteResult = null;
    // è¡Œæ”¿åŒºå›¾å¼€å…³çŠ¶æ€
    let districtMapEnabled = true;
    // ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¼€å…³çŠ¶æ€
    let districtMapOnlyEnabled = false;

    // ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¼€å…³
    function toggleDistrictMapOnly() {
      districtMapOnlyEnabled = document.getElementById('toggleDistrictMapOnly')?.checked ?? false;
      console.log('åˆ‡æ¢ä»…æˆªå–è¡Œæ”¿åŒºå›¾çŠ¶æ€:', districtMapOnlyEnabled);
    }

    function toggleRouteSimple() {
      routeSimpleMode = document.getElementById('toggleRouteSimple')?.checked ?? true;
      console.log('åˆ‡æ¢è·¯çº¿ç®€ç‰ˆçŠ¶æ€:', routeSimpleMode);
      
      // å¦‚æœå½“å‰æœ‰è·¯çº¿æ•°æ®ï¼Œé‡æ–°æ¸²æŸ“è·¯çº¿è¯¦æƒ…
      if (currentRouteResult) {
        updateRouteInfo(currentRouteResult, routeSimpleMode);
      }
    }

    // è¡Œæ”¿åŒºå›¾å¼€å…³
    function toggleDistrictMap() {
      districtMapEnabled = document.getElementById('toggleDistrictMap')?.checked ?? true;
      console.log('åˆ‡æ¢è¡Œæ”¿åŒºå›¾çŠ¶æ€:', districtMapEnabled);
    }

    // æ›´æ–°è·¯çº¿è¯¦æƒ…æ˜¾ç¤º
    function updateRouteInfo(result, simpleMode = false, forceUpdate = false) {
      const { route, legs, total_distance, total_duration, farthest_points } = result;
      const routeInfoDiv = document.getElementById('route-info');
      
      if (!routeInfoDiv) return;
      
      // è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œå¦‚æœæ§åˆ¶é¢æ¿å·²è¢«ç¼–è¾‘ä¸”ä¸æ˜¯å¼ºåˆ¶æ›´æ–°ï¼Œåˆ™è·³è¿‡æ¸²æŸ“
      if (debugMode && controlPanelEdited && !forceUpdate) {
        console.log('[è°ƒè¯•æ¨¡å¼] æ§åˆ¶é¢æ¿å·²ç¼–è¾‘ï¼Œè·³è¿‡é‡æ–°æ¸²æŸ“');
        return;
      }
      
      let html = '';
      
      if (simpleMode) {
        // ç®€ç‰ˆï¼šåªæ˜¾ç¤ºåºå·å’Œç½‘ç‚¹åç§°ï¼Œç«–å‘æ’åºï¼Œé‡‡ç”¨åœ°å›¾æ ‡è®°åç§°æ ·å¼
        html = '<h3 style="color:#3366FF;margin-bottom:15px;">ğŸ—ºï¸ è·¯çº¿è¯¦æƒ…ï¼ˆç®€ç‰ˆï¼‰</h3>';
        if (debugMode) {
          html += '<div style="color:#d32f2f;font-size:11px;margin-bottom:8px;">ğŸ’¡ è°ƒè¯•æ¨¡å¼ï¼šåŒå‡»å¯ç¼–è¾‘å†…å®¹</div>';
        }
        html += '<div style="line-height:1.8;margin-bottom:15px;">';
        route.forEach((loc, i) => {
          // ä½¿ç”¨åœ°å›¾æ ‡è®°åç§°çš„æ ·å¼ï¼šç™½è‰²èƒŒæ™¯ã€è“è‰²è¾¹æ¡†ã€é˜´å½±ç­‰
          // è°ƒè¯•æ¨¡å¼ä¸‹åŒå‡»å¯ç¼–è¾‘ï¼ˆæ ·å¼å®Œå…¨ä¸€è‡´ï¼‰
          const editableAttr = debugMode ? 'contenteditable="true"' : '';
          html += `<div style="padding:3px 0;display:flex;align-items:center;">
            <span ${editableAttr} style="
              background: white;
              border: 2px solid #2196F3;
              padding: 5px 10px;
              border-radius: 5px;
              font-size: 13px;
              font-weight: bold;
              box-shadow: 0 2px 6px rgba(0,0,0,0.3);
              white-space: nowrap;
              color: #333;
              outline: none;
            ">${i + 1}. ${loc.name}</span>
          </div>`;
        });
        html += '</div>';
        
        // æ€»ç½‘ç‚¹æ•°ä¿¡æ¯ï¼ˆè°ƒè¯•æ¨¡å¼ä¸‹å¯ç¼–è¾‘ï¼Œæ ·å¼å®Œå…¨ä¸€è‡´ï¼‰
        const summaryEditable = debugMode ? 'contenteditable="true"' : '';
        html += `
          <div ${summaryEditable} style="margin-top:15px;padding:12px;background:#E3F2FD;border-radius:6px;font-weight:bold;border-left:4px solid #2196F3;outline:none;">
            <div style="color:#1976D2;font-size:15px;">ğŸ“Š æ€»ç½‘ç‚¹æ•°ï¼š<span style="color:#FF5722;font-size:16px;">${route.length} ä¸ª</span></div>
            <div style="color:#FF5722;font-size:15px;margin-top:8px;">
              æ€»è·ç¦»ï¼š${formatMeters(total_distance)}
            </div>
            <div style="color:#FF5722;font-size:15px;margin-top:5px;">
              æ€»ç”¨æ—¶ï¼š${formatSeconds(total_duration)}
            </div>
          </div>`;

        // æœ€è¿œç½‘ç‚¹ä¿¡æ¯
        if (farthest_points && farthest_points.point1 && farthest_points.point2) {
          html += `
            <div style="margin-top:15px;padding:12px;background:#E8F5E9;border-radius:6px;border-left:4px solid #4CAF50;">
              <div style="color:#2E7D32;font-weight:bold;margin-bottom:8px;font-size:14px;">ğŸ“ æœ€è¿œç½‘ç‚¹ï¼ˆç›´çº¿è·ç¦»ï¼‰</div>
              <div style="color:#388E3C;font-size:15px;margin-bottom:5px;">
                <strong>${farthest_points.point1.name}</strong> â†” <strong>${farthest_points.point2.name}</strong>
              </div>
              <div style="color:#4CAF50;font-size:16px;font-weight:bold;margin-top:5px;">
                ${farthest_points.straight_distance_text}
              </div>
            </div>`;
        }
      } else {
        // å®Œæ•´ç‰ˆï¼šæ˜¾ç¤ºè¯¦ç»†è·¯çº¿ä¿¡æ¯
        html = '<h3 style="color:#3366FF;margin-bottom:10px;">ğŸ—ºï¸ è·¯çº¿è¯¦æƒ…</h3>';
        (legs || []).forEach((lg, i) => {
          html += `
            <div class="route-item">
              <strong>${i + 1}. ${lg.from}</strong> â†’ <strong>${i + 2}. ${lg.to}</strong>
              <div class="distance-info">${lg.distance_text} Â· ${lg.duration_text}</div>
            </div>`;
        });
        // å®Œæ•´ç‰ˆæ€»ç½‘ç‚¹æ•°ä¿¡æ¯ï¼ˆè°ƒè¯•æ¨¡å¼ä¸‹å¯ç¼–è¾‘ï¼Œæ ·å¼å®Œå…¨ä¸€è‡´ï¼‰
        const summaryEditableFull = debugMode ? 'contenteditable="true"' : '';
        html += `
          <div ${summaryEditableFull} style="margin-top:15px;padding:10px;background:#E3F2FD;border-radius:5px;font-weight:bold;outline:none;">
            <div style="color:#1976D2;">æ€»ç½‘ç‚¹æ•°ï¼š${route.length} ä¸ª</div>
            <div style="color:#FF5722;font-size:16px;margin-top:5px;">
              æ€»è·ç¦»ï¼š${formatMeters(total_distance)}
            </div>
            <div style="color:#FF5722;font-size:16px;margin-top:3px;">
              æ€»ç”¨æ—¶ï¼š${formatSeconds(total_duration)}
            </div>
          </div>`;

        if (farthest_points && farthest_points.point1 && farthest_points.point2) {
          html += `
            <div style="margin-top:15px;padding:10px;background:#E8F5E9;border-radius:5px;border-left:4px solid #00FF00;">
              <div style="color:#2E7D32;font-weight:bold;margin-bottom:5px;">ğŸ“ æœ€è¿œç½‘ç‚¹ï¼ˆç›´çº¿è·ç¦»ï¼‰</div>
              <div style="color:#388E3C;font-size:13px;">
                <strong>${farthest_points.point1.name}</strong> â†” <strong>${farthest_points.point2.name}</strong>
              </div>
              <div style="color:#00FF00;font-size:14px;font-weight:bold;margin-top:5px;">
                ${farthest_points.straight_distance_text}
              </div>
            </div>`;
        }
      }
      
      routeInfoDiv.innerHTML = html;
      
      // è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œä¸º contenteditable å…ƒç´ æ·»åŠ ç¼–è¾‘ç›‘å¬
      if (debugMode) {
        const editableElements = routeInfoDiv.querySelectorAll('[contenteditable="true"]');
        editableElements.forEach(el => {
          el.addEventListener('input', () => {
            controlPanelEdited = true;
            console.log('[è°ƒè¯•æ¨¡å¼] æ§åˆ¶é¢æ¿å†…å®¹å·²ä¿®æ”¹');
          });
          el.addEventListener('focus', () => {
            console.log('[è°ƒè¯•æ¨¡å¼] å¼€å§‹ç¼–è¾‘æ§åˆ¶é¢æ¿');
          });
        });
      }
    }

    function drawFarthestLine(farthest_points) {
      // æ¸…ç†æ—§çš„
      if (farthestLineOverlay) {
        try {
          map.removeOverlay(farthestLineOverlay);
          const idx = overlays.indexOf(farthestLineOverlay);
          if (idx > -1) overlays.splice(idx, 1);
        } catch(e) {
          console.warn('ç§»é™¤æ—§çš„æœ€è¿œè¿çº¿å¤±è´¥:', e);
        }
      }
      if (farthestLabelOverlay) {
        try {
          map.removeOverlay(farthestLabelOverlay);
          const idx = overlays.indexOf(farthestLabelOverlay);
          if (idx > -1) overlays.splice(idx, 1);
        } catch(e) {
          console.warn('ç§»é™¤æ—§çš„æœ€è¿œæ ‡ç­¾å¤±è´¥:', e);
        }
      }
      farthestLineOverlay = null;
      farthestLabelOverlay = null;

      if (!map) {
        console.warn('åœ°å›¾æœªåˆå§‹åŒ–ï¼Œæ— æ³•ç»˜åˆ¶æœ€è¿œè¿çº¿');
        return;
      }

      if (!farthest_points || !farthest_points.point1 || !farthest_points.point2) {
        console.log('æœªæ‰¾åˆ°æœ€è¿œç½‘ç‚¹æ•°æ®:', farthest_points);
        return;
      }

      console.log('å¼€å§‹ç»˜åˆ¶æœ€è¿œç½‘ç‚¹è¿çº¿:', farthest_points);

      const p1 = new BMap.Point(farthest_points.point1.lng, farthest_points.point1.lat);
      const p2 = new BMap.Point(farthest_points.point2.lng, farthest_points.point2.lat);

      console.log('ç‚¹1åæ ‡:', p1.lng, p1.lat, 'åç§°:', farthest_points.point1.name);
      console.log('ç‚¹2åæ ‡:', p2.lng, p2.lat, 'åç§°:', farthest_points.point2.name);

      // ä½¿ç”¨äº®ç»¿è‰² #00E676 (Material Design äº®ç»¿è‰²) æˆ– #00FF00 (çº¯ç»¿è‰²)
      const line = new BMap.Polyline([p1, p2], {
        strokeWeight: 4,  // çº¿æ¡å®½åº¦ï¼ˆç¨å¾®ç»†ä¸€ç‚¹ï¼‰
        strokeOpacity: 1.0,  // å®Œå…¨ä¸é€æ˜
        strokeColor: "#00FF00"  // äº®ç»¿è‰²
      });

      // å°è¯•è®¾ç½®è™šçº¿æ ·å¼ï¼ˆå¦‚æœAPIæ”¯æŒï¼‰
      if (typeof line.setStrokeStyle === 'function') {
        try {
          line.setStrokeStyle("dashed");
          console.log('å·²è®¾ç½®è™šçº¿æ ·å¼');
        } catch(e) {
          console.log('è™šçº¿æ ·å¼è®¾ç½®å¤±è´¥ï¼Œä½¿ç”¨å®çº¿');
        }
      }

      map.addOverlay(line);
      overlays.push(line);
      farthestLineOverlay = line;
      console.log('âœ“ æœ€è¿œè¿çº¿å·²æ·»åŠ åˆ°åœ°å›¾');

      // è®¡ç®—ä¸­ç‚¹ç”¨äºæ ‡æ³¨è·ç¦»
      const midPoint = new BMap.Point((p1.lng + p2.lng) / 2, (p1.lat + p2.lat) / 2);

      // æ ‡æ³¨ç›´çº¿è·ç¦»ï¼ˆä½¿ç”¨äº®ç»¿è‰²èƒŒæ™¯ï¼‰
      const label = new BMap.Label(farthest_points.straight_distance_text || "æœ€è¿œç›´çº¿è·ç¦»", {
        offset: new BMap.Size(0, -15)
      });

      label.setStyle({
        background: 'rgba(0, 255, 0, 0.9)',  // äº®ç»¿è‰²èƒŒæ™¯
        color: 'white',
        border: '2px solid white',
        padding: '6px 12px',
        borderRadius: '5px',
        fontSize: '13px',
        fontWeight: 'bold',
        boxShadow: '0 2px 6px rgba(0,0,0,0.4)',
        whiteSpace: 'nowrap',
        zIndex: 1001
      });

      label.setPosition(midPoint);
      map.addOverlay(label);
      overlays.push(label);
      farthestLabelOverlay = label;
      
      // ä¿å­˜åç§»ä¿¡æ¯ï¼Œç”¨äºåç»­å¯ç”¨æ‹–æ‹½åŠŸèƒ½
      label._initialOffset = { x: 0, y: -15 };
      label._midPoint = midPoint;
      
      console.log('âœ“ æœ€è¿œè·ç¦»æ ‡ç­¾å·²æ·»åŠ :', farthest_points.straight_distance_text);

      // æŒ‰å¼€å…³çŠ¶æ€æ˜¾ç¤º/éšè—
      toggleFarthestLine();
    }

    // å®šä¹‰å…¨å±€å›è°ƒå‡½æ•°ï¼Œä¾›ç™¾åº¦åœ°å›¾APIè°ƒç”¨
    window.baiduMapInit = function() {
      if (typeof BMap !== 'undefined') {
        initMap();
      } else {
        showError("ç™¾åº¦åœ°å›¾APIå¯¹è±¡æœªåˆå§‹åŒ–ï¼Œè¯·æ£€æŸ¥AKé…ç½®å’Œç½‘ç»œè¿æ¥");
      }
    };

    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      if (tabName === 'excel') {
        document.querySelector('.tab:first-child').classList.add('active');
        document.getElementById('excel-tab').classList.add('active');
      } else {
        document.querySelector('.tab:last-child').classList.add('active');
        document.getElementById('manual-tab').classList.add('active');
      }
    }

    function initMap() {
      if (typeof BMap === 'undefined') {
        showError("ç™¾åº¦åœ°å›¾APIæœªåŠ è½½æˆåŠŸ");
        return;
      }
      map = new BMap.Map("container");
      const center = new BMap.Point(116.397428, 39.90923);
      map.centerAndZoom(center, 11);
      map.enableScrollWheelZoom(true);
      
      // ç¼©æ”¾/ç§»åŠ¨/æ‹–æ‹½åï¼Œé‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®ï¼ˆä½¿ç”¨é˜²æŠ–æœºåˆ¶ï¼Œç¡®ä¿DOMæ›´æ–°å®Œæˆï¼‰
      let labelUpdateTimer = null;
      const debouncedUpdateLabels = () => {
        if (labelUpdateTimer) clearTimeout(labelUpdateTimer);
        labelUpdateTimer = setTimeout(() => {
          updateLabelPositions();
          labelUpdateTimer = null;
        }, 200); // å¢åŠ å»¶è¿Ÿï¼Œç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
      };
      
      map.addEventListener('zoomend', debouncedUpdateLabels);
      map.addEventListener('moveend', debouncedUpdateLabels);
      map.addEventListener('dragend', debouncedUpdateLabels);
    }

    // ä¿å­˜å½“å‰è·¯çº¿æ•°æ®ï¼ˆç”¨äºç¼©æ”¾ã€å¹³ç§»åé‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®ï¼‰
    let currentRouteData = null;
    let currentLabelOffsets = [];
    let manualAdjustedLabels = new Set(); // è®°å½•å·²æ‰‹åŠ¨è°ƒæ•´è¿‡çš„æ ‡ç­¾ç´¢å¼•
    let currentRoutePolyline = null; // ä¿å­˜å½“å‰è·¯çº¿polylineï¼Œç”¨äºæ£€æµ‹æ ‡ç­¾æ˜¯å¦é®æŒ¡è·¯çº¿
    let currentMarkerOffsets = []; // ä¿å­˜åœ†åœˆæ ‡è®°çš„åç§»ä¿¡æ¯ï¼ˆåƒç´ åç§»ï¼‰ï¼Œç”¨äºæ ‡ç­¾ä½ç½®è®¡ç®—

    // è·å–æ ‡ç­¾çš„å®é™…å°ºå¯¸ï¼ˆé€šè¿‡DOMå…ƒç´ ï¼‰
    function getLabelActualSize(label) {
      try {
        if (label && typeof label.getContent === 'function') {
          const labelElement = label.getContent();
          if (labelElement) {
            // å°è¯•å¤šç§æ–¹æ³•è·å–å°ºå¯¸
            if (labelElement.getBoundingClientRect) {
              const rect = labelElement.getBoundingClientRect();
              if (rect.width > 0 && rect.height > 0) {
                return { width: Math.max(rect.width, 80), height: Math.max(rect.height, 30) };
              }
            }
            // å¦‚æœgetBoundingClientRectä¸å¯ç”¨ï¼Œå°è¯•offsetWidth/offsetHeight
            if (labelElement.offsetWidth && labelElement.offsetHeight) {
              return { 
                width: Math.max(labelElement.offsetWidth, 80), 
                height: Math.max(labelElement.offsetHeight, 30) 
              };
            }
            // å°è¯•é€šè¿‡è®¡ç®—æ ·å¼è·å–
            if (window.getComputedStyle) {
              const style = window.getComputedStyle(labelElement);
              const width = parseFloat(style.width) || 120;
              const height = parseFloat(style.height) || 34;
              if (width > 0 && height > 0) {
                return { width: Math.max(width, 80), height: Math.max(height, 30) };
              }
            }
          }
        }
      } catch(e) {
        // å¿½ç•¥é”™è¯¯ï¼Œä½¿ç”¨é»˜è®¤å€¼
      }
      // é»˜è®¤å°ºå¯¸ï¼ˆåŒ…æ‹¬paddingå’Œborderï¼ŒåŸºäºæ ·å¼ï¼špadding: 5px 10px, border: 2pxï¼‰
      return { width: 120, height: 34 };
    }

    // æ·»åŠ æ ‡ç­¾åˆ°æ ‡è®°ç‚¹ï¼ˆåœ¨è§†å›¾è°ƒæ•´å®Œæˆåè°ƒç”¨ï¼‰
    async function addLabelsToMarkers(route, markers) {
      if (!route || !markers || route.length !== markers.length) return;
      
      currentLabelOffsets = [];
      
      // æŒ‰é¡ºåºæ·»åŠ æ ‡ç­¾ï¼Œç¡®ä¿ä¸äº’ç›¸é®æŒ¡ä¸”ä¸é®æŒ¡åœ†åœˆ
      for (let idx = 0; idx < route.length; idx++) {
        const marker = markers[idx];
        const loc = route[idx];
        if (!marker || !loc) continue;
        
        const labelText = loc.remark ? `${idx + 1}. ${loc.remark}` : `${idx + 1}. ${loc.name}`;
        
        // è®¡ç®—æ ‡ç­¾ä½ç½®ï¼ˆä½¿ç”¨å®é™…å°ºå¯¸ï¼Œç¡®ä¿ä¸é®æŒ¡ä»»ä½•åœ†åœˆï¼‰
        const { offsetX, offsetY } = calculateLabelOffset(idx, route.length, route, currentLabelOffsets, null);
        currentLabelOffsets.push({ offsetX, offsetY });
        
        const label = new BMap.Label(labelText, { offset: new BMap.Size(offsetX, offsetY) });
        label.setStyle({
          background: 'white',
          border: '2px solid #2196F3',
          padding: '5px 10px',
          borderRadius: '5px',
          fontSize: '13px',
          fontWeight: 'bold',
          boxShadow: '0 2px 6px rgba(0,0,0,0.3)',
          whiteSpace: 'nowrap',
          zIndex: 10000  // ç½‘ç‚¹åç§°æ ‡ç­¾æœ€é«˜ä¼˜å…ˆçº§ï¼Œç¡®ä¿åœ¨æ‰€æœ‰è·ç¦»æ ‡ç­¾ä¸Šæ–¹
        });
        marker.setLabel(label);
        
        // ç­‰å¾…æ ‡ç­¾æ¸²æŸ“ï¼Œç„¶åä½¿ç”¨å®é™…å°ºå¯¸é‡æ–°è®¡ç®—ä½ç½®
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // ä½¿ç”¨å®é™…å°ºå¯¸é‡æ–°è®¡ç®—ä½ç½®
        const actualSize = getLabelActualSize(label);
        if (actualSize) {
          const newOffsets = currentLabelOffsets.slice(0, idx);
          const { offsetX: newOffsetX, offsetY: newOffsetY } = calculateLabelOffset(idx, route.length, route, newOffsets, label);
          label.setOffset(new BMap.Size(newOffsetX, newOffsetY));
          currentLabelOffsets[idx] = { offsetX: newOffsetX, offsetY: newOffsetY };
        }
        
        // è®¾ç½®z-index
        try {
          const labelElement = label.getContent();
          if (labelElement && labelElement.style) {
            labelElement.style.zIndex = '10000';
            labelElement.style.position = 'relative';
          }
        } catch(e) {
          // å¿½ç•¥é”™è¯¯
        }
        
        // å¯ç”¨æ ‡ç­¾æ‹–æ‹½åŠŸèƒ½ï¼ˆä»…æ‰‹åŠ¨è¾“å…¥æ—¶ï¼‰
        enableLabelDragging(marker, label, idx, route);
      }
      
      console.log('[æ ‡ç­¾æ·»åŠ ] æ‰€æœ‰æ ‡ç­¾å·²æ·»åŠ å®Œæˆ');
      
      // ç­‰å¾…æ‰€æœ‰æ ‡ç­¾å®Œå…¨æ¸²æŸ“
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // è°ƒæ•´è§†å›¾ï¼Œç¡®ä¿æ‰€æœ‰åœ†åœˆå’Œæ ‡ç­¾ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰éƒ½åœ¨å¯è§åŒºåŸŸå†…
      await adjustViewportForAllElements(route, markers);
    }

    // è°ƒæ•´è§†å›¾ï¼Œç¡®ä¿æ‰€æœ‰åœ†åœˆå’Œæ ‡ç­¾ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰éƒ½åœ¨å¯è§åŒºåŸŸå†…
    async function adjustViewportForAllElements(route, markers) {
      if (!route || route.length === 0 || !map) return;
      
      const mapContainer = map.getContainer();
      if (!mapContainer) return;
      const mapRect = mapContainer.getBoundingClientRect();
      
      // æ§åˆ¶é¢æ¿å‚æ•°
      const panelLeft = 20;
      const panelTop = 20;
      const panelWidth = 380;
      const panelRight = panelLeft + panelWidth;
      const viewPadding = 5; // è§†å›¾è¾¹è·
      const effectiveLeft = panelRight + viewPadding; // æœ‰æ•ˆå¯è§†åŒºåŸŸçš„å·¦è¾¹ç•Œ
      const effectiveRight = mapRect.width - viewPadding; // æœ‰æ•ˆå¯è§†åŒºåŸŸçš„å³è¾¹ç•Œ
      const effectiveTop = viewPadding; // æœ‰æ•ˆå¯è§†åŒºåŸŸçš„ä¸Šè¾¹ç•Œ
      const effectiveBottom = mapRect.height - viewPadding; // æœ‰æ•ˆå¯è§†åŒºåŸŸçš„ä¸‹è¾¹ç•Œ
      
      const markerRadius = 20.5; // åœ†åœˆåŠå¾„ï¼ˆåƒç´ ï¼‰
      const borderWidth = 2; // æ ‡ç­¾è¾¹æ¡†å®½åº¦
      const labelPadding = 5; // æ ‡ç­¾é—´è·
      
      // è®¡ç®—æ‰€æœ‰åœ†åœˆå’Œæ ‡ç­¾çš„è¾¹ç•Œæ¡†
      let allBounds = {
        minX: Infinity,
        maxX: -Infinity,
        minY: Infinity,
        maxY: -Infinity
      };
      
      route.forEach((loc, idx) => {
        const pt = new BMap.Point(loc.lng, loc.lat);
        const pixel = map.pointToPixel(pt);
        
        // åœ†åœˆè¾¹ç•Œï¼ˆè€ƒè™‘åŠå¾„å’Œè¾¹è·ï¼‰
        const circleBounds = {
          minX: pixel.x - markerRadius - labelPadding,
          maxX: pixel.x + markerRadius + labelPadding,
          minY: pixel.y - markerRadius - labelPadding,
          maxY: pixel.y + markerRadius + labelPadding
        };
        
        // æ ‡ç­¾è¾¹ç•Œï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (markers && markers[idx]) {
          const label = markers[idx].getLabel();
          if (label && currentLabelOffsets && currentLabelOffsets[idx]) {
            const offset = currentLabelOffsets[idx];
            const labelX = pixel.x + offset.offsetX;
            const labelY = pixel.y + offset.offsetY;
            const labelSize = getLabelActualSize(label);
            const labelTotalWidth = labelSize.width + borderWidth * 2;
            const labelTotalHeight = labelSize.height + borderWidth * 2;
            
            const labelBounds = {
              minX: labelX - labelTotalWidth / 2 - labelPadding,
              maxX: labelX + labelTotalWidth / 2 + labelPadding,
              minY: labelY - labelTotalHeight / 2 - labelPadding,
              maxY: labelY + labelTotalHeight / 2 + labelPadding
            };
            
            // åˆå¹¶åœ†åœˆå’Œæ ‡ç­¾è¾¹ç•Œ
            allBounds.minX = Math.min(allBounds.minX, circleBounds.minX, labelBounds.minX);
            allBounds.maxX = Math.max(allBounds.maxX, circleBounds.maxX, labelBounds.maxX);
            allBounds.minY = Math.min(allBounds.minY, circleBounds.minY, labelBounds.minY);
            allBounds.maxY = Math.max(allBounds.maxY, circleBounds.maxY, labelBounds.maxY);
          } else {
            // åªæœ‰åœ†åœˆ
            allBounds.minX = Math.min(allBounds.minX, circleBounds.minX);
            allBounds.maxX = Math.max(allBounds.maxX, circleBounds.maxX);
            allBounds.minY = Math.min(allBounds.minY, circleBounds.minY);
            allBounds.maxY = Math.max(allBounds.maxY, circleBounds.maxY);
          }
        } else {
          // åªæœ‰åœ†åœˆ
          allBounds.minX = Math.min(allBounds.minX, circleBounds.minX);
          allBounds.maxX = Math.max(allBounds.maxX, circleBounds.maxX);
          allBounds.minY = Math.min(allBounds.minY, circleBounds.minY);
          allBounds.maxY = Math.max(allBounds.maxY, circleBounds.maxY);
        }
      });
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒæ•´è§†å›¾
      const needsAdjustment = 
        allBounds.minX < effectiveLeft || 
        allBounds.maxX > effectiveRight ||
        allBounds.minY < effectiveTop ||
        allBounds.maxY > effectiveBottom;
      
      if (!needsAdjustment) {
        console.log('[è§†å›¾è°ƒæ•´] æ‰€æœ‰å…ƒç´ éƒ½åœ¨æœ‰æ•ˆåŒºåŸŸå†…');
        return;
      }
      
      // è®¡ç®—éœ€è¦ç¼©æ”¾çš„æ¯”ä¾‹
      const currentWidth = allBounds.maxX - allBounds.minX;
      const currentHeight = allBounds.maxY - allBounds.minY;
      const availableWidth = effectiveRight - effectiveLeft;
      const availableHeight = effectiveBottom - effectiveTop;
      
      const scaleX = currentWidth / availableWidth;
      const scaleY = currentHeight / availableHeight;
      const scale = Math.max(scaleX, scaleY);
      
      if (scale > 1) {
        // éœ€è¦ç¼©å°ï¼Œä½†å°½å¯èƒ½ä¿æŒè¾ƒå¤§çš„ç¼©æ”¾çº§åˆ«
        const currentZoom = map.getZoom();
        if (currentZoom > 10) {
          // æ›´ä¿å®ˆçš„ç¼©æ”¾ç­–ç•¥ï¼šåªç¼©å°å¿…è¦çš„çº§åˆ«ï¼Œä¸è¦è¿‡åº¦ç¼©å°
          // å¦‚æœscaleåªæ˜¯ç•¥å¤§äº1ï¼Œåªç¼©å°1çº§ï¼›å¦‚æœscaleå¾ˆå¤§ï¼Œæ‰ç¼©å°æ›´å¤š
          let zoomReduction = 1;  // é»˜è®¤åªç¼©å°1çº§
          if (scale > 2) {
            // å¦‚æœscaleå¤§äº2ï¼Œæ‰è€ƒè™‘ç¼©å°æ›´å¤šçº§åˆ«
            zoomReduction = Math.min(Math.ceil(Math.log2(scale * 0.8)), currentZoom - 10);  // ä½¿ç”¨0.8çš„ç³»æ•°ï¼Œæ›´ä¿å®ˆ
          }
          
          const newZoom = Math.max(10, currentZoom - zoomReduction);
          if (newZoom < currentZoom) {
            map.setZoom(newZoom);
            await new Promise(resolve => setTimeout(resolve, 500));
            console.log(`[è§†å›¾è°ƒæ•´] ç¼©å°åœ°å›¾ï¼Œç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${newZoom}ï¼ˆä¿å®ˆç­–ç•¥ï¼Œå°½å¯èƒ½ä¿æŒè¾ƒå¤§ç¼©æ”¾ï¼‰`);
            
            // ç¼©æ”¾åé‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®
            updateLabelPositions();
            await new Promise(resolve => setTimeout(resolve, 300));
          }
        }
      }
      
      // æ£€æŸ¥ä¸­å¿ƒç‚¹åç§»ï¼Œå¦‚æœéœ€è¦ï¼Œè°ƒæ•´ä¸­å¿ƒç‚¹
      const centerX = (allBounds.minX + allBounds.maxX) / 2;
      const centerY = (allBounds.minY + allBounds.maxY) / 2;
      const targetCenterX = (effectiveLeft + effectiveRight) / 2;
      const targetCenterY = (effectiveTop + effectiveBottom) / 2;
      
      const offsetX = centerX - targetCenterX;
      const offsetY = centerY - targetCenterY;
      
      if (Math.abs(offsetX) > 10 || Math.abs(offsetY) > 10) {
        try {
          const centerPoint = map.getCenter();
          const centerPixel = map.pointToPixel(centerPoint);
          const newCenterPixel = new BMap.Pixel(centerPixel.x - offsetX, centerPixel.y - offsetY);
          const newCenter = map.pixelToPoint(newCenterPixel);
          map.setCenter(newCenter);
          await new Promise(resolve => setTimeout(resolve, 500));
          console.log(`[è§†å›¾è°ƒæ•´] è°ƒæ•´åœ°å›¾ä¸­å¿ƒ`);
          
          // è°ƒæ•´ä¸­å¿ƒåé‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®
          updateLabelPositions();
          await new Promise(resolve => setTimeout(resolve, 300));
        } catch(e) {
          console.warn('[è§†å›¾è°ƒæ•´] è°ƒæ•´ä¸­å¿ƒç‚¹å¤±è´¥:', e);
        }
      }
    }

    // çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹ï¼ˆAABB vs Circleï¼‰
    // è®¡ç®—åœ†å¿ƒåˆ°çŸ©å½¢æœ€è¿‘ç‚¹çš„è·ç¦»ï¼Œåˆ¤æ–­æ˜¯å¦ç¢°æ’
    function checkRectCircleCollision(rect, circleCenterX, circleCenterY, circleRadius, padding = 0) {
      // rect: { left, right, top, bottom } - æ ‡ç­¾è¾¹æ¡†æ¡†ï¼ˆåŒ…æ‹¬è¾¹æ¡†å’Œé—´è·ï¼‰
      // circleCenterX, circleCenterY: åœ†åœˆä¸­å¿ƒçš„åƒç´ åæ ‡
      // circleRadius: åœ†åœˆåŠå¾„ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
      // padding: é¢å¤–çš„å®‰å…¨è¾¹è·
      
      // è®¡ç®—åœ†å¿ƒåˆ°çŸ©å½¢æœ€è¿‘ç‚¹çš„è·ç¦»
      // å¦‚æœåœ†å¿ƒåœ¨çŸ©å½¢å†…ï¼Œæœ€è¿‘ç‚¹å°±æ˜¯åœ†å¿ƒæœ¬èº«
      // å¦‚æœåœ†å¿ƒåœ¨çŸ©å½¢å¤–ï¼Œæœ€è¿‘ç‚¹æ˜¯çŸ©å½¢è¾¹ç•Œä¸Šç¦»åœ†å¿ƒæœ€è¿‘çš„ç‚¹
      const nearestX = Math.max(rect.left, Math.min(circleCenterX, rect.right));
      const nearestY = Math.max(rect.top, Math.min(circleCenterY, rect.bottom));
      
      // è®¡ç®—æœ€è¿‘ç‚¹åˆ°åœ†å¿ƒçš„è·ç¦»
      const distance = Math.hypot(nearestX - circleCenterX, nearestY - circleCenterY);
      
      // å¦‚æœè·ç¦»å°äºï¼ˆåœ†åœˆåŠå¾„ + å®‰å…¨è¾¹è·ï¼‰ï¼Œåˆ™å‘ç”Ÿç¢°æ’
      const minDistance = circleRadius + padding;
      
      return distance < minDistance;
    }

    // è®¡ç®—æ ‡ç­¾åç§»ï¼Œè‡ªåŠ¨é¿è®©åœ†åœˆä¸å…¶ä»–æ ‡ç­¾ï¼ˆä½¿ç”¨å®é™…å°ºå¯¸ï¼‰
    function calculateLabelOffset(idx, total, route, existingOffsets = [], label = null) {
      // é»˜è®¤åç§»ï¼Œé˜²å¾¡æ€§è¿”å›ï¼ˆå¢åŠ é»˜è®¤è·ç¦»ï¼Œç¡®ä¿ä¸é®æŒ¡åœ†åœˆï¼‰
      // åœ†åœˆåŠå¾„20.5 + è¾¹æ¡†3 + å®‰å…¨è·ç¦»8 + æ ‡ç­¾è¾¹æ¡†2 + æ ‡ç­¾åŠå®½çº¦60 = çº¦93px
      const defaultDistance = 95;  // é»˜è®¤è·ç¦»ï¼Œç¡®ä¿ä¸é®æŒ¡
      const fallback = { 
        offsetX: (idx % 2 === 0) ? defaultDistance : -defaultDistance, 
        offsetY: (idx % 4 < 2) ? -defaultDistance * 0.6 : defaultDistance * 0.6 
      };
      if (!map || !route || idx >= route.length) return fallback;

      const pt = new BMap.Point(route[idx].lng, route[idx].lat);
      const pixel = map.pointToPixel(pt);

      // è·å–å®é™…æ ‡ç­¾å°ºå¯¸
      let labelWidth = 120;
      let labelHeight = 34;
      if (label) {
        const actualSize = getLabelActualSize(label);
        labelWidth = actualSize.width;
        labelHeight = actualSize.height;
      }

      // å°ºå¯¸åŠå®‰å…¨è·ç¦»
      const markerRadius = 20.5;         // åœ†åœˆåŠå¾„ï¼ˆå«è¾¹æ¡†ï¼Œ17.5pxåŠå¾„ + 3pxè¾¹æ¡†ï¼‰
      const markerBorder = 3;            // åœ†åœˆè¾¹æ¡†å®½åº¦
      const borderWidth = 2;             // æ ‡ç­¾è¾¹æ¡†å®½åº¦
      const padding = 8;                  // æ ‡ç­¾ä¸åœ†åœˆä¹‹é—´çš„æœ€å°é—´è·ï¼ˆè¾¹æ¡†å¤–çš„é—´è·ï¼Œå¢åŠ åˆ°8pxï¼‰
      const labelPadding = 5;            // æ ‡ç­¾å†…è¾¹è·
      // æ ‡ç­¾å®é™…å ç”¨ç©ºé—´ï¼ˆåŒ…æ‹¬å†…å®¹ã€å†…è¾¹è·ã€è¾¹æ¡†ï¼‰
      const labelTotalWidth = labelWidth + borderWidth * 2;
      const labelTotalHeight = labelHeight + borderWidth * 2;
      
      // è®¡ç®—æ ‡ç­¾ä¸­å¿ƒåˆ°åœ†åœˆä¸­å¿ƒçš„æœ€å°å®‰å…¨è·ç¦»
      // ç¡®ä¿ï¼šæ ‡ç­¾è¾¹æ¡†å¤–è¾¹ç¼˜ä¸åœ†åœˆè¾¹æ¡†å¤–è¾¹ç¼˜ä¹‹é—´è‡³å°‘æœ‰paddingçš„è·ç¦»
      // æ ‡ç­¾ä¸­å¿ƒåˆ°åœ†åœˆä¸­å¿ƒ = åœ†åœˆåŠå¾„ + åœ†åœˆè¾¹æ¡† + padding + æ ‡ç­¾è¾¹æ¡† + æ ‡ç­¾åŠå®½/åŠé«˜
      const labelHalfSize = Math.max(labelTotalWidth, labelTotalHeight) / 2;
      const minCenterDist = markerRadius + markerBorder + padding + borderWidth + labelHalfSize;
      
      // è·ç¦»ä¸ç¼©æ”¾ï¼ˆæ ¹æ®ç¼©æ”¾çº§åˆ«è°ƒæ•´ï¼Œç¡®ä¿æ ‡ç­¾å§‹ç»ˆæ¸…æ™°å¯è§ï¼‰
      const zoom = map.getZoom();
      const zoomFactor = Math.pow(1.2, zoom - 12); // ç¼©æ”¾å› å­ï¼Œç¼©æ”¾è¶Šå¤§ï¼Œæ ‡ç­¾è·ç¦»è¶Šè¿œ
      // åŸºç¡€è·ç¦»ï¼šè‡³å°‘æ»¡è¶³æœ€å°è·ç¦»ï¼Œå¹¶ä¸”æ ¹æ®ç¼©æ”¾çº§åˆ«å¢åŠ ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„è§†è§‰è·ç¦»
      const baseDist = Math.max(minCenterDist, 60 * zoomFactor);  // åŸºç¡€è·ç¦»ï¼ˆè‡³å°‘æ»¡è¶³æœ€å°è·ç¦»ï¼Œå¹¶å¢åŠ æœ€å°å€¼ï¼‰
      const minDist = minCenterDist;
      const maxDist = Math.max(baseDist * 1.5, 150 * zoomFactor); // æœ€å¤§è·ç¦»ï¼ˆå…è®¸æ›´è¿œçš„ä½ç½®ï¼‰

      // ç”Ÿæˆå€™é€‰åç§»ä½ç½®ï¼ˆå¢åŠ æ›´å¤šå€™é€‰ä½ç½®ï¼ŒåŒ…æ‹¬æ›´è¿œçš„è·ç¦»ï¼‰
      const candidates = [];
      const baseAngle = (idx / Math.max(1, total)) * 2 * Math.PI;

      // å¤šåœˆå±‚å€™é€‰ä½ç½®ï¼šä»è¿‘åˆ°è¿œ
      const distances = [baseDist, baseDist * 1.2, baseDist * 1.5, baseDist * 1.8, baseDist * 2.2];
      distances.forEach(dist => {
        if (dist < minDist || dist > maxDist) return;
        // åŸºç¡€è§’åº¦ä½ç½®
        candidates.push({ offsetX: Math.cos(baseAngle) * dist, offsetY: Math.sin(baseAngle) * dist });
        // å·¦å³å¾®è°ƒ
        for (let angleOffset of [-Math.PI/8, -Math.PI/12, Math.PI/12, Math.PI/8]) {
          candidates.push({ 
            offsetX: Math.cos(baseAngle + angleOffset) * dist, 
            offsetY: Math.sin(baseAngle + angleOffset) * dist 
          });
        }
      });

      // å››ä¸ªè±¡é™ä½ç½®ï¼ˆå¤šä¸ªè·ç¦»å±‚çº§ï¼‰
      for (let dist of [baseDist, baseDist * 1.3, baseDist * 1.7]) {
        if (dist < minDist || dist > maxDist) continue;
        candidates.push({ offsetX: dist, offsetY: -dist });
        candidates.push({ offsetX: -dist, offsetY: -dist });
        candidates.push({ offsetX: -dist, offsetY: dist });
        candidates.push({ offsetX: dist, offsetY: dist });
      }

      // æ°´å¹³å’Œå‚ç›´æ–¹å‘ï¼ˆå¤šä¸ªè·ç¦»ï¼‰
      for (let dist of [baseDist, baseDist * 1.4, baseDist * 1.8]) {
        if (dist < minDist || dist > maxDist) continue;
        candidates.push({ offsetX: dist, offsetY: 0 });
        candidates.push({ offsetX: -dist, offsetY: 0 });
        candidates.push({ offsetX: 0, offsetY: -dist });
        candidates.push({ offsetX: 0, offsetY: dist });
      }

      // å¯¹è§’çº¿ä½ç½®
      const diagDist = baseDist * 1.2;
      if (diagDist >= minDist && diagDist <= maxDist) {
        candidates.push({ offsetX: diagDist * 0.7, offsetY: -diagDist * 0.7 });
        candidates.push({ offsetX: -diagDist * 0.7, offsetY: -diagDist * 0.7 });
        candidates.push({ offsetX: -diagDist * 0.7, offsetY: diagDist * 0.7 });
        candidates.push({ offsetX: diagDist * 0.7, offsetY: diagDist * 0.7 });
      }

      let best = fallback;
      let bestScore = Number.POSITIVE_INFINITY;

      // è¯„ä¼°æ¯ä¸ªå€™é€‰ä½ç½®
      for (const cand of candidates) {
        const dist = Math.hypot(cand.offsetX, cand.offsetY);
        if (dist < minDist || dist > maxDist) continue;

        const labelX = pixel.x + cand.offsetX;
        const labelY = pixel.y + cand.offsetY;
        // æ ‡ç­¾è¾¹æ¡†æ¡†ï¼ˆåŒ…æ‹¬è¾¹æ¡†å®½åº¦å’Œé—´è·ï¼‰
        const box = {
          left: labelX - labelTotalWidth / 2 - padding,
          right: labelX + labelTotalWidth / 2 + padding,
          top: labelY - labelTotalHeight / 2 - padding,
          bottom: labelY + labelTotalHeight / 2 + padding
        };

        // ä½¿ç”¨çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹ï¼ˆAABB vs Circleï¼‰
        // æ£€æŸ¥æ ‡ç­¾è¾¹æ¡†æ¡†ï¼ˆçŸ©å½¢ï¼‰æ˜¯å¦ä¸ä»»ä½•åœ†åœˆæ ‡è®°ï¼ˆåœ†å½¢ï¼‰æœ‰é‡å é®æŒ¡
        // ä½¿ç”¨åœ†åœˆæ ‡è®°çš„å®é™…ç»˜åˆ¶ä½ç½®ï¼ˆåŒ…æ‹¬åç§»é‡ï¼‰
        let overlapsAnyCircle = false;
        for (let i = 0; i < route.length; i++) {
          const circlePt = new BMap.Point(route[i].lng, route[i].lat);
          const circlePx = map.pointToPixel(circlePt);
          
          // è·å–åœ†åœˆæ ‡è®°çš„åç§»é‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          let circleOffsetX = 0;
          let circleOffsetY = 0;
          if (currentMarkerOffsets && currentMarkerOffsets[i]) {
            circleOffsetX = currentMarkerOffsets[i].x;
            circleOffsetY = currentMarkerOffsets[i].y;
          }
          
          // åœ†åœˆæ ‡è®°çš„å®é™…ç»˜åˆ¶ä½ç½®ï¼ˆåƒç´ åæ ‡ï¼ŒåŒ…æ‹¬åç§»ï¼‰
          const actualCircleX = circlePx.x + circleOffsetX;
          const actualCircleY = circlePx.y + circleOffsetY;
          
          // åœ†åœˆçš„æ€»åŠå¾„ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
          const circleTotalRadius = markerRadius + markerBorder;
          
          // ä½¿ç”¨çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹
          // box æ˜¯æ ‡ç­¾çš„è¾¹æ¡†æ¡†ï¼ˆåŒ…æ‹¬è¾¹æ¡†å’Œé—´è·ï¼‰
          // åªæœ‰å½“åœ†å¿ƒåˆ°çŸ©å½¢æœ€è¿‘ç‚¹çš„è·ç¦»å¤§äºï¼ˆåœ†åœˆåŠå¾„ + å®‰å…¨è¾¹è·ï¼‰æ—¶ï¼Œæ‰è®¤ä¸ºä½ç½®åˆæ³•
          const hasCollision = checkRectCircleCollision(
            box,
            actualCircleX,
            actualCircleY,
            circleTotalRadius,
            padding  // é¢å¤–çš„å®‰å…¨è¾¹è·
          );
          
          if (hasCollision) {
            overlapsAnyCircle = true;
            // è®¡ç®—å®é™…è·ç¦»ç”¨äºæ—¥å¿—
            const nearestX = Math.max(box.left, Math.min(actualCircleX, box.right));
            const nearestY = Math.max(box.top, Math.min(actualCircleY, box.bottom));
            const actualDistance = Math.hypot(nearestX - actualCircleX, nearestY - actualCircleY);
            const minRequiredDistance = circleTotalRadius + padding;
            console.log(`[æ ‡ç­¾ä½ç½®] æ ‡ç­¾ ${idx} ä¸åœ†åœˆæ ‡è®° ${i} è¾¹æ¡†ç¢°æ’ï¼Œè·ç¦»: ${actualDistance.toFixed(1)}px < ${minRequiredDistance.toFixed(1)}px`);
            break;
          }
        }
        
        if (overlapsAnyCircle) continue; // å¦‚æœé®æŒ¡ä»»ä½•åœ†åœˆï¼Œç›´æ¥è·³è¿‡
        
        // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦é®æŒ¡è·¯çº¿ï¼ˆpolylineï¼‰
        if (currentRoutePolyline) {
          try {
            const path = currentRoutePolyline.getPath();
            if (path && path.length > 0) {
              // æ£€æŸ¥æ ‡ç­¾è¾¹æ¡†æ˜¯å¦ä¸è·¯çº¿çº¿æ®µç›¸äº¤
              for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                const p1Pixel = map.pointToPixel(p1);
                const p2Pixel = map.pointToPixel(p2);
                
                // è®¡ç®—è·¯çº¿çº¿æ®µçš„è¾¹ç•Œæ¡†
                const lineMinX = Math.min(p1Pixel.x, p2Pixel.x);
                const lineMaxX = Math.max(p1Pixel.x, p2Pixel.x);
                const lineMinY = Math.min(p1Pixel.y, p2Pixel.y);
                const lineMaxY = Math.max(p1Pixel.y, p2Pixel.y);
                
                // è·¯çº¿çº¿æ¡å®½åº¦ï¼ˆ4pxï¼‰ï¼ŒåŠ ä¸Šå®‰å…¨è¾¹è·
                const lineWidth = 4;
                const linePadding = padding;
                
                // æ‰©å±•è·¯çº¿è¾¹ç•Œæ¡†
                const lineBox = {
                  left: lineMinX - lineWidth / 2 - linePadding,
                  right: lineMaxX + lineWidth / 2 + linePadding,
                  top: lineMinY - lineWidth / 2 - linePadding,
                  bottom: lineMaxY + lineWidth / 2 + linePadding
                };
                
                // æ£€æŸ¥æ ‡ç­¾è¾¹æ¡†æ˜¯å¦ä¸è·¯çº¿è¾¹ç•Œæ¡†é‡å 
                const overlapX = Math.max(0, Math.min(box.right, lineBox.right) - Math.max(box.left, lineBox.left));
                const overlapY = Math.max(0, Math.min(box.bottom, lineBox.bottom) - Math.max(box.top, lineBox.top));
                
                if (overlapX > 0 && overlapY > 0) {
                  // è¿›ä¸€æ­¥æ£€æŸ¥ï¼šè®¡ç®—æ ‡ç­¾ä¸­å¿ƒåˆ°è·¯çº¿çº¿æ®µçš„è·ç¦»
                  const lineLength = Math.hypot(p2Pixel.x - p1Pixel.x, p2Pixel.y - p1Pixel.y);
                  if (lineLength > 0) {
                    // è®¡ç®—æ ‡ç­¾ä¸­å¿ƒåˆ°çº¿æ®µçš„æœ€è¿‘ç‚¹
                    const t = Math.max(0, Math.min(1, 
                      ((labelX - p1Pixel.x) * (p2Pixel.x - p1Pixel.x) + (labelY - p1Pixel.y) * (p2Pixel.y - p1Pixel.y)) / (lineLength * lineLength)
                    ));
                    const nearestPointX = p1Pixel.x + t * (p2Pixel.x - p1Pixel.x);
                    const nearestPointY = p1Pixel.y + t * (p2Pixel.y - p1Pixel.y);
                    const distToLine = Math.hypot(labelX - nearestPointX, labelY - nearestPointY);
                    
                    // å¦‚æœè·ç¦»å°äºè·¯çº¿å®½åº¦/2 + æ ‡ç­¾è¾¹æ¡†å®½åº¦/2 + å®‰å…¨è¾¹è·ï¼Œè¯´æ˜é®æŒ¡
                    const minDistToLine = (lineWidth / 2) + Math.max(labelTotalWidth, labelTotalHeight) / 2 + padding;
                    if (distToLine < minDistToLine) {
                      continue; // é®æŒ¡è·¯çº¿ï¼Œè·³è¿‡è¿™ä¸ªä½ç½®
                    }
                  }
                }
              }
            }
          } catch(e) {
            console.warn('[æ ‡ç­¾ä½ç½®è®¡ç®—] æ£€æµ‹è·¯çº¿é®æŒ¡å¤±è´¥:', e);
          }
        }

        // æ£€æŸ¥æ ‡ç­¾è¾¹æ¡†æ˜¯å¦å®Œå…¨åœ¨å¯è§è§†å›¾èŒƒå›´å†…ï¼ˆè€ƒè™‘æ§åˆ¶é¢æ¿ï¼‰
        const mapContainer = map.getContainer();
        if (mapContainer) {
          const mapRect = mapContainer.getBoundingClientRect();
          const panelLeft = 20;
          const panelTop = 20;
          const panelWidth = 380;
          const panelRight = panelLeft + panelWidth;
          const viewPadding = 5; // è§†å›¾è¾¹è·
          const effectiveLeft = panelRight + viewPadding; // æ§åˆ¶é¢æ¿å³ä¾§+è¾¹è·
          const effectiveRight = mapRect.width - viewPadding; // åœ°å›¾å³è¾¹ç•Œ-è¾¹è·
          const effectiveTop = viewPadding; // åœ°å›¾ä¸Šè¾¹ç•Œ+è¾¹è·
          const effectiveBottom = mapRect.height - viewPadding; // åœ°å›¾ä¸‹è¾¹ç•Œ-è¾¹è·
          
          // æ£€æŸ¥æ ‡ç­¾è¾¹æ¡†æ˜¯å¦å®Œå…¨åœ¨æœ‰æ•ˆå¯è§†åŒºåŸŸå†…ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
          if (box.left < effectiveLeft || box.right > effectiveRight || 
              box.top < effectiveTop || box.bottom > effectiveBottom) {
            continue; // è¶…å‡ºæœ‰æ•ˆè¾¹ç•Œçš„ä½ç½®ä¸è€ƒè™‘
          }
        }

        // ä¸ä¹‹å‰æ ‡ç­¾ã€åœ†åœˆçš„é‡å è¯„åˆ†
        let overlapScore = 0;
        let hasOverlap = false;

        for (let i = 0; i < Math.min(existingOffsets.length, route.length); i++) {
          const otherPt = new BMap.Point(route[i].lng, route[i].lat);
          const otherPx = map.pointToPixel(otherPt);
          const off = existingOffsets[i];
          const otherX = otherPx.x + off.offsetX;
          const otherY = otherPx.y + off.offsetY;
          
          // è·å–å…¶ä»–æ ‡ç­¾çš„å®é™…å°ºå¯¸ï¼ˆä¼°ç®—ï¼Œå› ä¸ºå¯èƒ½è¿˜æ²¡æœ‰æ¸²æŸ“ï¼‰
          let otherLabelWidth = labelWidth;
          let otherLabelHeight = labelHeight;
          // ä½¿ç”¨ä¼°ç®—çš„æ€»å°ºå¯¸ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
          const otherLabelTotalWidth = otherLabelWidth + borderWidth * 2;
          const otherLabelTotalHeight = otherLabelHeight + borderWidth * 2;
          
          // å…¶ä»–æ ‡ç­¾çš„è¾¹æ¡†æ¡†ï¼ˆåŒ…æ‹¬è¾¹æ¡†å®½åº¦å’Œé—´è·ï¼‰
          const otherBox = {
            left: otherX - otherLabelTotalWidth / 2 - padding,
            right: otherX + otherLabelTotalWidth / 2 + padding,
            top: otherY - otherLabelTotalHeight / 2 - padding,
            bottom: otherY + otherLabelTotalHeight / 2 + padding
          };
          
          // æ ‡ç­¾è¾¹æ¡†ä¸æ ‡ç­¾è¾¹æ¡†é‡å æ£€æµ‹ï¼ˆå®Œå…¨ç¦æ­¢é‡å ï¼ŒåŒ…æ‹¬è¾¹æ¡†ï¼‰
          // ä½¿ç”¨æ›´ä¸¥æ ¼çš„æ£€æµ‹ï¼šè€ƒè™‘ä¸¤ä¸ªæ ‡ç­¾çš„å®Œæ•´è¾¹æ¡†åŒºåŸŸ
          const overlapX = Math.max(0, Math.min(box.right, otherBox.right) - Math.max(box.left, otherBox.left));
          const overlapY = Math.max(0, Math.min(box.bottom, otherBox.bottom) - Math.max(box.top, otherBox.top));
          if (overlapX > 0 && overlapY > 0) {
            hasOverlap = true;
            overlapScore += overlapX * overlapY * 10000; // å¤§å¹…æé«˜é‡å æƒ©ç½š
            break; // æœ‰é‡å ç›´æ¥è·³è¿‡
          }

          // æ ‡ç­¾ä¸­å¿ƒåˆ°å…¶ä»–åœ†åœˆä¸­å¿ƒçš„è·ç¦»ï¼Œé¿å…è´´å¾—è¿‡è¿‘
          // ä½¿ç”¨çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹æ£€æŸ¥æ ‡ç­¾ä¸å…¶ä»–åœ†åœˆçš„è·ç¦»
          // è·å–å…¶ä»–åœ†åœˆæ ‡è®°çš„åç§»é‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          let otherCircleOffsetX = 0;
          let otherCircleOffsetY = 0;
          if (currentMarkerOffsets && currentMarkerOffsets[i]) {
            otherCircleOffsetX = currentMarkerOffsets[i].x;
            otherCircleOffsetY = currentMarkerOffsets[i].y;
          }
          
          // å…¶ä»–åœ†åœˆæ ‡è®°çš„å®é™…ç»˜åˆ¶ä½ç½®ï¼ˆåƒç´ åæ ‡ï¼ŒåŒ…æ‹¬åç§»ï¼‰
          const otherActualCircleX = otherPx.x + otherCircleOffsetX;
          const otherActualCircleY = otherPx.y + otherCircleOffsetY;
          
          // åœ†åœˆçš„æ€»åŠå¾„ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
          const circleTotalRadius = markerRadius + markerBorder;
          
          // ä½¿ç”¨çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹
          const hasCollisionWithOtherCircle = checkRectCircleCollision(
            box,
            otherActualCircleX,
            otherActualCircleY,
            circleTotalRadius,
            padding
          );
          
          if (hasCollisionWithOtherCircle) {
            overlapScore += 100000;
            hasOverlap = true;
            break;
          }
          
          // æ£€æŸ¥æ ‡ç­¾è¾¹æ¡†æ˜¯å¦ä¸å…¶ä»–æ ‡ç­¾è¾¹æ¡†å¤ªè¿‘ï¼ˆå³ä½¿ä¸é‡å ï¼Œä¹Ÿè¦ä¿æŒä¸€å®šè·ç¦»ï¼‰
          const labelToLabel = Math.hypot(labelX - otherX, labelY - otherY);
          const minLabelDistance = Math.max(labelTotalWidth, labelTotalHeight) / 2 + Math.max(otherLabelTotalWidth, otherLabelTotalHeight) / 2 + padding * 2;
          if (labelToLabel < minLabelDistance) {
            overlapScore += 50000; // è™½ç„¶ä¸é‡å ï¼Œä½†å¤ªè¿‘äº†ä¹Ÿè¦æƒ©ç½š
          }
        }

        // å¦‚æœæœ‰é‡å ï¼Œç›´æ¥è·³è¿‡
        if (hasOverlap) continue;

        // è®¡ç®—è¯„åˆ†ï¼ˆè·ç¦»é€‚ä¸­ã€æ— é‡å çš„ä½ç½®å¾—åˆ†æ›´é«˜ï¼‰
        const distanceScore = Math.abs(dist - baseDist * 1.2); // åå¥½è·ç¦»é€‚ä¸­çš„ä½ç½®
        const totalScore = overlapScore + distanceScore * 0.1;

        if (totalScore < bestScore) {
          bestScore = totalScore;
          best = { offsetX: Math.round(cand.offsetX), offsetY: Math.round(cand.offsetY) };
          if (overlapScore === 0 && distanceScore < 5) break; // å·²æ‰¾åˆ°ç†æƒ³ä½ç½®ï¼Œæå‰ç»“æŸ
        }
      }

      // å¦‚æœæ‰€æœ‰å€™é€‰ä½ç½®éƒ½æœ‰é‡å ï¼Œè¿”å›fallbackï¼ˆè¿™ç§æƒ…å†µåº”è¯¥å¾ˆå°‘ï¼‰
      if (bestScore >= 10000) {
        console.warn(`æ ‡ç­¾ ${idx} æ— æ³•æ‰¾åˆ°å®Œå…¨æ— é‡å çš„ä½ç½®ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®`);
      }

      return best || fallback;
    }

    // ç¼©æ”¾/å¹³ç§»åæ›´æ–°æ‰€æœ‰æ ‡ç­¾ä½ç½®ï¼ˆä½¿ç”¨æ”¹è¿›çš„ç®—æ³•ç¡®ä¿æ‰€æœ‰æ ‡ç­¾éƒ½ä¸é‡å ï¼‰
    function updateLabelPositions() {
      if (!currentRouteData || !currentRouteData.route || !markers.length) return;
      const route = currentRouteData.route;
      const newOffsets = [];

      // æŒ‰é¡ºåºè®¡ç®—æ¯ä¸ªæ ‡ç­¾çš„ä½ç½®ï¼Œç¡®ä¿ä½¿ç”¨å®é™…å°ºå¯¸
      markers.forEach((marker, idx) => {
        if (idx >= route.length) return;
        const label = marker.getLabel();
        if (!label) return;
        
        // å¦‚æœæ ‡ç­¾å·²ç»è¢«æ‰‹åŠ¨è°ƒæ•´è¿‡ï¼Œå°è¯•ä¿æŒç›¸å¯¹ä½ç½®ï¼ˆä½†ä¹Ÿè¦é¿å…é‡å ï¼‰
        if (manualAdjustedLabels.has(idx) && currentLabelOffsets[idx]) {
          // å¯¹äºæ‰‹åŠ¨è°ƒæ•´è¿‡çš„æ ‡ç­¾ï¼Œå…ˆå°è¯•ä½¿ç”¨åŸä½ç½®
          const savedOffset = currentLabelOffsets[idx];
          // æ£€æŸ¥è¿™ä¸ªä½ç½®æ˜¯å¦ä¼šå¯¼è‡´é‡å 
          const actualSize = getLabelActualSize(label);
          const hasOverlap = checkPositionOverlap(idx, savedOffset.offsetX, savedOffset.offsetY, actualSize, route, newOffsets);
          
          if (!hasOverlap) {
            // å¦‚æœæ²¡æœ‰é‡å ï¼Œä¿æŒåŸä½ç½®
          label.setOffset(new BMap.Size(savedOffset.offsetX, savedOffset.offsetY));
          newOffsets.push({ offsetX: savedOffset.offsetX, offsetY: savedOffset.offsetY });
        } else {
            // å¦‚æœæœ‰é‡å ï¼Œé‡æ–°è®¡ç®—ä½ç½®ï¼ˆä½†å°½é‡æ¥è¿‘åŸä½ç½®ï¼‰
            const { offsetX, offsetY } = calculateLabelOffset(idx, route.length, route, newOffsets, label);
            label.setOffset(new BMap.Size(offsetX, offsetY));
            newOffsets.push({ offsetX, offsetY });
          }
        } else {
          // è‡ªåŠ¨è®¡ç®—æ–°çš„åç§»é‡ï¼ˆä¼ å…¥labelå¯¹è±¡ä»¥è·å–å®é™…å°ºå¯¸ï¼‰
          const { offsetX, offsetY } = calculateLabelOffset(idx, route.length, route, newOffsets, label);
          label.setOffset(new BMap.Size(offsetX, offsetY));
          newOffsets.push({ offsetX, offsetY });
        }

        // ç¡®ä¿å±‚çº§
        try {
          const style = label.getStyle();
          if (style) {
            style.zIndex = 10000;
            label.setStyle(style);
          }
          const el = label.getContent();
          if (el && el.style) el.style.zIndex = '10000';
        } catch(e) {}
      });

      currentLabelOffsets = newOffsets;
    }

    // æ£€æŸ¥æŒ‡å®šä½ç½®æ˜¯å¦ä¼šå¯¼è‡´æ ‡ç­¾é‡å 
    function checkPositionOverlap(idx, offsetX, offsetY, labelSize, route, existingOffsets) {
      const pt = new BMap.Point(route[idx].lng, route[idx].lat);
      const pixel = map.pointToPixel(pt);
      const padding = 8;  // å¢åŠ å®‰å…¨è¾¹è·
      const markerRadius = 20.5;
      const markerBorder = 3;
      const borderWidth = 2;

      const labelX = pixel.x + offsetX;
      const labelY = pixel.y + offsetY;
      // è€ƒè™‘æ ‡ç­¾è¾¹æ¡†å®½åº¦
      const labelTotalWidth = labelSize.width + borderWidth * 2;
      const labelTotalHeight = labelSize.height + borderWidth * 2;
      const box = {
        left: labelX - labelTotalWidth / 2 - padding,
        right: labelX + labelTotalWidth / 2 + padding,
        top: labelY - labelTotalHeight / 2 - padding,
        bottom: labelY + labelTotalHeight / 2 + padding
      };

      // ä½¿ç”¨çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹æ£€æŸ¥æ˜¯å¦ä¸æ ‡è®°ç‚¹é‡å 
      // è·å–å½“å‰åœ†åœˆæ ‡è®°çš„åç§»é‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      let circleOffsetX = 0;
      let circleOffsetY = 0;
      if (currentMarkerOffsets && currentMarkerOffsets[idx]) {
        circleOffsetX = currentMarkerOffsets[idx].x;
        circleOffsetY = currentMarkerOffsets[idx].y;
      }
      
      // åœ†åœˆæ ‡è®°çš„å®é™…ç»˜åˆ¶ä½ç½®ï¼ˆåƒç´ åæ ‡ï¼ŒåŒ…æ‹¬åç§»ï¼‰
      const actualCircleX = pixel.x + circleOffsetX;
      const actualCircleY = pixel.y + circleOffsetY;
      
      // åœ†åœˆçš„æ€»åŠå¾„ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
      const circleTotalRadius = markerRadius + markerBorder;
      
      // ä½¿ç”¨çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹
      const hasCollision = checkRectCircleCollision(
        box,
        actualCircleX,
        actualCircleY,
        circleTotalRadius,
        padding
      );
      
      if (hasCollision) {
        return true;
      }

      // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–æ ‡ç­¾é‡å 
      for (let i = 0; i < Math.min(existingOffsets.length, idx); i++) {
        const otherPt = new BMap.Point(route[i].lng, route[i].lat);
        const otherPx = map.pointToPixel(otherPt);
        const off = existingOffsets[i];
        const otherX = otherPx.x + off.offsetX;
        const otherY = otherPx.y + off.offsetY;
        
        // ä½¿ç”¨ä¼°ç®—å°ºå¯¸ï¼ˆå› ä¸ºæˆ‘ä»¬æ²¡æœ‰å…¶ä»–æ ‡ç­¾çš„å®é™…å°ºå¯¸ï¼‰
        const otherSize = { width: 120, height: 34 };
        const otherBox = {
          left: otherX - otherSize.width / 2 - padding,
          right: otherX + otherSize.width / 2 + padding,
          top: otherY - otherSize.height / 2 - padding,
          bottom: otherY + otherSize.height / 2 + padding
        };

        const overlapX = Math.max(0, Math.min(box.right, otherBox.right) - Math.max(box.left, otherBox.left));
        const overlapY = Math.max(0, Math.min(box.bottom, otherBox.bottom) - Math.max(box.top, otherBox.top));
        if (overlapX > 0 && overlapY > 0) {
          return true;
        }

        // ä½¿ç”¨çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–æ ‡è®°ç‚¹å¤ªè¿‘
        // è·å–å…¶ä»–åœ†åœˆæ ‡è®°çš„åç§»é‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        let otherCircleOffsetX = 0;
        let otherCircleOffsetY = 0;
        if (currentMarkerOffsets && currentMarkerOffsets[i]) {
          otherCircleOffsetX = currentMarkerOffsets[i].x;
          otherCircleOffsetY = currentMarkerOffsets[i].y;
        }
        
        // å…¶ä»–åœ†åœˆæ ‡è®°çš„å®é™…ç»˜åˆ¶ä½ç½®ï¼ˆåƒç´ åæ ‡ï¼ŒåŒ…æ‹¬åç§»ï¼‰
        const otherActualCircleX = otherPx.x + otherCircleOffsetX;
        const otherActualCircleY = otherPx.y + otherCircleOffsetY;
        
        // åœ†åœˆçš„æ€»åŠå¾„ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
        const circleTotalRadius = markerRadius + markerBorder;
        
        // ä½¿ç”¨çŸ©å½¢ä¸åœ†å½¢ç¢°æ’æ£€æµ‹
        const hasCollisionWithOtherCircle = checkRectCircleCollision(
          box,
          otherActualCircleX,
          otherActualCircleY,
          circleTotalRadius,
          padding
        );
        
        if (hasCollisionWithOtherCircle) {
          return true;
        }
      }

      return false;
    }

    // å¯ç”¨æ ‡ç­¾æ‹–æ‹½åŠŸèƒ½ï¼ˆå¤‡æ³¨æ ‡ç­¾ï¼‰
    function enableLabelDragging(marker, label, idx, route, forceRebind = false) {
      if (!marker || !label || !route || idx >= route.length) return;
      
      // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿æ ‡ç­¾å…ƒç´ å·²å®Œå…¨æ¸²æŸ“ï¼ˆå¢åŠ å»¶è¿Ÿæ—¶é—´ï¼‰
      setTimeout(() => {
        try {
          // å°è¯•å¤šç§æ–¹æ³•è·å–æ ‡ç­¾å…ƒç´ 
          let labelElement = null;
          
          // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„DOMå…ƒç´ 
          const isValidDOMElement = (el) => {
            return el && typeof el === 'object' && el.nodeType === 1 && el.style && typeof el.style === 'object';
          };
          
          // æ–¹æ³•1: å°è¯•é€šè¿‡ç™¾åº¦åœ°å›¾å†…éƒ¨ç»“æ„æŸ¥æ‰¾ï¼ˆæœ€å¯é ï¼‰
          if (!labelElement && label && typeof label === 'object') {
            try {
              // å°è¯•è®¿é—®ç™¾åº¦åœ°å›¾ Label çš„å†…éƒ¨å±æ€§
              if (label.V && isValidDOMElement(label.V)) {
                labelElement = label.V;
              } else if (label.Ha && isValidDOMElement(label.Ha)) {
                labelElement = label.Ha;
              } else if (label._div && isValidDOMElement(label._div)) {
                labelElement = label._div;
              } else if (label._content && isValidDOMElement(label._content)) {
                labelElement = label._content;
              } else if (label._dom && isValidDOMElement(label._dom)) {
                labelElement = label._dom;
          }
              // éå†æ‰€æœ‰å±æ€§æŸ¥æ‰¾DOMå…ƒç´ 
              if (!labelElement) {
                for (let key in label) {
                  if (label[key] && isValidDOMElement(label[key])) {
                    labelElement = label[key];
                    console.log(`æ ‡ç­¾ ${idx} é€šè¿‡å±æ€§ ${key} æ‰¾åˆ°DOMå…ƒç´ `);
                    break;
                  }
                }
              }
            } catch(e) {
              // å¿½ç•¥è®¿é—®ç§æœ‰å±æ€§çš„é”™è¯¯
            }
          }
          
          // æ–¹æ³•2: é€šè¿‡ DOM æŸ¥æ‰¾ï¼ˆæ ¹æ®æ–‡æœ¬å†…å®¹åŒ¹é…ï¼‰
          if (!labelElement && map) {
            try {
              const labelPane = map.getPanes().labelPane;
              if (labelPane) {
                // è·å–æ ‡ç­¾çš„æ–‡æœ¬å†…å®¹
                const labelText = route[idx].remark ? `${idx + 1}. ${route[idx].remark}` : `${idx + 1}. ${route[idx].name}`;
                const labelPrefix = `${idx + 1}.`;
                // æŸ¥æ‰¾åŒ…å«è¯¥æ–‡æœ¬çš„å…ƒç´ 
                const allLabels = labelPane.querySelectorAll('div');
                for (let el of allLabels) {
                  if (!isValidDOMElement(el)) continue;
                  const text = el.textContent || el.innerText || '';
                  // åŒ¹é…ä»¥åºå·å¼€å¤´çš„æ ‡ç­¾
                  if (text.trim().startsWith(labelPrefix)) {
                      labelElement = el;
                    console.log(`æ ‡ç­¾ ${idx} é€šè¿‡æ–‡æœ¬åŒ¹é…æ‰¾åˆ°DOMå…ƒç´ : "${text.substring(0, 20)}..."`);
                      break;
                  }
                }
              }
            } catch(e) {
              console.warn(`æ–¹æ³•2æŸ¥æ‰¾æ ‡ç­¾å¤±è´¥:`, e);
            }
          }
          
          // æ–¹æ³•3: é€šè¿‡æ ‡è®°ç‚¹ä½ç½®æŸ¥æ‰¾æœ€è¿‘çš„æ ‡ç­¾
          if (!labelElement && map && marker) {
            try {
              const pt = new BMap.Point(route[idx].lng, route[idx].lat);
              const pixel = map.pointToPixel(pt);
              const labelPane = map.getPanes().labelPane;
              if (labelPane) {
                const allLabels = labelPane.querySelectorAll('div');
                let minDist = Infinity;
                let closestEl = null;
                const labelPrefix = `${idx + 1}.`;
                for (let el of allLabels) {
                  if (!isValidDOMElement(el)) continue;
                  // åªåŒ¹é…å¤‡æ³¨æ ‡ç­¾ï¼ˆè“è‰²è¾¹æ¡†ï¼‰ï¼Œæ’é™¤è·ç¦»æ ‡ç­¾
                  const bgColor = window.getComputedStyle(el).backgroundColor;
                  if (bgColor && bgColor.includes('255') && bgColor.includes('152')) continue; // è·³è¿‡æ©™è‰²èƒŒæ™¯çš„è·ç¦»æ ‡ç­¾
                  
                  const rect = el.getBoundingClientRect();
                  if (rect.width === 0 || rect.height === 0) continue;
                  const mapRect = map.getContainer().getBoundingClientRect();
                  const elX = rect.left - mapRect.left + rect.width / 2;
                  const elY = rect.top - mapRect.top + rect.height / 2;
                  const dist = Math.hypot(elX - pixel.x, elY - pixel.y);
                  // ä¼˜å…ˆåŒ¹é…æ–‡æœ¬åºå·ä¸€è‡´çš„æ ‡ç­¾
                  const text = el.textContent || el.innerText || '';
                  if (text.trim().startsWith(labelPrefix)) {
                    closestEl = el;
                    break;
                  }
                  if (dist < minDist && dist < 200) {
                    minDist = dist;
                    closestEl = el;
                  }
                }
                if (closestEl) {
                  labelElement = closestEl;
                  console.log(`æ ‡ç­¾ ${idx} é€šè¿‡ä½ç½®åŒ¹é…æ‰¾åˆ°DOMå…ƒç´ `);
                }
              }
            } catch(e) {
              console.warn(`æ–¹æ³•3æŸ¥æ‰¾æ ‡ç­¾å¤±è´¥:`, e);
            }
          }
          
          // éªŒè¯å…ƒç´ æ˜¯å¦æœ‰æ•ˆ
          if (!isValidDOMElement(labelElement)) {
            // å¦‚æœå…ƒç´ è¿˜æœªå‡†å¤‡å¥½ï¼Œå†ç­‰ä¸€ä¼šå„¿é‡è¯•ï¼ˆæœ€å¤šé‡è¯•5æ¬¡ï¼‰
            const retryKey = `_label_${idx}_retry`;
            const retryCount = window[retryKey] || 0;
            if (retryCount < 5) {
              window[retryKey] = retryCount + 1;
              console.log(`æ ‡ç­¾ ${idx} DOMå…ƒç´ æœªå°±ç»ªï¼Œ${retryCount + 1}/5 æ¬¡é‡è¯•...`);
              setTimeout(() => {
                enableLabelDragging(marker, label, idx, route, forceRebind);
              }, 800);
            } else {
              console.warn(`æ ‡ç­¾ ${idx} æ‹–æ‹½åŠŸèƒ½è·³è¿‡ï¼ˆDOMå…ƒç´ ä¸å¯ç”¨ï¼‰`);
              delete window[retryKey];
            }
            return;
          }
          
          // æ¸…é™¤é‡è¯•è®¡æ•°
          const retryKey = `_label_${idx}_retry`;
          if (window[retryKey]) {
            delete window[retryKey];
          }
          
          // æ£€æŸ¥æ˜¯å¦å·²ç»ç»‘å®šè¿‡äº‹ä»¶ï¼ˆé¿å…é‡å¤ç»‘å®šï¼Œé™¤éå¼ºåˆ¶é‡æ–°ç»‘å®šï¼‰
          if (!forceRebind && labelElement._dragEnabled) {
            return;
          }
          labelElement._dragEnabled = true;
          
          // è®¾ç½®å¯æ‹–æ‹½æ ·å¼ï¼ˆç¡®ä¿å…ƒç´ å¯ä»¥æ¥æ”¶é¼ æ ‡äº‹ä»¶ï¼‰
            labelElement.style.cursor = 'move';
          labelElement.style.userSelect = 'none';
            labelElement.style.webkitUserSelect = 'none';
          labelElement.style.pointerEvents = 'auto';
          labelElement.style.position = 'relative';
          labelElement.title = debugMode ? 'æ‹–æ‹½ç§»åŠ¨ï¼ŒåŒå‡»ç¼–è¾‘å†…å®¹' : 'æ‹–æ‹½è°ƒæ•´ä½ç½®';
          
          // è°ƒè¯•æ¨¡å¼ï¼šåŒå‡»ç¼–è¾‘æ ‡ç­¾å†…å®¹ï¼ˆåŒ…æ‹¬åºå·ï¼‰
          if (debugMode && !labelElement._editEnabled) {
            labelElement._editEnabled = true;
            labelElement.ondblclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              
              // åˆ›å»ºç¼–è¾‘è¾“å…¥æ¡†ï¼Œå¯ç¼–è¾‘å®Œæ•´å†…å®¹ï¼ˆåŒ…æ‹¬åºå·ï¼‰
              const currentText = labelElement.innerText || labelElement.textContent || '';
              
              const input = document.createElement('input');
              input.type = 'text';
              input.value = currentText;
              input.style.cssText = `
                width: ${Math.max(120, labelElement.offsetWidth + 20)}px;
                padding: 5px 10px;
                border: 2px solid #FF9800;
                border-radius: 5px;
                font-size: 13px;
                font-weight: bold;
                background: #fff3e0;
                outline: none;
              `;
              
              // ä¿å­˜åŸå§‹å†…å®¹
              const originalContent = labelElement.innerHTML;
              labelElement.innerHTML = '';
              labelElement.appendChild(input);
              input.focus();
              input.select();
              
              const saveEdit = () => {
                const newText = input.value.trim();
                if (newText && newText !== currentText) {
                  // ç›´æ¥æ›´æ–°æ ‡ç­¾å†…å®¹ï¼ˆä¸åŒæ­¥åˆ°æ§åˆ¶é¢æ¿ï¼‰
                  label.setContent(newText);
                  console.log(`[è°ƒè¯•æ¨¡å¼] åœ°å›¾æ ‡ç­¾å·²ç¼–è¾‘: "${newText}"`);
                } else {
                  // æ¢å¤åŸå§‹å†…å®¹
                  labelElement.innerHTML = originalContent;
                }
              };
              
              input.onblur = saveEdit;
              input.onkeydown = (ke) => {
                if (ke.key === 'Enter') {
                  ke.preventDefault();
                  input.blur();
                } else if (ke.key === 'Escape') {
                  input.value = currentText; // æ¢å¤åŸå€¼
                  input.blur();
                }
              };
            };
          }
          
          // æ‹–æ‹½çŠ¶æ€
          let isDragging = false;
          let startX = 0, startY = 0;
          let startOffsetX = 0, startOffsetY = 0;
          
          const onMouseDown = (e) => {
            if (e.button !== 0) return; // åªå“åº”å·¦é”®
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            
            // è·å–å½“å‰åç§»é‡
            try {
              const offset = label.getOffset();
              startOffsetX = offset.width || 0;
              startOffsetY = offset.height || 0;
            } catch(err) {
              startOffsetX = currentLabelOffsets[idx]?.offsetX || 0;
              startOffsetY = currentLabelOffsets[idx]?.offsetY || 0;
            }
            
            labelElement.style.opacity = '0.7';
            labelElement.style.zIndex = '99999';
            
            // ç¦ç”¨åœ°å›¾æ‹–æ‹½
            map && map.disableDragging();
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          };
          
          const onMouseMove = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const newOffsetX = startOffsetX + dx;
            const newOffsetY = startOffsetY + dy;
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®
            try {
            label.setOffset(new BMap.Size(newOffsetX, newOffsetY));
            } catch(err) {
              console.warn('setOffsetå¤±è´¥:', err);
            }
            
            // ä¿å­˜åç§»é‡
              currentLabelOffsets[idx] = { offsetX: newOffsetX, offsetY: newOffsetY };
            manualAdjustedLabels.add(idx);
          };
          
          const onMouseUp = (e) => {
            if (!isDragging) return;
            isDragging = false;
            
            labelElement.style.opacity = '1';
            
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            
            // æ¢å¤åœ°å›¾æ‹–æ‹½
            map && map.enableDragging();
            
            console.log(`å¤‡æ³¨æ ‡ç­¾ ${idx + 1} å·²æ‹–æ‹½åˆ°æ–°ä½ç½®`);
          };
          
          // ç»‘å®šäº‹ä»¶åˆ°å…ƒç´ æœ¬èº«
          labelElement.onmousedown = onMouseDown;
          
          // åŒæ—¶ç»‘å®šåˆ°å­å…ƒç´ 
          Array.from(labelElement.children || []).forEach(child => {
            if (child && child.style) {
              child.style.cursor = 'move';
              child.style.pointerEvents = 'auto';
              child.onmousedown = onMouseDown;
            }
          });
          
          console.log(`å¤‡æ³¨æ ‡ç­¾ ${idx + 1} æ‹–æ‹½åŠŸèƒ½å·²å¯ç”¨`);
          
        } catch(e) {
          console.error('å¯ç”¨æ ‡ç­¾æ‹–æ‹½å¤±è´¥:', e, e.stack);
        }
      }, 1000); // å»¶è¿Ÿ1000msï¼Œç¡®ä¿æ ‡ç­¾å®Œå…¨æ¸²æŸ“
    }

    // å¯ç”¨è·ç¦»æ ‡ç­¾æ‹–æ‹½åŠŸèƒ½
    function enableDistanceLabelDragging(label, legIdx, midPoint, initialOffset) {
      if (!label || !map) return;
      
      // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿æ ‡ç­¾å…ƒç´ å·²å®Œå…¨æ¸²æŸ“
      setTimeout(() => {
        try {
          // å°è¯•è·å–æ ‡ç­¾DOMå…ƒç´ 
          let labelElement = null;
          
          // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„DOMå…ƒç´ 
          const isValidDOMElement = (el) => {
            return el && typeof el === 'object' && el.nodeType === 1 && el.style && typeof el.style === 'object';
          };
          
          // æ–¹æ³•1: å°è¯•é€šè¿‡ç™¾åº¦åœ°å›¾å†…éƒ¨ç»“æ„æŸ¥æ‰¾
          if (!labelElement && label && typeof label === 'object') {
            try {
              // å°è¯•è®¿é—®ç™¾åº¦åœ°å›¾ Label çš„å†…éƒ¨å±æ€§
              if (label.V && isValidDOMElement(label.V)) {
                labelElement = label.V;
              } else if (label.Ha && isValidDOMElement(label.Ha)) {
                labelElement = label.Ha;
              } else if (label._div && isValidDOMElement(label._div)) {
                labelElement = label._div;
              } else if (label._content && isValidDOMElement(label._content)) {
                labelElement = label._content;
              } else if (label._dom && isValidDOMElement(label._dom)) {
                labelElement = label._dom;
              }
              // éå†æ‰€æœ‰å±æ€§æŸ¥æ‰¾DOMå…ƒç´ 
              if (!labelElement) {
                for (let key in label) {
                  if (label[key] && isValidDOMElement(label[key])) {
                    labelElement = label[key];
                    break;
            }
                }
              }
            } catch(e) {
              // å¿½ç•¥è®¿é—®ç§æœ‰å±æ€§çš„é”™è¯¯
            }
          }
          
          // æ–¹æ³•2: é€šè¿‡ DOM æŸ¥æ‰¾è·ç¦»æ ‡ç­¾ï¼ˆæ©™è‰²èƒŒæ™¯ï¼‰
          if (!labelElement && map) {
            try {
              const labelPane = map.getPanes().labelPane;
              if (labelPane) {
                const allLabels = labelPane.querySelectorAll('div');
                // æ”¶é›†æ‰€æœ‰æ©™è‰²èƒŒæ™¯çš„è·ç¦»æ ‡ç­¾
                const distLabels = [];
                for (let el of allLabels) {
                  if (!isValidDOMElement(el)) continue;
                  const bgColor = window.getComputedStyle(el).backgroundColor;
                  // è·ç¦»æ ‡ç­¾ç‰¹å¾ï¼šæ©™è‰²èƒŒæ™¯ rgba(255, 152, 0, ...)
                  if (bgColor && bgColor.includes('255') && bgColor.includes('152')) {
                    distLabels.push(el);
                  }
                }
                // æŒ‰ä½ç½®æ‰¾åˆ°ç¬¬legIdxä¸ªè·ç¦»æ ‡ç­¾
                if (distLabels.length > legIdx) {
                  labelElement = distLabels[legIdx];
                } else if (distLabels.length > 0) {
                  // å¦‚æœç´¢å¼•ä¸åŒ¹é…ï¼Œå°è¯•æ ¹æ®ä½ç½®åŒ¹é…
                  const midPixel = map.pointToPixel(midPoint);
                  let minDist = Infinity;
                  for (let el of distLabels) {
                    const rect = el.getBoundingClientRect();
                    const mapRect = map.getContainer().getBoundingClientRect();
                    const elX = rect.left - mapRect.left + rect.width / 2;
                    const elY = rect.top - mapRect.top + rect.height / 2;
                    const dist = Math.hypot(elX - midPixel.x, elY - midPixel.y);
                    if (dist < minDist) {
                      minDist = dist;
                      labelElement = el;
                    }
                  }
                }
              }
            } catch(e) {
              console.warn(`æŸ¥æ‰¾è·ç¦»æ ‡ç­¾ ${legIdx} å¤±è´¥:`, e);
            }
          }
          
          if (!isValidDOMElement(labelElement)) {
            // é‡è¯•
            const retryKey = `_distLabel_${legIdx}_retry`;
            const retryCount = window[retryKey] || 0;
            if (retryCount < 3) {
              window[retryKey] = retryCount + 1;
              setTimeout(() => {
                enableDistanceLabelDragging(label, legIdx, midPoint, initialOffset);
              }, 800);
            } else {
              console.warn(`è·ç¦»æ ‡ç­¾ ${legIdx + 1} æ‹–æ‹½åŠŸèƒ½è·³è¿‡ï¼ˆDOMå…ƒç´ ä¸å¯ç”¨ï¼‰`);
              delete window[retryKey];
            }
            return;
          }
          
          // æ¸…é™¤é‡è¯•è®¡æ•°
          const retryKey = `_distLabel_${legIdx}_retry`;
          if (window[retryKey]) {
            delete window[retryKey];
            }
          
          // æ£€æŸ¥æ˜¯å¦å·²ç»‘å®š
          if (labelElement._dragEnabled) return;
          labelElement._dragEnabled = true;
          
          // è®¾ç½®æ‹–æ‹½æ ·å¼ï¼ˆç¡®ä¿å…ƒç´ å¯ä»¥æ¥æ”¶é¼ æ ‡äº‹ä»¶ï¼‰
          labelElement.style.cursor = 'move';
          labelElement.style.userSelect = 'none';
          labelElement.style.pointerEvents = 'auto';
          labelElement.style.position = 'relative';
          labelElement.title = 'æ‹–æ‹½è°ƒæ•´ä½ç½®';
          
          let isDragging = false;
          let startX = 0, startY = 0;
          let startOffsetX = initialOffset.x, startOffsetY = initialOffset.y;
          
          const onMouseDown = (e) => {
            if (e.button !== 0) return;
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            
            // è·å–å½“å‰åç§»é‡
            try {
              const offset = label.getOffset();
              startOffsetX = offset.width || initialOffset.x;
              startOffsetY = offset.height || initialOffset.y;
            } catch(err) {
              // ä½¿ç”¨åˆå§‹å€¼
            }
            
            labelElement.style.opacity = '0.7';
            labelElement.style.zIndex = '99999';
            
            map && map.disableDragging();
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          };
          
          const onMouseMove = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const newOffsetX = startOffsetX + dx;
            const newOffsetY = startOffsetY + dy;
            
            try {
              label.setOffset(new BMap.Size(newOffsetX, newOffsetY));
            } catch(err) {
              // å¿½ç•¥é”™è¯¯
            }
          };
          
          const onMouseUp = (e) => {
            if (!isDragging) return;
            isDragging = false;
            
            labelElement.style.opacity = '1';
            
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            
            map && map.enableDragging();
            
            console.log(`è·ç¦»æ ‡ç­¾ ${legIdx + 1} å·²æ‹–æ‹½åˆ°æ–°ä½ç½®`);
          };
          
          // ç»‘å®šäº‹ä»¶
          labelElement.onmousedown = onMouseDown;
          
          // åŒæ—¶ç»‘å®šåˆ°å­å…ƒç´ 
          Array.from(labelElement.children || []).forEach(child => {
            if (child && child.style) {
                child.style.cursor = 'move';
              child.onmousedown = onMouseDown;
              }
            });
          
          console.log(`è·ç¦»æ ‡ç­¾ ${legIdx + 1} æ‹–æ‹½åŠŸèƒ½å·²å¯ç”¨`);
          
        } catch(e) {
          console.error('å¯ç”¨è·ç¦»æ ‡ç­¾æ‹–æ‹½å¤±è´¥:', e);
        }
      }, 1000);
    }

    // ç»Ÿä¸€çš„çŠ¶æ€æ›´æ–°å‡½æ•°ï¼Œç¡®ä¿çŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
    function updateStatus(message, type = 'info') {
      const statusInfo = document.getElementById('status-info');
      if (!statusInfo) return;
      
      // ç¡®ä¿çŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
      statusInfo.style.display = 'block';
      
      let statusText = document.getElementById('status-text');
      // å¦‚æœæ‰¾ä¸åˆ°status-textå…ƒç´ ï¼Œåˆ›å»ºå®ƒ
      if (!statusText) {
        statusInfo.innerHTML = '<div id="status-text">' + message + '</div>';
        statusText = document.getElementById('status-text');
      } else {
        statusText.textContent = message;
      }
      
      if (statusText) {
        // è®¾ç½®é»˜è®¤æ ·å¼
        statusInfo.style.background = '#f5f5f5'; // é»˜è®¤èƒŒæ™¯è‰²
        statusText.style.color = '#666'; // é»˜è®¤æ–‡å­—é¢œè‰²
        
        if (type === 'loading') {
          statusInfo.style.background = '#E3F2FD'; // è“è‰²èƒŒæ™¯ï¼ˆåŠ è½½ä¸­ï¼‰
          statusText.style.color = '#1976D2';
        } else if (type === 'success') {
          statusInfo.style.background = '#E8F5E9'; // ç»¿è‰²èƒŒæ™¯ï¼ˆæˆåŠŸï¼‰
          statusText.style.color = '#2E7D32';
        } else if (type === 'error') {
          statusInfo.style.background = '#FFEBEE'; // çº¢è‰²èƒŒæ™¯ï¼ˆé”™è¯¯ï¼‰
          statusText.style.color = '#C62828';
        } else if (type === 'ready') {
          statusInfo.style.background = '#f5f5f5'; // é»˜è®¤èƒŒæ™¯ï¼ˆå°±ç»ªï¼‰
          statusText.style.color = '#666';
        }
      }
    }

    function showLoading(message) {
      updateStatus(message, 'loading');
    }
    
    function clearStatusInfo() {
      // ä¸æ¸…é™¤çŠ¶æ€æ ï¼Œåªé‡ç½®ä¸º"å°±ç»ª"çŠ¶æ€
      updateStatus('å°±ç»ª', 'ready');
    }

    // æ˜¾ç¤ºæˆªå›¾æ¨¡å¼é€‰æ‹©å¯¹è¯æ¡†
    function showScreenshotModeDialog(callback) {
      // åˆ›å»ºé®ç½©å±‚
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
      
      // åˆ›å»ºå¯¹è¯æ¡†
      const dialog = document.createElement('div');
      dialog.className = 'modal-dialog';
      dialog.innerHTML = `
        <div class="modal-title">ğŸ“¸ é€‰æ‹©æˆªå›¾æ¨¡å¼</div>
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-detail" onclick="closeScreenshotDialog(false)">è¯¦ç»†ç‰ˆ</button>
          <button class="modal-btn modal-btn-simple" onclick="closeScreenshotDialog(true)">ç®€æ´ç‰ˆ</button>
        </div>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // ä¿å­˜å›è°ƒå‡½æ•°åˆ°å…¨å±€ï¼Œä¾›æŒ‰é’®è°ƒç”¨
      window._screenshotModeCallback = callback;
      
      // ç‚¹å‡»é®ç½©å±‚å…³é—­
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeScreenshotDialog(false); // é»˜è®¤é€‰æ‹©è¯¦ç»†ç‰ˆ
        }
      });
    }

    // å…³é—­æˆªå›¾æ¨¡å¼å¯¹è¯æ¡†
    function closeScreenshotDialog(useSimpleMode) {
      const overlay = document.querySelector('.modal-overlay');
      if (overlay) {
        overlay.remove();
      }
      
      // è°ƒç”¨å›è°ƒå‡½æ•°
      if (window._screenshotModeCallback) {
        window._screenshotModeCallback(useSimpleMode);
        window._screenshotModeCallback = null;
      }
    }
    
    // æ˜¾ç¤ºæ‰¹é‡å¤„ç†è¿›åº¦
    function showBatchProgress(totalGroups) {
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = `
          <div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
            <div id="batchStatus">å‡†å¤‡å¤„ç† ${totalGroups} ä¸ªç½‘ç»„...</div>
            <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
              <div id="batchProgressBar" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
            </div>
          </div>
        `;
      }
    }
    
    // æ›´æ–°æ‰¹é‡å¤„ç†çŠ¶æ€
    function updateBatchStatus(message, current, total) {
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        const batchStatus = document.getElementById('batchStatus');
        const batchProgressBar = document.getElementById('batchProgressBar');
        if (batchStatus) {
          batchStatus.textContent = message;
        }
        if (batchProgressBar) {
          const progress = (current / total * 100).toFixed(0);
          batchProgressBar.style.width = progress + '%';
        }
      }
    }

    function clearMap() {
      if (!map) return;
      markers.forEach(m => map.removeOverlay(m));
      overlays.forEach(o => map.removeOverlay(o));
      markers = [];
      overlays = [];
      currentLocations = [];
      document.getElementById('route-info').innerHTML = '';

      // âœ… æ¸…ç©ºæœ€è¿œçº¿å¼•ç”¨
      farthestLineOverlay = null;
      farthestLabelOverlay = null;
      
      // âœ… æ¸…ç©ºè·ç¦»æ ‡ç­¾å¼•ç”¨
      distanceLabels = [];
      
      // âœ… æ¸…ç©ºè·¯çº¿å¼•ç”¨
      currentRoutePolyline = null;
      
      // âœ… æ¸…ç©ºæ‰‹åŠ¨è°ƒæ•´æ ‡ç­¾è®°å½•
      manualAdjustedLabels.clear();
      
      // âœ… æ¸…ç©ºå¯¼å…¥çš„Excelæ–‡ä»¶
      const excelFileInput = document.getElementById('excelFile');
      if (excelFileInput) {
        excelFileInput.value = '';
      }
      
      // âœ… é‡ç½®æ§åˆ¶é¢æ¿ç¼–è¾‘æ ‡å¿—
      controlPanelEdited = false;
    }

    function parseLocationData() {
      const input = document.getElementById('locationInput').value.trim();
      if (!input) {
        showError('è¯·è¾“å…¥ç½‘ç‚¹æ•°æ®ï¼');
        return [];
      }
      const lines = input.split('\n');
      const locations = [];
      const errors = [];

      lines.forEach((line, idx) => {
        const t = line.trim();
        if (!t) return;
        const parts = t.split(',');
        if (parts.length < 3) {
          errors.push(`ç¬¬${idx + 1}è¡Œï¼šæ ¼å¼é”™è¯¯ï¼ˆè‡³å°‘éœ€è¦ ç»åº¦,çº¬åº¦,åç§°ï¼‰`);
          return;
        }
        const lng = parseFloat(parts[0].trim());
        const lat = parseFloat(parts[1].trim());
        const name = parts[2].trim();
        const remark = parts.length > 3 ? parts[3].trim() : '';  // ç¬¬å››åˆ—ï¼šå¤‡æ³¨
        const group = parts.length > 4 ? parts[4].trim() : '';  // ç¬¬äº”åˆ—ï¼šç½‘ç»„
        const employee_id = parts.length > 5 ? parts[5].trim() : '';  // ç¬¬å…­åˆ—ï¼šå·¥å·
        const employee_name = parts.length > 6 ? parts[6].trim() : '';  // ç¬¬ä¸ƒåˆ—ï¼šå§“å
        const district = parts.length > 7 ? parts[7].trim() : '';  // ç¬¬å…«åˆ—ï¼šå¿åŒº
        const adjustment = parts.length > 8 ? parts[8].trim() : '';  // ç¬¬ä¹åˆ—ï¼šè°ƒæ•´
        const mask = parts.length > 9 ? parts[9].trim() : '';  // ç¬¬ååˆ—ï¼šé®ç½©
        if (Number.isNaN(lng) || Number.isNaN(lat)) {
          errors.push(`ç¬¬${idx + 1}è¡Œï¼šç»çº¬åº¦æ ¼å¼é”™è¯¯`);
          return;
        }
        locations.push({ lng, lat, name, remark, group, employee_id, employee_name, district, adjustment, mask });
      });

      if (errors.length) {
        showError(errors.join('<br>'));
        return [];
      }
      return locations;
    }

    // ä¿å­˜åˆ†ç»„æ•°æ®
    let excelGroups = {};
    let excelEmployees = {};  // æŒ‰å·¥å·åˆ†ç»„çš„æ•°æ®
    let excelAdjustments = {};  // æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ•°æ®ï¼ˆç»“æ„ï¼šadjustment -> employee_id -> groups -> locationsï¼‰

    async function handleExcelUpload() {
      const fileInput = document.getElementById('excelFile');
      const file = fileInput.files[0];
      if (!file) return;

      showLoading('ğŸ“¤ æ­£åœ¨ä¸Šä¼ æ–‡ä»¶...');

      const formData = new FormData();
      formData.append('file', file);

      try {
        const resp = await fetch('/upload_excel', { method: 'POST', body: formData });
        const data = await resp.json();
        if (data.error) return showError(data.error);

        currentLocations = data.locations || [];
        excelGroups = data.groups || {};
        excelEmployees = data.employees || {};  // ä¿å­˜æŒ‰å·¥å·åˆ†ç»„çš„æ•°æ®
        excelAdjustments = data.adjustments || {};  // ä¿å­˜æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ•°æ®
        
        // ç¾åŒ–æˆåŠŸå¯¼å…¥çš„å¼¹çª—æ ¼å¼
        let infoHtml = `<div style="
          padding: 16px 20px;
          background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
          color: white;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
          border-left: 4px solid #2E7D32;
        ">
          <div style="font-size: 18px; font-weight: bold; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 24px;">âœ…</span>
            <span>æˆåŠŸå¯¼å…¥ ${currentLocations.length} ä¸ªç½‘ç‚¹</span>
          </div>`;
        
        if (data.group_count > 0) {
          infoHtml += `
          <div style="
            margin-top: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            backdrop-filter: blur(10px);
          ">
            <div style="font-size: 15px; font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
              <span>ğŸ“¦</span>
              <span>å…± ${data.group_count} ä¸ªç½‘ç»„</span>
            </div>
            <div style="font-size: 13px; line-height: 1.6; opacity: 0.95;">
              ${Object.keys(excelGroups).map(g => `<span style="display: inline-block; margin: 2px 4px; padding: 4px 8px; background: rgba(255, 255, 255, 0.2); border-radius: 4px;">${g} (${excelGroups[g].length}ä¸ªç½‘ç‚¹)</span>`).join('')}
            </div>
            <div style="margin-top: 10px; font-size: 13px; font-style: italic; opacity: 0.9;">
              â³ æ­£åœ¨æŒ‰ç½‘ç»„ä¾æ¬¡å¤„ç†...
            </div>
          </div>`;
        }
        
        infoHtml += `</div>`;
        document.getElementById('route-info').innerHTML = infoHtml;

        if (currentLocations.length) {
          document.getElementById('locationInput').value =
            currentLocations.map(l => [l.lng, l.lat, l.name, l.remark || "", l.group || "", l.employee_id || "", l.employee_name || "", l.district || "", l.adjustment || "", l.mask || ""].filter(x => x !== "").join(',')).join('\n');
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰é®ç½©å†…å®¹ï¼Œå¦‚æœæœ‰åˆ™æ˜¾ç¤ºé®ç½©å±‚
        updateMaskOverlay(currentLocations);

        // å¦‚æœæœ‰åˆ†ç»„æ•°æ®ï¼Œæ˜¾ç¤ºè‡ªå®šä¹‰å¯¹è¯æ¡†é€‰æ‹©æˆªå›¾æ¨¡å¼
        if (data.group_count > 0) {
          // åˆ›å»ºè‡ªå®šä¹‰æ¨¡æ€å¯¹è¯æ¡†
          showScreenshotModeDialog((useSimpleMode) => {
            // è®¾ç½®è·¯çº¿ç®€ç‰ˆå¼€å…³çŠ¶æ€
            const routeSimpleCheckbox = document.getElementById('toggleRouteSimple');
            if (routeSimpleCheckbox) {
              routeSimpleCheckbox.checked = useSimpleMode;
              // è§¦å‘changeäº‹ä»¶ï¼Œç¡®ä¿çŠ¶æ€åŒæ­¥
              if (typeof toggleRouteSimple === 'function') {
                toggleRouteSimple();
              }
            }
            
            // å»¶è¿Ÿä¸€ä¸‹å†å¼€å§‹æ‰¹é‡å¤„ç†ï¼Œç¡®ä¿UIçŠ¶æ€å·²æ›´æ–°
            setTimeout(() => {
              // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰è°ƒæ•´å­—æ®µæ•°æ®ï¼Œå¦‚æœæœ‰åˆ™æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„å¤„ç†
              if (data.adjustment_count > 0 && data.adjustment_count > 0) {
                startBatchProcessByAdjustment();
              } else if (data.employee_count > 0) {
                // å¦‚æœæœ‰å·¥å·æ•°æ®ï¼ŒæŒ‰å·¥å·åˆ†ç»„å¤„ç†
                startBatchProcessByEmployee();
              } else {
                // å¦åˆ™æŒ‰ç½‘ç»„å¤„ç†
                startBatchProcess();
              }
            }, 300);
          });
        } else {
          // æ²¡æœ‰åˆ†ç»„ï¼Œç›´æ¥ç»˜åˆ¶æ‰€æœ‰ç‚¹
          await drawPoints(currentLocations);
          document.getElementById('batchProcessSection').style.display = 'none';
        }
      } catch (e) {
        showError('ä¸Šä¼ å¤±è´¥ï¼š' + e);
      }
    }
    
    // æ‰¹é‡å¤„ç†å‡½æ•°
    async function startBatchProcess() {
      if (!excelGroups || Object.keys(excelGroups).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„ç½‘ç»„æ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥Excelæ–‡ä»¶');
        return;
      }
      
      const groups = Object.keys(excelGroups);
      const totalGroups = groups.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡åœ¨çŠ¶æ€åŒºåŸŸ
      showBatchProgress(totalGroups);
      
      const results = [];
      
      for (let i = 0; i < groups.length; i++) {
        const groupName = groups[i];
        const locations = excelGroups[groupName];
        
        // æ›´æ–°è¿›åº¦ï¼ˆåœ¨çŠ¶æ€åŒºåŸŸæ˜¾ç¤ºï¼‰
        updateBatchStatus(`æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, i + 1, totalGroups);
        
        try {
          // 1. æ¸…é™¤åœ°å›¾
          clearMap();
          
          // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
          await drawPoints(locations);
          
          // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // 4. ä¼˜åŒ–è·¯çº¿
          updateBatchStatus(`ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, i + 1, totalGroups);
          const optimizeResp = await fetch('/optimize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: locations })
          });
          const optimizeData = await optimizeResp.json();
          
          if (optimizeData.error) {
            results.push({ group: groupName, success: false, error: optimizeData.error });
            continue;
          }
          
          // 5. ç»˜åˆ¶è·¯çº¿ç»“æœï¼ˆä¸è‡ªåŠ¨æˆªå›¾ï¼Œç”±æ‰¹é‡å¤„ç†æ§åˆ¶ï¼‰
          await drawRouteResult(optimizeData, false);
          
          // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // 7. æˆªå›¾ï¼ˆä½¿ç”¨ç½‘ç»„åç§°ï¼Œå¦‚æœæ²¡æœ‰å·¥å·åˆ™ä¼ ç©ºå­—ç¬¦ä¸²ï¼Œä¼ å…¥å½“å‰ç½‘ç»„çš„locationsä»¥è·å–å¯¹åº”çš„é®ç½©å†…å®¹ï¼‰
          // è°ƒè¯•æ¨¡å¼ä¸‹ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾
          if (debugMode) {
            console.log(`[è°ƒè¯•æ¨¡å¼] ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾ç½‘ç»„ ${groupName}...`);
            await waitForManualScreenshot({
              groupName: groupName,
              employeeId: '',
              employeeName: '',
              adjustment: '',
              locations: locations
            });
            results.push({ 
              group: groupName, 
              success: true, 
              location_count: locations.length
            });
          } else {
          updateBatchStatus(`ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, i + 1, totalGroups);
          try {
            await captureScreenshot(groupName, '', '', '', locations);
            // captureScreenshotå†…éƒ¨å·²ç»å¤„ç†äº†å“åº”ï¼Œè¿™é‡Œå‡è®¾æˆåŠŸ
            results.push({ 
              group: groupName, 
              success: true, 
              location_count: locations.length
            });
          } catch (e) {
            results.push({ 
              group: groupName, 
              success: false, 
              error: 'æˆªå›¾å¤±è´¥: ' + String(e)
            });
            }
          }
          
          // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
          await new Promise(resolve => setTimeout(resolve, 500));
          
        } catch (e) {
          results.push({ group: groupName, success: false, error: String(e) });
        }
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœï¼ˆåœ¨çŠ¶æ€åŒºåŸŸï¼‰
      const successCount = results.filter(r => r.success).length;
      const failCount = results.filter(r => !r.success).length;
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${successCount} ç»„, å¤±è´¥: ${failCount} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (failCount > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        results.filter(r => !r.success).forEach(r => {
          statusHtml += `${r.group}: ${r.error}<br>`;
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        // ä¿æŒçŠ¶æ€æ å§‹ç»ˆæ˜¾ç¤º
        statusInfo.style.display = 'block';
        // å¯¹äºå¤æ‚çš„æ‰¹é‡å¤„ç†ç»“æœï¼Œç›´æ¥æ›´æ–°innerHTMLï¼Œä½†ä¿æŒçŠ¶æ€æ å¯è§
        statusInfo.innerHTML = statusHtml;
        // 10ç§’åæ¢å¤ä¸º"å°±ç»ª"çŠ¶æ€
        setTimeout(() => {
          // æ¢å¤çŠ¶æ€æ çš„æ ‡å‡†ç»“æ„ï¼ˆåŒ…å«status-textå…ƒç´ ï¼‰
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
      
      // è·¯çº¿è¯¦æƒ…é¡µä¿æŒä¸å˜ï¼Œä¸è¦†ç›–
    }

    // æŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„çš„æ‰¹é‡å¤„ç†å‡½æ•°ï¼ˆé¦–å…ˆæŒ‰è°ƒæ•´å­—æ®µåˆ†ç»„ï¼Œç„¶åæŒ‰å·¥å·ã€ç½‘ç»„åˆ†ç»„ï¼‰
    async function startBatchProcessByAdjustment() {
      if (!excelAdjustments || Object.keys(excelAdjustments).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„è°ƒæ•´å­—æ®µæ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥åŒ…å«è°ƒæ•´å­—æ®µçš„Excelæ–‡ä»¶');
        return;
      }
      
      const adjustments = Object.keys(excelAdjustments);
      const totalAdjustments = adjustments.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡
      showBatchProgress(totalAdjustments);
      
      const allResults = [];
      
      // éå†æ¯ä¸ªè°ƒæ•´å­—æ®µ
      for (let adjIdx = 0; adjIdx < adjustments.length; adjIdx++) {
        const adjustment = adjustments[adjIdx];
        const adjustmentData = excelAdjustments[adjustment];
        const employeeIds = Object.keys(adjustmentData);
        const totalEmployees = employeeIds.length;
        
        updateBatchStatus(`æ­£åœ¨å¤„ç†è°ƒæ•´å­—æ®µ ${adjIdx + 1}/${totalAdjustments}: ${adjustment} - ${totalEmployees}ä¸ªå·¥å·`, adjIdx + 1, totalAdjustments);
        
        // éå†è¯¥è°ƒæ•´å­—æ®µä¸‹çš„æ¯ä¸ªå·¥å·
        for (let empIdx = 0; empIdx < employeeIds.length; empIdx++) {
          const employeeId = employeeIds[empIdx];
          const employeeData = adjustmentData[employeeId];
          const employeeName = employeeData.employee_name || '';
          const groups = Object.keys(employeeData.groups);
          const totalGroups = groups.length;
          
          updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId} (${employeeName}): ${totalGroups}ä¸ªç½‘ç»„`, adjIdx + 1, totalAdjustments);
          
          const employeeResults = [];
          
          // å¦‚æœå‹¾é€‰äº†"ä»…æˆªå–è¡Œæ”¿åŒºå›¾"ï¼Œè·³è¿‡ç½‘ç»„çš„å•ç‹¬æˆªå›¾
          if (!districtMapOnlyEnabled) {
          // å¤„ç†è¯¥å·¥å·ä¸‹çš„æ‰€æœ‰ç½‘ç»„
          for (let i = 0; i < groups.length; i++) {
            const groupName = groups[i];
            const locations = employeeData.groups[groupName];
            
            updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, adjIdx + 1, totalAdjustments);
            
            try {
              // 1. æ¸…é™¤åœ°å›¾
              clearMap();
              
              // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
              await drawPoints(locations);
              
              // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
              await new Promise(resolve => setTimeout(resolve, 500));
              
              // 4. ä¼˜åŒ–è·¯çº¿
              updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, adjIdx + 1, totalAdjustments);
              const optimizeResp = await fetch('/optimize', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ locations: locations })
              });
              const optimizeData = await optimizeResp.json();
              
              if (optimizeData.error) {
                employeeResults.push({ group: groupName, success: false, error: optimizeData.error });
                continue;
              }
              
              // 5. ç»˜åˆ¶è·¯çº¿ç»“æœ
              await drawRouteResult(optimizeData, false);
              
              // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // 7. æˆªå›¾ï¼ˆä½¿ç”¨æ–°çš„å‘½åè§„åˆ™ï¼šç½‘ç»„ç½‘ç‚¹å›¾-å·¥å·-å§“å-è°ƒæ•´ï¼‰
              // è°ƒè¯•æ¨¡å¼ä¸‹ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾
              if (debugMode) {
                console.log(`[è°ƒè¯•æ¨¡å¼] ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾ ${employeeId}-${groupName}...`);
                await waitForManualScreenshot({
                  groupName: groupName,
                  employeeId: employeeId,
                  employeeName: employeeName,
                  adjustment: adjustment,
                  locations: locations
                });
                employeeResults.push({ 
                  group: groupName, 
                  success: true, 
                  location_count: locations.length
                });
              } else {
              updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, adjIdx + 1, totalAdjustments);
              try {
                await captureScreenshot(groupName, employeeId, employeeName, adjustment, locations);
                employeeResults.push({ 
                  group: groupName, 
                  success: true, 
                  location_count: locations.length
                });
              } catch (e) {
                employeeResults.push({ 
                  group: groupName, 
                  success: false, 
                  error: 'æˆªå›¾å¤±è´¥: ' + String(e)
                });
                }
              }
              
              // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
              await new Promise(resolve => setTimeout(resolve, 500));
              
            } catch (e) {
              employeeResults.push({ group: groupName, success: false, error: String(e) });
              }
            }
          }
          
          // å¦‚æœè¡Œæ”¿åŒºå›¾åŠŸèƒ½å¼€å¯ï¼Œä¸”è¯¥å·¥å·æœ‰ç½‘ç»„ï¼Œç»˜åˆ¶è¡Œæ”¿åŒºå›¾
          if (districtMapEnabled && totalGroups > 0) {
            updateBatchStatus(`è°ƒæ•´ ${adjustment} - å·¥å· ${employeeId}: ğŸ—ºï¸ æ­£åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºå›¾...`, adjIdx + 1, totalAdjustments);
            try {
              await drawDistrictMapForEmployee(employeeId, employeeName, employeeData.groups, adjustment);
              employeeResults.push({ 
                type: 'district_map',
                success: true
              });
            } catch (e) {
              console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
              employeeResults.push({ 
                type: 'district_map',
                success: false,
                error: String(e)
              });
            }
          }
          
          allResults.push({
            adjustment: adjustment,
            employee_id: employeeId,
            employee_name: employeeName,
            groups: employeeResults
          });
        }
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœ
      const totalSuccess = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => r.success).length, 0);
      const totalFail = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => !r.success).length, 0);
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${totalSuccess} ç»„, å¤±è´¥: ${totalFail} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (totalFail > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        allResults.forEach(emp => {
          emp.groups.filter(r => !r.success).forEach(r => {
            statusHtml += `${emp.adjustment} - ${emp.employee_id} - ${r.group}: ${r.error}<br>`;
          });
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = statusHtml;
        setTimeout(() => {
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
    }

    // æŒ‰å·¥å·åˆ†ç»„çš„æ‰¹é‡å¤„ç†å‡½æ•°
    async function startBatchProcessByEmployee() {
      if (!excelEmployees || Object.keys(excelEmployees).length === 0) {
        showError('æ²¡æœ‰å¯å¤„ç†çš„å·¥å·æ•°æ®ï¼Œè¯·å…ˆå¯¼å…¥åŒ…å«å·¥å·çš„Excelæ–‡ä»¶');
        return;
      }
      
      const employeeIds = Object.keys(excelEmployees);
      const totalEmployees = employeeIds.length;
      
      // æ˜¾ç¤ºè¿›åº¦æ¡
      showBatchProgress(totalEmployees);
      
      const allResults = [];
      
      // éå†æ¯ä¸ªå·¥å·
      for (let empIdx = 0; empIdx < employeeIds.length; empIdx++) {
        const employeeId = employeeIds[empIdx];
        const employeeData = excelEmployees[employeeId];
        const employeeName = employeeData.employee_name || '';
        const groups = Object.keys(employeeData.groups);
        const totalGroups = groups.length;
        
        updateBatchStatus(`æ­£åœ¨å¤„ç†å·¥å· ${empIdx + 1}/${totalEmployees}: ${employeeId} (${employeeName}) - ${totalGroups}ä¸ªç½‘ç»„`, empIdx + 1, totalEmployees);
        
        const employeeResults = [];
        
        // å¦‚æœå‹¾é€‰äº†"ä»…æˆªå–è¡Œæ”¿åŒºå›¾"ï¼Œè·³è¿‡ç½‘ç»„çš„å•ç‹¬æˆªå›¾
        if (!districtMapOnlyEnabled) {
        // å¤„ç†è¯¥å·¥å·ä¸‹çš„æ‰€æœ‰ç½‘ç»„
        for (let i = 0; i < groups.length; i++) {
          const groupName = groups[i];
          const locations = employeeData.groups[groupName];
          
          updateBatchStatus(`å·¥å· ${employeeId}: æ­£åœ¨å¤„ç†ç½‘ç»„ ${i + 1}/${totalGroups}: ${groupName} (${locations.length}ä¸ªç½‘ç‚¹)`, empIdx + 1, totalEmployees);
          
          try {
            // 1. æ¸…é™¤åœ°å›¾
            clearMap();
            
            // 2. ç»˜åˆ¶å½“å‰ç»„çš„ç½‘ç‚¹
            await drawPoints(locations);
            
            // 3. ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // 4. ä¼˜åŒ–è·¯çº¿
            updateBatchStatus(`å·¥å· ${employeeId}: ğŸ”„ æ­£åœ¨ä¼˜åŒ–ç½‘ç»„ ${groupName} çš„è·¯çº¿...`, empIdx + 1, totalEmployees);
            const optimizeResp = await fetch('/optimize', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ locations: locations })
            });
            const optimizeData = await optimizeResp.json();
            
            if (optimizeData.error) {
              employeeResults.push({ group: groupName, success: false, error: optimizeData.error });
              continue;
            }
            
            // 5. ç»˜åˆ¶è·¯çº¿ç»“æœ
            await drawRouteResult(optimizeData, false);
            
            // 6. ç­‰å¾…è·¯çº¿æ¸²æŸ“
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // 7. æˆªå›¾ï¼ˆä½¿ç”¨æ–°çš„å‘½åè§„åˆ™ï¼šå·¥å·-å§“å-ç½‘ç»„ç½‘ç‚¹å›¾-ç½‘ç»„ï¼‰
            // è°ƒè¯•æ¨¡å¼ä¸‹ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾
            if (debugMode) {
              // ä»locationsä¸­è·å–adjustmentå­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
              const adjustment = locations.length > 0 && locations[0].adjustment ? locations[0].adjustment : '';
              console.log(`[è°ƒè¯•æ¨¡å¼] ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾ ${employeeId}-${groupName}...`);
              await waitForManualScreenshot({
                groupName: groupName,
                employeeId: employeeId,
                employeeName: employeeName,
                adjustment: adjustment,
                locations: locations
              });
              employeeResults.push({ 
                group: groupName, 
                success: true, 
                location_count: locations.length
              });
            } else {
            updateBatchStatus(`å·¥å· ${employeeId}: ğŸ“¸ æ­£åœ¨æˆªå›¾ç½‘ç»„ ${groupName}...`, empIdx + 1, totalEmployees);
            try {
              // ä»locationsä¸­è·å–adjustmentå­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
              const adjustment = locations.length > 0 && locations[0].adjustment ? locations[0].adjustment : '';
              await captureScreenshot(groupName, employeeId, employeeName, adjustment, locations);
              employeeResults.push({ 
                group: groupName, 
                success: true, 
                location_count: locations.length
              });
            } catch (e) {
              employeeResults.push({ 
                group: groupName, 
                success: false, 
                error: 'æˆªå›¾å¤±è´¥: ' + String(e)
              });
              }
            }
            
            // 8. ç­‰å¾…ä¸€ä¸‹å†å¤„ç†ä¸‹ä¸€ç»„
            await new Promise(resolve => setTimeout(resolve, 500));
            
          } catch (e) {
            employeeResults.push({ group: groupName, success: false, error: String(e) });
            }
          }
        }
        
        // å¦‚æœè¡Œæ”¿åŒºå›¾åŠŸèƒ½å¼€å¯ï¼Œä¸”è¯¥å·¥å·æœ‰ç½‘ç»„ï¼Œç»˜åˆ¶è¡Œæ”¿åŒºå›¾
        if (districtMapEnabled && totalGroups > 0) {
          updateBatchStatus(`å·¥å· ${employeeId}: ğŸ—ºï¸ æ­£åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºå›¾...`, empIdx + 1, totalEmployees);
          try {
            // ä»ç¬¬ä¸€ä¸ªç½‘ç»„çš„ç¬¬ä¸€ä¸ªç½‘ç‚¹è·å–adjustmentå­—æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const firstGroupName = groups[0];
            const firstLocations = employeeData.groups[firstGroupName];
            const adjustment = firstLocations.length > 0 && firstLocations[0].adjustment ? firstLocations[0].adjustment : '';
            await drawDistrictMapForEmployee(employeeId, employeeName, employeeData.groups, adjustment);
            employeeResults.push({ 
              type: 'district_map',
              success: true
            });
          } catch (e) {
            console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
            employeeResults.push({ 
              type: 'district_map',
              success: false,
              error: String(e)
            });
          }
        }
        
        allResults.push({
          employee_id: employeeId,
          employee_name: employeeName,
          groups: employeeResults
        });
      }
      
      // æ˜¾ç¤ºå®Œæˆç»“æœ
      const totalSuccess = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => r.success).length, 0);
      const totalFail = allResults.reduce((sum, emp) => 
        sum + emp.groups.filter(r => !r.success).length, 0);
      
      let statusHtml = `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; font-size: 12px;">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">âœ… æ‰¹é‡å¤„ç†å®Œæˆ</div>
        <div>æˆåŠŸ: ${totalSuccess} ç»„, å¤±è´¥: ${totalFail} ç»„</div>
        <div style="background: #ddd; border-radius: 3px; height: 20px; margin-top: 5px; overflow: hidden;">
          <div style="background: #4CAF50; height: 100%; width: 100%;"></div>
        </div>`;
      
      if (totalFail > 0) {
        statusHtml += `<div style="margin-top: 8px; padding: 8px; background: #ff9800; color: white; border-radius: 3px; font-size: 11px;">
          <strong>å¤±è´¥çš„ç½‘ç»„:</strong><br>`;
        allResults.forEach(emp => {
          emp.groups.filter(r => !r.success).forEach(r => {
            statusHtml += `${emp.employee_id} - ${r.group}: ${r.error}<br>`;
          });
        });
        statusHtml += `</div>`;
      }
      
      statusHtml += `</div>`;
      const statusInfo = document.getElementById('status-info');
      if (statusInfo) {
        statusInfo.style.display = 'block';
        statusInfo.innerHTML = statusHtml;
        setTimeout(() => {
          if (statusInfo) {
            statusInfo.innerHTML = '<div id="status-text">å°±ç»ª</div>';
            updateStatus('å°±ç»ª', 'ready');
          }
        }, 10000);
      }
    }

    // ç»˜åˆ¶å·¥å·çš„è¡Œæ”¿åŒºå›¾
    async function drawDistrictMapForEmployee(employeeId, employeeName, groups, adjustment = '') {
      try {
        // æ”¶é›†è¯¥å·¥å·ä¸‹æ‰€æœ‰ç½‘ç‚¹çš„åæ ‡
        const allLocations = [];
        Object.values(groups).forEach(groupLocs => {
          allLocations.push(...groupLocs);
        });
        
        if (allLocations.length === 0) return;
      
      // æ”¶é›†æ‰€æœ‰ç½‘ç»„ä¸­çš„å¿åŒºå­—æ®µï¼ˆç”¨äºç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼‰
      const districtsFromField = new Set();
      allLocations.forEach(loc => {
        if (loc.district && loc.district.trim()) {
          districtsFromField.add(loc.district.trim());
        }
      });
      
      console.log(`[è¡Œæ”¿åŒºå›¾] ä»å¿åŒºå­—æ®µè·å–åˆ°çš„è¡Œæ”¿åŒº: ${Array.from(districtsFromField).join(', ')}`);
      
      // å¦‚æœæä¾›äº†å¿åŒºå­—æ®µï¼Œç›´æ¥ä½¿ç”¨å¿åŒºå­—æ®µï¼›å¦åˆ™ä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼ˆæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒºï¼‰
      let districtsMap = {};
      let useDistrictField = districtsFromField.size > 0;
      
      if (useDistrictField) {
        // ä½¿ç”¨å¿åŒºå­—æ®µæä¾›çš„è¡Œæ”¿åŒºåç§°
        console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨å¿åŒºå­—æ®µç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼Œå…± ${districtsFromField.size} ä¸ªè¡Œæ”¿åŒº`);
        Array.from(districtsFromField).forEach(districtName => {
          districtsMap[districtName] = [];  // åªéœ€è¦è¡Œæ”¿åŒºåç§°ï¼Œä¸éœ€è¦åæ ‡ä¿¡æ¯
        });
      } else {
        // å¦‚æœæ²¡æœ‰å¿åŒºå­—æ®µï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼šè°ƒç”¨APIæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒº
        console.log(`[è¡Œæ”¿åŒºå›¾] æœªæä¾›å¿åŒºå­—æ®µï¼ŒæŸ¥è¯¢æ‰€æœ‰ç½‘ç‚¹çš„è¡Œæ”¿åŒºä¿¡æ¯`);
        
        try {
          const resp = await fetch('/get_district_boundary', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: allLocations })
          });
          const data = await resp.json();
          
          if (data.error || !data.success) {
            console.error('è·å–è¡Œæ”¿åŒºä¿¡æ¯å¤±è´¥:', data.error || 'æœªçŸ¥é”™è¯¯');
            return;
          }
          
          // æŒ‰è¡Œæ”¿åŒºåˆ†ç»„
          data.districts.forEach(dist => {
            const districtName = dist.district;
            if (districtName && districtName !== 'æœªçŸ¥åŒºåŸŸ' && districtName !== 'æŸ¥è¯¢å¤±è´¥') {
              if (!districtsMap[districtName]) {
                districtsMap[districtName] = [];
              }
              districtsMap[districtName].push(dist);
            }
          });
          
          console.log(`[è¡Œæ”¿åŒºå›¾] æŸ¥è¯¢åˆ°çš„è¡Œæ”¿åŒº: ${Object.keys(districtsMap).join(', ')}`);
        } catch (e) {
          console.error('æŸ¥è¯¢è¡Œæ”¿åŒºä¿¡æ¯å¤±è´¥:', e);
          return;
        }
      }
      
      if (Object.keys(districtsMap).length === 0) {
        console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆè¡Œæ”¿åŒºï¼Œè·³è¿‡è¡Œæ”¿åŒºè¾¹ç•Œç»˜åˆ¶`);
        return;
      }
      
      // æ¸…é™¤åœ°å›¾
      clearMap();
      
      // å®šä¹‰é¢œè‰²æ•°ç»„ï¼ˆç”¨äºä¸åŒè¡Œæ”¿åŒºè¾¹æ¡†ï¼Œä½¿ç”¨æ˜æ˜¾åŒºåˆ†çš„é¢œè‰²ï¼‰
      const districtColors = [
        '#FF0000',  // çº¢è‰² - æœ€æ˜æ˜¾
        '#0000FF',  // è“è‰² - ä¸çº¢è‰²å¯¹æ¯”æ˜æ˜¾
        '#00FF00',  // ç»¿è‰² - ä¸çº¢è“å¯¹æ¯”æ˜æ˜¾
        '#FF00FF',  // æ´‹çº¢è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FFFF00',  // é»„è‰² - æ˜äº®é†’ç›®
        '#00FFFF',  // é’è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FF8000',  // æ©™è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#8000FF',  // ç´«è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#FF0080',  // ç²‰çº¢è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
        '#0080FF'   // å¤©è“è‰² - ä¸å‰é¢é¢œè‰²å¯¹æ¯”æ˜æ˜¾
      ];
      const groupColors = [
        '#2196F3', '#FF5722', '#4CAF50', '#FF9800', '#9C27B0',
        '#00BCD4', '#795548', '#607D8B', '#E91E63', '#009688'
      ];
      
      // å‡½æ•°ï¼šå°†é¢œè‰²å˜äº®ï¼ˆå¢åŠ äº®åº¦ï¼‰
      function brightenColor(hex, percent = 30) {
        // ç§»é™¤ # å·
        hex = hex.replace('#', '');
        
        // è½¬æ¢ä¸º RGB
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        // å¢åŠ äº®åº¦
        const newR = Math.min(255, Math.floor(r + (255 - r) * percent / 100));
        const newG = Math.min(255, Math.floor(g + (255 - g) * percent / 100));
        const newB = Math.min(255, Math.floor(b + (255 - b) * percent / 100));
        
        // è½¬æ¢å›åå…­è¿›åˆ¶
        return '#' + 
          newR.toString(16).padStart(2, '0') + 
          newG.toString(16).padStart(2, '0') + 
          newB.toString(16).padStart(2, '0');
      }
      
      // ç¬¬ä¸€æ­¥ï¼šå…ˆæ”¶é›†æ‰€æœ‰éœ€è¦æ˜¾ç¤ºçš„ç‚¹ï¼ˆç½‘ç‚¹å’Œè¾¹ç•Œç‚¹ï¼‰ï¼Œè°ƒæ•´è§†é‡åˆ°åˆé€‚å¤§å°
      const allPointsForViewport = [];
      Object.values(groups).forEach(groupLocs => {
        groupLocs.forEach(loc => {
          allPointsForViewport.push(new BMap.Point(loc.lng, loc.lat));
        });
      });
      
      // å…ˆè°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰ç½‘ç‚¹ï¼ˆåç»­ç»˜åˆ¶è¾¹æ¡†æ—¶ä¼šè¿›ä¸€æ­¥è°ƒæ•´ï¼‰
      if (allPointsForViewport.length > 0) {
        map.setViewport(allPointsForViewport);
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å…ƒç´ è¢«æ§åˆ¶é¢æ¿é®æŒ¡
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        
        let hasOverlap = false;
        for (const pt of allPointsForViewport) {
          const pixel = map.pointToPixel(pt);
          if (pixel.x >= panelLeft && pixel.x <= panelRight && pixel.y >= panelTop) {
            hasOverlap = true;
            break;
          }
        }
        
        if (hasOverlap) {
          const currentZoom = map.getZoom();
          if (currentZoom > 10) {
            const adjustedZoom = Math.max(10, currentZoom - 1);
            map.setZoom(adjustedZoom);
            await new Promise(resolve => setTimeout(resolve, 500));
            console.log(`[è¡Œæ”¿åŒºå›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${adjustedZoom}ï¼ˆé¿å…æ§åˆ¶é¢æ¿é®æŒ¡ï¼‰`);
          }
        }
      }
      
      // ç¬¬äºŒæ­¥ï¼šè§†é‡è°ƒæ•´å®Œæˆåï¼Œå¼€å§‹ç»˜åˆ¶æ‰€æœ‰ç½‘ç»„çš„è·¯çº¿å’Œç½‘ç‚¹ï¼ˆä¸åŒç½‘ç»„ç”¨ä¸åŒé¢œè‰²ï¼‰
      let groupIndex = 0;
      
      console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹ç»˜åˆ¶æ‰€æœ‰ç½‘ç»„çš„è·¯çº¿å’Œç½‘ç‚¹ï¼Œå…± ${Object.keys(groups).length} ä¸ªç½‘ç»„`);
      
      // ä½¿ç”¨Promiseæ•°ç»„æ¥ç­‰å¾…æ‰€æœ‰è·¯çº¿åŠ è½½å®Œæˆ
      const routePromises = [];
      
      for (const [groupName, groupLocs] of Object.entries(groups)) {
        const groupColor = groupColors[groupIndex % groupColors.length];
        groupIndex++;
        
        console.log(`[è¡Œæ”¿åŒºå›¾] ç»˜åˆ¶ç½‘ç»„ ${groupName}ï¼Œå…± ${groupLocs.length} ä¸ªç½‘ç‚¹ï¼Œé¢œè‰²: ${groupColor}`);
        
        // ä¼˜åŒ–è·¯çº¿ä»¥è·å–é¡ºåº
        let optimizedLocs = groupLocs;
        const optimizePromise = (async () => {
        try {
          const optimizeResp = await fetch('/optimize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: groupLocs })
          });
          const optimizeData = await optimizeResp.json();
          
          if (!optimizeData.error && optimizeData.route) {
            optimizedLocs = optimizeData.route;
          }
            return optimizeData;
        } catch (e) {
          console.error(`ä¼˜åŒ–ç½‘ç»„ ${groupName} è·¯çº¿å¤±è´¥:`, e);
            return null;
        }
        })();
        
        // å…ˆç»˜åˆ¶è·¯çº¿ï¼ˆåŠ ç²—ï¼Œé¢œè‰²åˆ†æ˜ï¼‰ï¼Œç¡®ä¿è·¯çº¿åœ¨åº•å±‚
        const routePromise = optimizePromise.then(async (optimizeData) => {
          if (optimizeData && !optimizeData.error && optimizeData.polyline) {
            try {
            const routePoints = optimizeData.polyline.map(p => new BMap.Point(p[0], p[1]));
            const polyline = new BMap.Polyline(routePoints, {
              strokeColor: groupColor,
              strokeWeight: 4,  // è·¯çº¿çº¿æ¡ï¼ˆç¨å¾®ç»†ä¸€ç‚¹ï¼‰
              strokeOpacity: 0.9
            });
            map.addOverlay(polyline);
            overlays.push(polyline);
              
              // ç­‰å¾…è·¯çº¿æ¸²æŸ“åˆ°åœ°å›¾ä¸Š
              await new Promise(resolve => setTimeout(resolve, 200));
              console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ ç½‘ç»„ ${groupName} è·¯çº¿å·²ç»˜åˆ¶å¹¶æ¸²æŸ“å®Œæˆ`);
        } catch (e) {
          console.error(`[è¡Œæ”¿åŒºå›¾] ç»˜åˆ¶ç½‘ç»„ ${groupName} è·¯çº¿å¤±è´¥:`, e);
        }
          }
          return optimizeData;
        });
        
        routePromises.push(routePromise);
        
        // åç»˜åˆ¶ç½‘ç‚¹ï¼ˆä½¿ç”¨ç™¾åº¦åœ°å›¾é»˜è®¤Markeræ ·å¼ï¼‰ï¼Œç¡®ä¿æ ‡è®°åœ¨ä¸Šå±‚æ˜¾ç¤º
        optimizePromise.then((optimizeData) => {
          const locsToUse = (optimizeData && !optimizeData.error && optimizeData.route) ? optimizeData.route : groupLocs;
          locsToUse.forEach((loc, idx) => {
          const pt = new BMap.Point(loc.lng, loc.lat);
          
          // ä½¿ç”¨ç™¾åº¦åœ°å›¾JS APIè‡ªå¸¦çš„é»˜è®¤Markeræ ·å¼
          const marker = new BMap.Marker(pt);
          map.addOverlay(marker);
          markers.push(marker);
        });
          console.log(`[è¡Œæ”¿åŒºå›¾] ç½‘ç»„ ${groupName} å·²ç»˜åˆ¶ ${locsToUse.length} ä¸ªç½‘ç‚¹æ ‡è®°`);
        });
      }
      
      // ç­‰å¾…æ‰€æœ‰ç½‘ç»„è·¯çº¿åŠ è½½å’Œæ¸²æŸ“å®Œæˆ
      console.log(`[è¡Œæ”¿åŒºå›¾] ç­‰å¾…æ‰€æœ‰ ${routePromises.length} ä¸ªç½‘ç»„çš„è·¯çº¿åŠ è½½å®Œæˆ...`);
      await Promise.all(routePromises);
      console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æ‰€æœ‰è·¯çº¿å·²åŠ è½½å®Œæˆ`);
      
      // é¢å¤–ç­‰å¾…ç¡®ä¿åœ°å›¾å®Œå…¨æ¸²æŸ“
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // ç°åœ¨ç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼ˆåœ¨è·¯çº¿å’Œç½‘ç‚¹ä¹‹ä¸Šï¼‰
      // å¦‚æœæä¾›äº†å¿åŒºå­—æ®µï¼Œç»˜åˆ¶æ‰€æœ‰ç½‘ç»„æ‰€åœ¨å¿åŒºçš„è¾¹ç•Œï¼›å¦åˆ™ç»˜åˆ¶æŸ¥è¯¢åˆ°çš„è¡Œæ”¿åŒºè¾¹ç•Œ
      console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹ç»˜åˆ¶è¡Œæ”¿åŒºè¾¹ç•Œï¼Œå…± ${Object.keys(districtsMap).length} ä¸ªè¡Œæ”¿åŒº`);
      
      const districtPolygons = [];
      const boundaryPromises = [];
      let colorIndex = 0;
      
      for (const [districtName, districtLocs] of Object.entries(districtsMap)) {
          const color = districtColors[colorIndex % districtColors.length];
          colorIndex++;
          
          console.log(`[è¡Œæ”¿åŒºå›¾] å¤„ç†è¡Œæ”¿åŒº: ${districtName}`);
          
          // å¦‚æœä½¿ç”¨å¿åŒºå­—æ®µï¼Œç›´æ¥ä½¿ç”¨å­—æ®µå€¼ï¼›å¦åˆ™å°è¯•ä¸åŒçš„åç§°æ ¼å¼
          let nameVariants = [];
          
          if (useDistrictField) {
            // ä½¿ç”¨å¿åŒºå­—æ®µæä¾›çš„åç§°ï¼Œç›´æ¥ä½¿ç”¨
            nameVariants.push(districtName);
            // ä¹Ÿå¯ä»¥å°è¯•ä¸€äº›å¸¸è§å˜ä½“ï¼ˆå»æ‰çœã€å¸‚ç­‰å‰ç¼€ï¼‰
            const nameWithoutProvince = districtName.replace(/^[^çœ]+çœ/, '').replace(/^[^å¸‚]+å¸‚/, '');
            if (nameWithoutProvince && nameWithoutProvince !== districtName) {
              nameVariants.push(nameWithoutProvince);
            }
            // å°è¯•å»æ‰"åŒº"ã€"å¿"ã€"å¸‚"åç¼€åçš„åç§°
            const nameWithoutSuffix = districtName.replace(/[åŒºå¿å¸‚]$/, '');
            if (nameWithoutSuffix && nameWithoutSuffix !== districtName) {
              nameVariants.push(nameWithoutSuffix);
            }
          } else {
            // å¦‚æœæ²¡æœ‰å¿åŒºå­—æ®µï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘ï¼šå°è¯•ä¸åŒçš„åç§°æ ¼å¼
            if (districtLocs && districtLocs.length > 0) {
              const firstDist = districtLocs[0];
              
              // ä¼˜å…ˆå°è¯•åŒºå¿åï¼ˆæœ€å¸¸ç”¨ï¼‰
              if (firstDist.district_level) {
                nameVariants.push(firstDist.district_level);  // "å»ºé‚ºåŒº"
              }
              
              // å°è¯•å¸‚+åŒºå¿
              if (firstDist.city && firstDist.district_level) {
                const cityName = firstDist.city.replace('å¸‚', '');
                nameVariants.push(cityName + firstDist.district_level);  // "å—äº¬å»ºé‚ºåŒº"
                nameVariants.push(firstDist.city + firstDist.district_level);  // "å—äº¬å¸‚å»ºé‚ºåŒº"
              }
            }
            
            // æœ€åå°è¯•å®Œæ•´æ ¼å¼
            nameVariants.push(districtName);  // "æ±Ÿè‹å—äº¬å¸‚å»ºé‚ºåŒº"
          }
          
          // å»é‡
          const uniqueVariants = [...new Set(nameVariants)];
          console.log(`[è¡Œæ”¿åŒºå›¾] å°†å°è¯•çš„åç§°æ ¼å¼:`, uniqueVariants);
          
          // ä½¿ç”¨PromiseåŒ…è£…Boundary APIè°ƒç”¨ï¼ˆå‚è€ƒxzqh.htmlçš„å®ç°æ–¹å¼ï¼‰
          const boundaryPromise = new Promise((resolve) => {
            let boundaryFound = false;
            let attemptIndex = 0;
            let polygonsForThisDistrict = [];  // è®°å½•è¿™ä¸ªè¡Œæ”¿åŒºç»˜åˆ¶çš„å¤šè¾¹å½¢
            
            const tryGetBoundary = (nameToTry) => {
              console.log(`[è¡Œæ”¿åŒºå›¾] å°è¯•è·å–è¾¹ç•Œ: ${nameToTry}`);
              const boundary = new BMap.Boundary();
              boundary.get(nameToTry, (rs) => {
                console.log(`[è¡Œæ”¿åŒºå›¾] Boundary APIè¿”å›ç»“æœ:`, rs);
                if (rs && rs.boundaries && rs.boundaries.length > 0) {
                  console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æˆåŠŸè·å– ${nameToTry} çš„è¾¹ç•Œï¼Œå…± ${rs.boundaries.length} ä¸ªè¾¹ç•Œ`);
                  boundaryFound = true;
                  
                  // å‚è€ƒxzqh.htmlï¼šç›´æ¥ä½¿ç”¨boundaries[i]ä½œä¸ºå‚æ•°ä¼ ç»™Polygon
                  for (let i = 0; i < rs.boundaries.length; i++) {
                    try {
                      const polygon = new BMap.Polygon(rs.boundaries[i], {
                        strokeWeight: 3,
                        strokeColor: color,
                        strokeOpacity: 0.9,
                        fillOpacity: 0,  // ä¸å¡«å……ï¼Œåªæ˜¾ç¤ºè¾¹ç•Œçº¿
                        strokeStyle: "solid"
                      });
                      map.addOverlay(polygon);
                      overlays.push(polygon);  // æ·»åŠ åˆ°overlaysæ•°ç»„ï¼Œç¡®ä¿clearMap()èƒ½æ¸…é™¤
                      districtPolygons.push(polygon);
                      polygonsForThisDistrict.push(polygon);  // è®°å½•è¿™ä¸ªè¡Œæ”¿åŒºçš„å¤šè¾¹å½¢
                      console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æˆåŠŸç»˜åˆ¶å¤šè¾¹å½¢ ${i + 1}/${rs.boundaries.length} (${districtName})`);
                    } catch (polyErr) {
                      console.error(`[è¡Œæ”¿åŒºå›¾] âŒ ç»˜åˆ¶å¤šè¾¹å½¢ ${i + 1} å¤±è´¥:`, polyErr);
                    }
                  }
                  
                  // éªŒè¯å¤šè¾¹å½¢æ˜¯å¦çœŸçš„æ·»åŠ æˆåŠŸ
                  if (polygonsForThisDistrict.length > 0) {
                    console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ ${districtName} æˆåŠŸç»˜åˆ¶ ${polygonsForThisDistrict.length} ä¸ªå¤šè¾¹å½¢`);
                  } else {
                    console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ${districtName} è™½ç„¶è·å–åˆ°è¾¹ç•Œï¼Œä½†æ²¡æœ‰æˆåŠŸç»˜åˆ¶ä»»ä½•å¤šè¾¹å½¢`);
                  }
                  
                  resolve();
                } else {
                  // å¦‚æœå½“å‰åç§°æ ¼å¼å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª
                  attemptIndex++;
                  if (attemptIndex < uniqueVariants.length && !boundaryFound) {
                    console.log(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ${nameToTry} æœªæ‰¾åˆ°è¾¹ç•Œ (boundaries: ${rs?.boundaries?.length || 0})ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæ ¼å¼...`);
                    tryGetBoundary(uniqueVariants[attemptIndex]);
                  } else {
                    console.log(`[è¡Œæ”¿åŒºå›¾] âŒ æ‰€æœ‰æ ¼å¼éƒ½å¤±è´¥ï¼Œæ— æ³•è·å– ${districtName} çš„è¾¹ç•Œ`);
                    console.log(`[è¡Œæ”¿åŒºå›¾] å°è¯•è¿‡çš„åç§°æ ¼å¼:`, uniqueVariants);
                    console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ${districtName} çš„è¾¹ç•Œç»˜åˆ¶å¤±è´¥ï¼Œè¯¥è¡Œæ”¿åŒºå°†æ²¡æœ‰è¾¹ç•Œæ˜¾ç¤º`);
                    resolve();  // å³ä½¿å¤±è´¥ä¹Ÿresolveï¼Œä¸é˜»å¡å…¶ä»–è¡Œæ”¿åŒºçš„ç»˜åˆ¶
                  }
                }
              });
            };
            
            // å¼€å§‹å°è¯•ç¬¬ä¸€ä¸ªåç§°æ ¼å¼
            if (uniqueVariants.length > 0) {
              tryGetBoundary(uniqueVariants[0]);
            } else {
              // å¦‚æœæ²¡æœ‰å¯ç”¨çš„åç§°å˜ä½“ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹åç§°
              tryGetBoundary(districtName);
            }
          });
          boundaryPromises.push(boundaryPromise);
        }
        
        // ç­‰å¾…æ‰€æœ‰è¾¹ç•Œç»˜åˆ¶å®Œæˆ
        console.log(`[è¡Œæ”¿åŒºå›¾] ç­‰å¾…æ‰€æœ‰ ${boundaryPromises.length} ä¸ªè¡Œæ”¿åŒºçš„è¾¹ç•Œç»˜åˆ¶å®Œæˆ...`);
        await Promise.all(boundaryPromises);
        console.log(`[è¡Œæ”¿åŒºå›¾] æ‰€æœ‰è¾¹ç•ŒPromiseå·²å®Œæˆï¼Œå·²ç»˜åˆ¶ ${districtPolygons.length} ä¸ªå¤šè¾¹å½¢`);
        
        // é¢å¤–ç­‰å¾…ï¼Œç¡®ä¿æ‰€æœ‰å¤šè¾¹å½¢éƒ½å·²ç»æ¸²æŸ“åˆ°åœ°å›¾ä¸Š
        // ç™¾åº¦åœ°å›¾çš„addOverlayæ˜¯å¼‚æ­¥çš„ï¼Œéœ€è¦ç­‰å¾…åœ°å›¾æ¸²æŸ“å®Œæˆ
        console.log(`[è¡Œæ”¿åŒºå›¾] ç­‰å¾…åœ°å›¾æ¸²æŸ“å¤šè¾¹å½¢ï¼ˆç¬¬1æ¬¡ç­‰å¾…ï¼Œ2ç§’ï¼‰...`);
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // éªŒè¯å¤šè¾¹å½¢æ˜¯å¦çœŸçš„æ·»åŠ åˆ°äº†åœ°å›¾ä¸Š
        const polygonOverlaysAfterFirstWait = overlays.filter(overlay => {
          try {
            return overlay && overlay.getPath && typeof overlay.getPath === 'function';
          } catch (e) {
            return false;
          }
        });
        console.log(`[è¡Œæ”¿åŒºå›¾] ç¬¬1æ¬¡ç­‰å¾…åï¼Œåœ°å›¾ä¸Šæœ‰ ${polygonOverlaysAfterFirstWait.length} ä¸ªå¤šè¾¹å½¢`);
        
        // å¦‚æœå¤šè¾¹å½¢æ•°é‡ä¸è¶³ï¼Œå†ç­‰å¾…ä¸€æ¬¡
        const expectedDistrictsCountForWait = Object.keys(districtsMap).length;
        if (polygonOverlaysAfterFirstWait.length < expectedDistrictsCountForWait && polygonOverlaysAfterFirstWait.length < districtPolygons.length) {
          console.log(`[è¡Œæ”¿åŒºå›¾] å¤šè¾¹å½¢æ•°é‡ä¸è¶³ï¼Œå†æ¬¡ç­‰å¾…3ç§’ä»¥ç¡®ä¿æ¸²æŸ“å®Œæˆ...`);
          await new Promise(resolve => setTimeout(resolve, 3000));
        }
        
        // éªŒè¯å¤šè¾¹å½¢æ˜¯å¦çœŸçš„æ·»åŠ åˆ°äº†åœ°å›¾ä¸Šï¼ˆé€šè¿‡æ£€æŸ¥overlaysæ•°ç»„ï¼‰
        const polygonOverlays = overlays.filter(overlay => {
          try {
            // æ£€æŸ¥æ˜¯å¦æ˜¯Polygonç±»å‹
            return overlay && overlay.getPath && typeof overlay.getPath === 'function';
          } catch (e) {
            return false;
          }
        });
        console.log(`[è¡Œæ”¿åŒºå›¾] éªŒè¯ï¼šåœ°å›¾ä¸Šå…±æœ‰ ${polygonOverlays.length} ä¸ªå¤šè¾¹å½¢è¦†ç›–ç‰©`);
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰é¢„æœŸçš„è¡Œæ”¿åŒºéƒ½æœ‰å¯¹åº”çš„å¤šè¾¹å½¢
        const expectedDistrictsCount = Object.keys(districtsMap).length;
        if (polygonOverlays.length < expectedDistrictsCount) {
          console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ è­¦å‘Šï¼šé¢„æœŸ ${expectedDistrictsCount} ä¸ªè¡Œæ”¿åŒºï¼Œä½†åªç»˜åˆ¶äº† ${polygonOverlays.length} ä¸ªå¤šè¾¹å½¢`);
          console.warn(`[è¡Œæ”¿åŒºå›¾] å·²ç»˜åˆ¶çš„å¤šè¾¹å½¢æ•°é‡: ${districtPolygons.length}ï¼Œåœ°å›¾ä¸Šçš„å¤šè¾¹å½¢æ•°é‡: ${polygonOverlays.length}`);
          
          // åˆ—å‡ºå·²ç»˜åˆ¶çš„è¡Œæ”¿åŒº
          const drawnDistricts = new Set();
          districtPolygons.forEach((polygon, idx) => {
            try {
              const path = polygon.getPath();
              if (path && path.length > 0) {
                drawnDistricts.add(`å¤šè¾¹å½¢${idx + 1}`);
              }
            } catch (e) {
              // å¿½ç•¥é”™è¯¯
            }
          });
          console.log(`[è¡Œæ”¿åŒºå›¾] å·²ç»˜åˆ¶çš„å¤šè¾¹å½¢: ${Array.from(drawnDistricts).join(', ')}`);
        } else {
          console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æ‰€æœ‰ ${expectedDistrictsCount} ä¸ªè¡Œæ”¿åŒºéƒ½æœ‰å¯¹åº”çš„å¤šè¾¹å½¢`);
        }
        
        // å†æ¬¡ç­‰å¾…ä¸€ä¸‹ï¼Œç¡®ä¿åœ°å›¾å®Œå…¨æ¸²æŸ“
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // æ”¶é›†æ‰€æœ‰è¾¹ç•Œç‚¹ï¼Œç”¨äºæœ€ç»ˆè°ƒæ•´è§†é‡
        const allBoundaryPoints = [];
        districtPolygons.forEach((polygon, idx) => {
          try {
            const path = polygon.getPath();
            if (path && path.length > 0) {
              path.forEach(point => {
                allBoundaryPoints.push(point);
              });
              console.log(`[è¡Œæ”¿åŒºå›¾] å¤šè¾¹å½¢ ${idx + 1} æœ‰ ${path.length} ä¸ªç‚¹`);
            } else {
              console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ å¤šè¾¹å½¢ ${idx + 1} æ²¡æœ‰è·¯å¾„ç‚¹`);
            }
          } catch (e) {
            console.error(`[è¡Œæ”¿åŒºå›¾] è·å–è¾¹ç•Œç‚¹å¤±è´¥ (å¤šè¾¹å½¢ ${idx + 1}):`, e);
          }
        });
        console.log(`[è¡Œæ”¿åŒºå›¾] æ€»å…±æ”¶é›†åˆ° ${allBoundaryPoints.length} ä¸ªè¾¹ç•Œç‚¹`);
        
        // å¦‚æœè¾¹ç•Œç‚¹æ•°é‡ä¸º0ï¼Œè¯´æ˜æ²¡æœ‰æˆåŠŸç»˜åˆ¶ä»»ä½•è¾¹ç•Œï¼Œç»™å‡ºè­¦å‘Š
        if (allBoundaryPoints.length === 0) {
          console.error(`[è¡Œæ”¿åŒºå›¾] âŒ é”™è¯¯ï¼šæ²¡æœ‰æ”¶é›†åˆ°ä»»ä½•è¾¹ç•Œç‚¹ï¼å¯èƒ½æ‰€æœ‰è¾¹ç•Œç»˜åˆ¶éƒ½å¤±è´¥äº†`);
          console.error(`[è¡Œæ”¿åŒºå›¾] é¢„æœŸè¡Œæ”¿åŒºæ•°é‡: ${expectedDistrictsCount}ï¼Œå®é™…ç»˜åˆ¶çš„å¤šè¾¹å½¢æ•°é‡: ${districtPolygons.length}`);
          // å¯ä»¥é€‰æ‹©æ˜¯å¦ç»§ç»­æˆªå›¾ï¼Œæˆ–è€…æŠ›å‡ºé”™è¯¯
          // è¿™é‡Œé€‰æ‹©ç»§ç»­ï¼Œä½†ä¼šç»™å‡ºæ˜ç¡®çš„è­¦å‘Š
        }
        
        // åˆå¹¶æ‰€æœ‰ç‚¹ï¼ˆç½‘ç‚¹ + è¾¹ç•Œç‚¹ï¼‰ç”¨äºè°ƒæ•´è§†é‡
        const allPoints = allLocations.map(loc => new BMap.Point(loc.lng, loc.lat));
        const combinedPoints = [...allPoints, ...allBoundaryPoints];
        
        // ç­‰å¾…ä¸€ä¸‹ç¡®ä¿æ‰€æœ‰è¦†ç›–ç‰©éƒ½å·²æ·»åŠ 
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // è°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬è¡Œæ”¿è¾¹ç•Œï¼‰
        // ç›®æ ‡ï¼šç¡®ä¿æ‰€æœ‰å¿åŒºçš„æ‰€æœ‰è¾¹æ¡†éƒ½åœ¨è§†é‡èŒƒå›´å†…
        const maxZoom = 15;  // æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼Œé¿å…è¿‡è¿‘
        const minZoom = 8;   // æœ€å°ç¼©æ”¾çº§åˆ«ï¼Œç¡®ä¿èƒ½åŒ…å«æ›´å¤§çš„åŒºåŸŸ
        
        // æ§åˆ¶é¢æ¿ä½ç½®ï¼šleft: 20px, top: 20px, max-width: 380px
        const panelLeft = 20;
        const panelTop = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth;
        const viewPadding = 50;  // è§†é‡è¾¹è·ï¼Œç¡®ä¿è¾¹ç•Œä¸ä¼šè¢«è£åˆ‡
        
        // è®¡ç®—æ‰€æœ‰ç‚¹çš„è¾¹ç•Œæ¡†
        const calculateBounds = (points) => {
          if (points.length === 0) return null;
          
          let minLng = points[0].lng;
          let maxLng = points[0].lng;
          let minLat = points[0].lat;
          let maxLat = points[0].lat;
          
          points.forEach(pt => {
            minLng = Math.min(minLng, pt.lng);
            maxLng = Math.max(maxLng, pt.lng);
            minLat = Math.min(minLat, pt.lat);
            maxLat = Math.max(maxLat, pt.lat);
          });
          
          return { minLng, maxLng, minLat, maxLat };
        };
        
        // æ£€æŸ¥æ‰€æœ‰è¾¹ç•Œç‚¹æ˜¯å¦éƒ½åœ¨è§†é‡å†…ï¼ˆè€ƒè™‘æ§åˆ¶é¢æ¿å’Œè¾¹è·ï¼‰
        const checkAllPointsVisible = (points, bounds) => {
          if (!bounds || points.length === 0) return false;
          
          const mapRect = map.getContainer().getBoundingClientRect();
          const effectiveLeft = panelRight + viewPadding;
          const effectiveRight = mapRect.width - viewPadding;
          const effectiveTop = viewPadding;
          const effectiveBottom = mapRect.height - viewPadding;
          
          // å°†æ‰€æœ‰è¾¹ç•Œç‚¹è½¬æ¢ä¸ºå±å¹•åæ ‡ï¼Œæ£€æŸ¥æ˜¯å¦éƒ½åœ¨æœ‰æ•ˆè§†é‡å†…
          for (const pt of points) {
            try {
              const pixel = map.pointToPixel(pt);
              const screenX = pixel.x;
              const screenY = pixel.y;
              
              // æ£€æŸ¥æ˜¯å¦åœ¨æœ‰æ•ˆè§†é‡åŒºåŸŸå†…
              if (screenX < effectiveLeft || screenX > effectiveRight || 
                  screenY < effectiveTop || screenY > effectiveBottom) {
                return false;
              }
            } catch (e) {
              // è½¬æ¢å¤±è´¥ï¼Œè®¤ä¸ºä¸åœ¨è§†é‡å†…
              return false;
            }
          }
          
          return true;
        };
        
        // æ ¹æ®è¾¹ç•Œæ¡†è®¾ç½®åœ°å›¾è§†é‡
        const setViewportFromBounds = (bounds, padding = 0.1) => {
          // padding æ˜¯ç›¸å¯¹äºè¾¹ç•Œæ¡†çš„ç™¾åˆ†æ¯”è¾¹è·ï¼ˆä¾‹å¦‚ 0.1 è¡¨ç¤ºå¢åŠ 10%çš„è¾¹è·ï¼‰
          const lngRange = bounds.maxLng - bounds.minLng;
          const latRange = bounds.maxLat - bounds.minLat;
          
          // è®¡ç®—å¸¦è¾¹è·çš„è¾¹ç•Œ
          const paddedMinLng = bounds.minLng - lngRange * padding;
          const paddedMaxLng = bounds.maxLng + lngRange * padding;
          const paddedMinLat = bounds.minLat - latRange * padding;
          const paddedMaxLat = bounds.maxLat + latRange * padding;
          
          // è®¡ç®—ä¸­å¿ƒç‚¹
          const centerLng = (paddedMinLng + paddedMaxLng) / 2;
          const centerLat = (paddedMinLat + paddedMaxLat) / 2;
          const center = new BMap.Point(centerLng, centerLat);
          
          // è®¾ç½®ä¸­å¿ƒ
          map.setCenter(center);
          
          // è®¡ç®—åˆé€‚çš„ç¼©æ”¾çº§åˆ«
          const mapRect = map.getContainer().getBoundingClientRect();
          const effectiveWidth = mapRect.width - panelRight - viewPadding * 2;
          const effectiveHeight = mapRect.height - viewPadding * 2;
          
          // è®¡ç®—éœ€è¦çš„ç¼©æ”¾çº§åˆ«
          const lngZoom = Math.log2(360 * effectiveWidth / 256 / (paddedMaxLng - paddedMinLng));
          const latZoom = Math.log2(360 * effectiveHeight / 256 / (paddedMaxLat - paddedMinLat));
          let zoom = Math.floor(Math.min(lngZoom, latZoom));
          
          // é™åˆ¶åœ¨åˆç†èŒƒå›´å†…ï¼ˆåˆå§‹è®¾ç½®æ—¶ç¨å¾®ä¿å®ˆä¸€ç‚¹ï¼Œåé¢ä¼šå°è¯•æ”¾å¤§ï¼‰
          zoom = Math.max(minZoom, Math.min(maxZoom, zoom));
          
          // ç¨å¾®ç¼©å°ä¸€ç‚¹ä½œä¸ºåˆå§‹å€¼ï¼Œåé¢ä¼šå°è¯•åœ¨å¯è§çš„å‰æä¸‹å°½å¯èƒ½æ”¾å¤§
          zoom = Math.max(minZoom, zoom - 1);
          
          map.setZoom(zoom);
        };
        
        if (allBoundaryPoints.length > 0) {
          // ä¼˜å…ˆä½¿ç”¨è¾¹ç•Œç‚¹è®¡ç®—è§†é‡ï¼Œç¡®ä¿æ‰€æœ‰å¿åŒºè¾¹æ¡†éƒ½åœ¨è§†é‡å†…
          console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨è¾¹ç•Œç‚¹è°ƒæ•´è§†é‡ï¼Œç¡®ä¿æ‰€æœ‰ ${allBoundaryPoints.length} ä¸ªè¾¹ç•Œç‚¹éƒ½åœ¨è§†é‡å†…`);
          
          // è®¡ç®—è¾¹ç•Œæ¡†ï¼ˆåªä½¿ç”¨è¾¹ç•Œç‚¹ï¼Œå› ä¸ºè¿™æ˜¯æœ€é‡è¦çš„ï¼‰
          const bounds = calculateBounds(allBoundaryPoints);
          
          if (bounds) {
            // è®¾ç½®åˆå§‹è§†é‡ï¼ˆä½¿ç”¨è¾¹ç•Œç‚¹ï¼Œå¸¦10%è¾¹è·ï¼‰
            setViewportFromBounds(bounds, 0.15);  // 15%çš„è¾¹è·ï¼Œç¡®ä¿æ‰€æœ‰è¾¹ç•Œéƒ½åœ¨è§†é‡å†…
          await new Promise(resolve => setTimeout(resolve, 500));
            
            // éªŒè¯æ‰€æœ‰è¾¹ç•Œç‚¹æ˜¯å¦éƒ½åœ¨è§†é‡å†…
          let currentZoom = map.getZoom();
            let allVisible = checkAllPointsVisible(allBoundaryPoints, bounds);
            let attempts = 0;
            const maxAttempts = 10;
          
            // å¦‚æœä¸åœ¨è§†é‡å†…ï¼Œé€æ­¥ç¼©å°ç›´åˆ°æ‰€æœ‰ç‚¹éƒ½åœ¨è§†é‡å†…
            while (!allVisible && currentZoom > minZoom && attempts < maxAttempts) {
            currentZoom = Math.max(minZoom, currentZoom - 1);
            map.setZoom(currentZoom);
            await new Promise(resolve => setTimeout(resolve, 300));
              
              // é‡æ–°è®¡ç®—è¾¹ç•Œæ¡†ï¼ˆå› ä¸ºè§†é‡å˜äº†ï¼‰
              const newBounds = calculateBounds(allBoundaryPoints);
              allVisible = checkAllPointsVisible(allBoundaryPoints, newBounds);
              
              console.log(`[è¡Œæ”¿åŒºå›¾] å°è¯•ç¼©æ”¾çº§åˆ« ${currentZoom}ï¼Œæ‰€æœ‰è¾¹ç•Œç‚¹å¯è§: ${allVisible}`);
              attempts++;
            }
            
            if (allVisible) {
              console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æ‰€æœ‰è¾¹ç•Œç‚¹éƒ½åœ¨è§†é‡å†…ï¼Œå½“å‰ç¼©æ”¾çº§åˆ«: ${currentZoom}`);
              
              // åœ¨ç¡®ä¿æ‰€æœ‰è¾¹ç•Œç‚¹å¯è§çš„å‰æä¸‹ï¼Œé€æ­¥å°è¯•å¢å¤§ç¼©æ”¾çº§åˆ«ï¼Œæ‰¾åˆ°æœ€å¤§å¯ç”¨ç¼©æ”¾çº§åˆ«
            let bestZoom = currentZoom;
              console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹å°è¯•æ”¾å¤§ï¼Œä»ç¼©æ”¾çº§åˆ« ${currentZoom} å¼€å§‹ï¼Œæœ€å¤§ç¼©æ”¾çº§åˆ«: ${maxZoom}`);
              
              // ä»å½“å‰ç¼©æ”¾çº§åˆ«å¼€å§‹ï¼Œé€æ­¥å°è¯•å¢å¤§
            for (let testZoom = currentZoom + 1; testZoom <= maxZoom; testZoom++) {
              map.setZoom(testZoom);
                await new Promise(resolve => setTimeout(resolve, 300));
              
                // æ£€æŸ¥æ‰€æœ‰è¾¹ç•Œç‚¹æ˜¯å¦ä»ç„¶å¯è§
                const newBounds = calculateBounds(allBoundaryPoints);
                const stillVisible = checkAllPointsVisible(allBoundaryPoints, newBounds);
              
                if (stillVisible) {
                bestZoom = testZoom;
                  console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šæ‰€æœ‰è¾¹ç•Œç‚¹ä»ç„¶å¯è§ï¼Œå¯ä»¥ç»§ç»­æ”¾å¤§`);
              } else {
                  // å¦‚æœæ”¾å¤§åä¸å¯è§ï¼Œå›é€€åˆ°ä¸Šä¸€ä¸ªå¯ç”¨çš„ç¼©æ”¾çº§åˆ«
                  console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šéƒ¨åˆ†è¾¹ç•Œç‚¹ä¸å¯è§ï¼Œå›é€€åˆ° ${bestZoom}`);
                map.setZoom(bestZoom);
                  await new Promise(resolve => setTimeout(resolve, 300));
                break;
              }
            }
              
              currentZoom = bestZoom;
              console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${currentZoom}ï¼ˆç¡®ä¿æ‰€æœ‰è¾¹ç•Œç‚¹å¯è§çš„æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼‰`);
            } else {
              console.log(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ç»è¿‡ ${attempts} æ¬¡å°è¯•ï¼Œéƒ¨åˆ†è¾¹ç•Œç‚¹å¯èƒ½ä¸åœ¨è§†é‡å†…ï¼Œå½“å‰ç¼©æ”¾çº§åˆ«: ${currentZoom}`);
            }
            
            // å¦‚æœè¿˜æœ‰ç½‘ç‚¹ï¼Œä¹Ÿæ£€æŸ¥ç½‘ç‚¹æ˜¯å¦åœ¨è§†é‡å†…ï¼ˆå¯é€‰ï¼‰
            if (allPoints.length > 0) {
              const newBounds = calculateBounds(allBoundaryPoints);
              let allPointsVisible = checkAllPointsVisible(allPoints, newBounds);
              
              // å¦‚æœç½‘ç‚¹ä¸åœ¨è§†é‡å†…ï¼Œç¨å¾®ç¼©å°ä¸€ç‚¹ï¼Œä½†è¦ç¡®ä¿ä»ç„¶å°½å¯èƒ½å¤§
              if (!allPointsVisible && currentZoom > minZoom) {
              currentZoom = Math.max(minZoom, currentZoom - 1);
              map.setZoom(currentZoom);
                await new Promise(resolve => setTimeout(resolve, 300));
                console.log(`[è¡Œæ”¿åŒºå›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«ä»¥åŒ…å«æ‰€æœ‰ç½‘ç‚¹: ${currentZoom}`);
                
                // å†æ¬¡éªŒè¯æ‰€æœ‰è¾¹ç•Œç‚¹ä»ç„¶å¯è§
                const finalBounds = calculateBounds(allBoundaryPoints);
                const boundaryStillVisible = checkAllPointsVisible(allBoundaryPoints, finalBounds);
                if (!boundaryStillVisible) {
                  // å¦‚æœç¼©å°åè¾¹ç•Œç‚¹ä¸å¯è§ï¼Œè¿™æ˜¯ä¸åº”è¯¥å‘ç”Ÿçš„ï¼Œè®°å½•è­¦å‘Š
                  console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ ç¼©å°åè¾¹ç•Œç‚¹ä¸å¯è§ï¼Œéœ€è¦è¿›ä¸€æ­¥è°ƒæ•´`);
          }
              }
            }
          } else {
            // å¦‚æœè¾¹ç•Œæ¡†è®¡ç®—å¤±è´¥ï¼Œå›é€€åˆ°ä½¿ç”¨setViewport
            console.log(`[è¡Œæ”¿åŒºå›¾] è¾¹ç•Œæ¡†è®¡ç®—å¤±è´¥ï¼Œä½¿ç”¨setViewport`);
          map.setViewport(allBoundaryPoints);
          await new Promise(resolve => setTimeout(resolve, 500));
          
            // ç¼©å°ä¸€ç‚¹ç¡®ä¿è¾¹ç•Œå¯è§
            let currentZoom = map.getZoom();
          if (currentZoom > minZoom) {
            currentZoom = Math.max(minZoom, currentZoom - 1);
            map.setZoom(currentZoom);
            await new Promise(resolve => setTimeout(resolve, 300));
          }
          
            // å°è¯•åœ¨å¯è§çš„å‰æä¸‹å°½å¯èƒ½æ”¾å¤§
            let bestZoom = currentZoom;
            console.log(`[è¡Œæ”¿åŒºå›¾] å¼€å§‹å°è¯•æ”¾å¤§ï¼Œä»ç¼©æ”¾çº§åˆ« ${currentZoom} å¼€å§‹`);
            for (let testZoom = currentZoom + 1; testZoom <= maxZoom; testZoom++) {
              map.setZoom(testZoom);
              await new Promise(resolve => setTimeout(resolve, 300));
              
              // ç®€å•æ£€æŸ¥ï¼šä½¿ç”¨getBoundséªŒè¯æ˜¯å¦æ‰€æœ‰ç‚¹éƒ½åœ¨è§†é‡å†…
              try {
                const mapBounds = map.getBounds();
                let allInBounds = true;
                for (const pt of allBoundaryPoints) {
                  if (!mapBounds.containsPoint(pt)) {
                    allInBounds = false;
                    break;
                  }
                }
                
                if (allInBounds) {
                bestZoom = testZoom;
                  console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šæ‰€æœ‰è¾¹ç•Œç‚¹ä»ç„¶å¯è§ï¼Œå¯ä»¥ç»§ç»­æ”¾å¤§`);
              } else {
                  console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ« ${testZoom}ï¼šéƒ¨åˆ†è¾¹ç•Œç‚¹ä¸å¯è§ï¼Œå›é€€åˆ° ${bestZoom}`);
                map.setZoom(bestZoom);
                  await new Promise(resolve => setTimeout(resolve, 300));
                break;
              }
              } catch (e) {
                // å¦‚æœæ£€æŸ¥å¤±è´¥ï¼Œä¿æŒå½“å‰ç¼©æ”¾çº§åˆ«
                console.log(`[è¡Œæ”¿åŒºå›¾] æ£€æŸ¥å¤±è´¥ï¼Œå›é€€åˆ° ${bestZoom}`);
                map.setZoom(bestZoom);
                await new Promise(resolve => setTimeout(resolve, 300));
                break;
              }
            }
            console.log(`[è¡Œæ”¿åŒºå›¾] âœ“ æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${bestZoom}ï¼ˆç¡®ä¿æ‰€æœ‰è¾¹ç•Œç‚¹å¯è§çš„æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼‰`);
          }
          
          await new Promise(resolve => setTimeout(resolve, 500));
        } else if (allPoints.length > 0) {
          // å¦‚æœæ²¡æœ‰è¾¹ç•Œç‚¹ï¼Œä½¿ç”¨ç½‘ç‚¹è°ƒæ•´è§†é‡
          console.log(`[è¡Œæ”¿åŒºå›¾] ä½¿ç”¨ç½‘ç‚¹è°ƒæ•´è§†é‡ï¼Œå…± ${allPoints.length} ä¸ªç‚¹`);
          map.setViewport(allPoints);
          await new Promise(resolve => setTimeout(resolve, 500));
          let currentZoom = map.getZoom();
          
          if (currentZoom > maxZoom) {
            map.setZoom(maxZoom);
            console.log(`[è¡Œæ”¿åŒºå›¾] è°ƒæ•´ç¼©æ”¾çº§åˆ«: ${currentZoom} -> ${maxZoom}ï¼ˆé™åˆ¶æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼‰`);
          } else {
            console.log(`[è¡Œæ”¿åŒºå›¾] ç¼©æ”¾çº§åˆ«åˆé€‚: ${currentZoom}ï¼ˆç½‘ç‚¹æ•°é‡: ${allPoints.length}ï¼‰`);
          }
        }
        
        // ç­‰å¾…æ¸²æŸ“å®Œæˆ
        console.log('[è¡Œæ”¿åŒºå›¾] ç­‰å¾…åœ°å›¾æ¸²æŸ“å®Œæˆ...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // æœ€åéªŒè¯ï¼šæ£€æŸ¥æ˜¯å¦æœ‰è¾¹ç•Œå¤šè¾¹å½¢ï¼ˆåœ¨æˆªå›¾å‰ï¼‰
        const finalPolygonOverlays = overlays.filter(overlay => {
          try {
            return overlay && overlay.getPath && typeof overlay.getPath === 'function';
          } catch (e) {
            return false;
          }
        });
        const expectedDistrictsFinal = Object.keys(districtsMap).length;
        
        console.log(`[è¡Œæ”¿åŒºå›¾] æˆªå›¾å‰æœ€ç»ˆéªŒè¯ï¼šåœ°å›¾ä¸Šæœ‰ ${finalPolygonOverlays.length} ä¸ªè¾¹ç•Œå¤šè¾¹å½¢ï¼Œé¢„æœŸ ${expectedDistrictsFinal} ä¸ªè¡Œæ”¿åŒº`);
        
        if (finalPolygonOverlays.length === 0 && expectedDistrictsFinal > 0) {
          console.error(`[è¡Œæ”¿åŒºå›¾] âŒ ä¸¥é‡è­¦å‘Šï¼šæ²¡æœ‰ç»˜åˆ¶ä»»ä½•è¾¹ç•Œå¤šè¾¹å½¢å°±å¼€å§‹æˆªå›¾ï¼`);
          console.error(`[è¡Œæ”¿åŒºå›¾] é¢„æœŸ ${expectedDistrictsFinal} ä¸ªè¡Œæ”¿åŒºçš„è¾¹ç•Œï¼Œä½†åœ°å›¾ä¸Šæ²¡æœ‰ä»»ä½•å¤šè¾¹å½¢`);
          console.log(`[è¡Œæ”¿åŒºå›¾] ç­‰å¾…é¢å¤–3ç§’ï¼Œå¸Œæœ›è¾¹ç•Œèƒ½å¤Ÿæ¸²æŸ“...`);
          await new Promise(resolve => setTimeout(resolve, 3000));
          
          // å†æ¬¡æ£€æŸ¥
          const retryPolygonOverlays = overlays.filter(overlay => {
            try {
              return overlay && overlay.getPath && typeof overlay.getPath === 'function';
            } catch (e) {
              return false;
            }
          });
          console.log(`[è¡Œæ”¿åŒºå›¾] é‡è¯•åæ£€æŸ¥ï¼šåœ°å›¾ä¸Šæœ‰ ${retryPolygonOverlays.length} ä¸ªè¾¹ç•Œå¤šè¾¹å½¢`);
          
          if (retryPolygonOverlays.length === 0) {
            console.error(`[è¡Œæ”¿åŒºå›¾] âŒ é”™è¯¯ï¼šç»è¿‡é¢å¤–ç­‰å¾…åä»ç„¶æ²¡æœ‰è¾¹ç•Œå¤šè¾¹å½¢ï¼Œä½†å°†ç»§ç»­æˆªå›¾`);
            console.error(`[è¡Œæ”¿åŒºå›¾] è¿™å¯èƒ½å¯¼è‡´æˆªå›¾ä¸åŒ…å«ä»»ä½•åŒºè¾¹æ¡†ï¼Œè¯·æ£€æŸ¥ï¼š`);
            console.error(`[è¡Œæ”¿åŒºå›¾] 1. è¡Œæ”¿åŒºåç§°æ˜¯å¦æ­£ç¡®`);
            console.error(`[è¡Œæ”¿åŒºå›¾] 2. ç™¾åº¦åœ°å›¾APIæ˜¯å¦æ­£å¸¸`);
            console.error(`[è¡Œæ”¿åŒºå›¾] 3. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸`);
          }
        } else if (finalPolygonOverlays.length < expectedDistrictsFinal) {
          console.warn(`[è¡Œæ”¿åŒºå›¾] âš ï¸ è­¦å‘Šï¼šé¢„æœŸ ${expectedDistrictsFinal} ä¸ªè¡Œæ”¿åŒºï¼Œä½†åªç»˜åˆ¶äº† ${finalPolygonOverlays.length} ä¸ªè¾¹ç•Œ`);
          console.warn(`[è¡Œæ”¿åŒºå›¾] éƒ¨åˆ†è¡Œæ”¿åŒºçš„è¾¹ç•Œå¯èƒ½æœªç»˜åˆ¶æˆåŠŸï¼Œä½†å°†ç»§ç»­æˆªå›¾`);
        }
        
        // è°ƒè¯•æ¨¡å¼ä¸‹ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾
        if (debugMode) {
          console.log(`[è°ƒè¯•æ¨¡å¼] ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾è¡Œæ”¿åŒºå›¾ ${employeeId}...`);
          await waitForManualScreenshot({
            groupName: '__DISTRICT_MAP__',
            employeeId: employeeId,
            employeeName: employeeName,
            adjustment: adjustment,
            locations: []
          });
        } else {
        console.log('[è¡Œæ”¿åŒºå›¾] å¼€å§‹æˆªå›¾...');
        // æˆªå›¾ï¼ˆä½¿ç”¨ç‰¹æ®Šæ ‡è®°è¡¨ç¤ºè¿™æ˜¯è¡Œæ”¿åŒºå›¾ï¼‰
        // è¡Œæ”¿åŒºå›¾ä¸éœ€è¦adjustmentå­—æ®µ
        await captureScreenshot('__DISTRICT_MAP__', employeeId, employeeName, adjustment);
        console.log('[è¡Œæ”¿åŒºå›¾] æˆªå›¾å®Œæˆ');
        }
        
        // æˆªå›¾å®Œæˆåï¼Œæ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰è¦†ç›–ç‰©ï¼ˆè·¯çº¿ã€è¾¹æ¡†ã€ç½‘ç‚¹åœ†åœˆï¼‰ï¼Œé¿å…å½±å“ä¸‹ä¸€ä¸ªå‘˜å·¥
        console.log('[è¡Œæ”¿åŒºå›¾] æ¸…é™¤åœ°å›¾è¦†ç›–ç‰©ï¼Œå‡†å¤‡ä¸‹ä¸€ä¸ªå‘˜å·¥çš„æ•°æ®...');
        clearMap();
        // ç­‰å¾…æ¸…é™¤å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
        console.log('[è¡Œæ”¿åŒºå›¾] åœ°å›¾å·²æ¸…é™¤ï¼Œå¯ä»¥å¤„ç†ä¸‹ä¸€ä¸ªå‘˜å·¥çš„æ•°æ®');
        
    } catch (e) {
      console.error('ç»˜åˆ¶è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
      // å³ä½¿å‡ºé”™ä¹Ÿè¦æ¸…é™¤åœ°å›¾ï¼Œé¿å…å½±å“ä¸‹ä¸€ä¸ªå‘˜å·¥
      try {
        clearMap();
      } catch (clearErr) {
        console.error('æ¸…é™¤åœ°å›¾å¤±è´¥:', clearErr);
      }
      throw e;
    }
  }

  // ä»…æˆªå–è¡Œæ”¿åŒºå›¾ï¼ˆç»˜åˆ¶ç½‘ç‚¹ã€è·¯çº¿å’ŒåŒºè¾¹æ¡†ï¼‰- æ‰‹åŠ¨è°ƒç”¨
  async function captureDistrictMapOnly() {
    try {
      // è·å–å½“å‰åœ°å›¾ä¸Šçš„æ‰€æœ‰ç½‘ç‚¹æ•°æ®
      const locations = currentLocations.length > 0 ? currentLocations : parseLocationData();
      
      if (locations.length === 0) {
        showError('è¯·å…ˆå¯¼å…¥æˆ–è¾“å…¥ç½‘ç‚¹æ•°æ®ï¼');
        return;
      }
      
      // æŒ‰ç½‘ç»„åˆ†ç»„
      const groups = groupLocationsByGroup(locations);
      
      if (Object.keys(groups).length === 0) {
        showError('æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„ç½‘ç»„æ•°æ®ï¼');
        return;
      }
      
      // æ”¶é›†å·¥å·å’Œå§“åï¼ˆå¦‚æœæœ‰ï¼‰
      const firstLoc = locations[0];
      const employeeId = firstLoc.employee_id || '';
      const employeeName = firstLoc.employee_name || '';
      const adjustment = firstLoc.adjustment || '';
      
      // ä½¿ç”¨drawDistrictMapForEmployeeçš„é€»è¾‘æ¥ç»˜åˆ¶
      await drawDistrictMapForEmployee(employeeId, employeeName, groups, adjustment);
      
    } catch (e) {
      console.error('ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¤±è´¥:', e);
      showError('ä»…æˆªå–è¡Œæ”¿åŒºå›¾å¤±è´¥: ' + e.message);
    }
  }

    function colorByIndex(i, total) {
      return '#2196F3';
    }

    // åœ†åœˆæ ‡è®°å‚æ•°
    const MARKER_RADIUS = 17.5;  // åœ†åœˆåŠå¾„ï¼ˆåƒç´ ï¼‰
    const MARKER_BORDER = 3;      // è¾¹æ¡†å®½åº¦ï¼ˆåƒç´ ï¼‰
    const MARKER_TOTAL_RADIUS = MARKER_RADIUS + MARKER_BORDER;  // æ€»åŠå¾„ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
    const MARKER_MIN_DISTANCE = MARKER_TOTAL_RADIUS * 2 + 2;  // ä¸¤ä¸ªåœ†åœˆæ ‡è®°ä¹‹é—´çš„æœ€å°è·ç¦»ï¼ˆç¡®ä¿è¾¹æ¡†ä¸é‡å ï¼Œé¢å¤–2pxå®‰å…¨è¾¹è·ï¼‰

    // æ£€æµ‹å¹¶è°ƒæ•´åœ†åœˆæ ‡è®°ä½ç½®ï¼Œé¿å…è¾¹æ¡†é‡å 
    // è¿”å›ï¼š{ points: è°ƒæ•´åçš„åœ°ç†åæ ‡ç‚¹æ•°ç»„, offsets: åƒç´ åç§»é‡æ•°ç»„ }
    function adjustMarkerPositions(points) {
      if (!map || !points || points.length <= 1) {
        return { points: points || [], offsets: (points || []).map(() => ({ x: 0, y: 0 })) };
      }
      
      const originalPixels = [];  // åŸå§‹åƒç´ åæ ‡
      const adjustedPixels = [];   // è°ƒæ•´åçš„åƒç´ åæ ‡
      
      // å°†åœ°ç†åæ ‡è½¬æ¢ä¸ºåƒç´ åæ ‡
      for (let i = 0; i < points.length; i++) {
        const pixel = map.pointToPixel(points[i]);
        originalPixels.push({ x: pixel.x, y: pixel.y, index: i });
        adjustedPixels.push({ x: pixel.x, y: pixel.y, index: i });
      }
      
      // æ£€æµ‹å¹¶è°ƒæ•´é‡å çš„æ ‡è®°
      for (let i = 0; i < adjustedPixels.length; i++) {
        for (let j = i + 1; j < adjustedPixels.length; j++) {
          const p1 = adjustedPixels[i];
          const p2 = adjustedPixels[j];
          
          // è®¡ç®—ä¸¤ä¸ªæ ‡è®°ä¸­å¿ƒä¹‹é—´çš„è·ç¦»
          const distance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
          
          // å¦‚æœè·ç¦»å°äºæœ€å°è·ç¦»ï¼Œéœ€è¦è°ƒæ•´ä½ç½®
          if (distance < MARKER_MIN_DISTANCE) {
            // è®¡ç®—éœ€è¦ç§»åŠ¨çš„è·ç¦»
            const moveDistance = (MARKER_MIN_DISTANCE - distance) / 2 + 1;  // é¢å¤–1pxç¡®ä¿ä¸é‡å 
            
            // è®¡ç®—æ–¹å‘å‘é‡
            let dx = 0, dy = 0;
            if (distance > 0.001) {
              dx = (p2.x - p1.x) / distance;
              dy = (p2.y - p1.y) / distance;
            } else {
              // å¦‚æœä¸¤ä¸ªç‚¹å®Œå…¨é‡åˆï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªæ–¹å‘
              const angle = Math.random() * 2 * Math.PI;
              dx = Math.cos(angle);
              dy = Math.sin(angle);
            }
            
            // è°ƒæ•´ä½ç½®ï¼šä¸¤ä¸ªæ ‡è®°å‘ç›¸åæ–¹å‘ç§»åŠ¨
            // ä¼˜å…ˆæ°´å¹³æˆ–å‚ç›´æ–¹å‘ç§»åŠ¨ï¼ˆå¹¶æ’æ˜¾ç¤ºï¼‰
            if (Math.abs(dx) > Math.abs(dy)) {
              // æ°´å¹³æ–¹å‘ç§»åŠ¨
              p1.x -= moveDistance * Math.sign(dx);
              p2.x += moveDistance * Math.sign(dx);
            } else {
              // å‚ç›´æ–¹å‘ç§»åŠ¨
              p1.y -= moveDistance * Math.sign(dy);
              p2.y += moveDistance * Math.sign(dy);
            }
            
            console.log(`[æ ‡è®°è°ƒæ•´] æ ‡è®° ${i + 1} å’Œ ${j + 1} è·ç¦»è¿‡è¿‘ (${distance.toFixed(1)}px < ${MARKER_MIN_DISTANCE}px)ï¼Œå·²è°ƒæ•´ä½ç½®`);
          }
        }
      }
      
      // è®¡ç®—åƒç´ åç§»é‡
      const offsets = [];
      for (let i = 0; i < adjustedPixels.length; i++) {
        offsets.push({
          x: adjustedPixels[i].x - originalPixels[i].x,
          y: adjustedPixels[i].y - originalPixels[i].y
        });
      }
      
      // è¿”å›åŸå§‹åœ°ç†åæ ‡ç‚¹ï¼ˆä¸æ”¹å˜åœ°ç†åæ ‡ï¼Œåªæ”¹å˜æ˜¾ç¤ºä½ç½®ï¼‰
      return { points: points, offsets: offsets };
    }

    function createNumberMarker(point, number, total, offsetX = 0, offsetY = 0) {
      const markerContent = document.createElement('div');
      const bgColor = colorByIndex(number - 1, total);
      markerContent.style.cssText = `
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background: ${bgColor};
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        border: 3px solid white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        position: absolute;
        z-index: ${20000 + number};
        pointer-events: ${debugMode ? 'auto' : 'none'};
        cursor: pointer;
      `;
      markerContent.innerHTML = String(number);
      markerContent.setAttribute('data-marker-number', number);
      
      // è°ƒè¯•æ¨¡å¼ï¼šåŒå‡»ç¼–è¾‘åœ†åœˆæ•°å­—
      if (debugMode) {
        markerContent.title = 'åŒå‡»ç¼–è¾‘æ•°å­—';
        markerContent.ondblclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const currentNumber = markerContent.innerText || String(number);
          
          // åˆ›å»ºç¼–è¾‘è¾“å…¥æ¡†
          const input = document.createElement('input');
          input.type = 'text';
          input.value = currentNumber;
          input.style.cssText = `
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            background: #fff3e0;
            color: #333;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            outline: 2px solid #FF9800;
            padding: 0;
          `;
          
          markerContent.innerHTML = '';
          markerContent.appendChild(input);
          input.focus();
          input.select();
          
          const saveEdit = () => {
            const newValue = input.value.trim() || currentNumber;
            markerContent.innerHTML = newValue;
            console.log(`[è°ƒè¯•æ¨¡å¼] åœ†åœˆæ ‡è®°å·²ç¼–è¾‘: ${currentNumber} -> ${newValue}`);
          };
          
          input.onblur = saveEdit;
          input.onkeydown = (ke) => {
            if (ke.key === 'Enter') {
              ke.preventDefault();
              input.blur();
            } else if (ke.key === 'Escape') {
              input.value = currentNumber;
              input.blur();
            }
          };
        };
      }

      const icon = new BMap.Icon(
        "data:image/svg+xml;base64," + btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="1" height="1"></svg>`),
        new BMap.Size(1, 1)
      );

      const marker = new BMap.Marker(point, {
        icon,
        offset: new BMap.Size(0, 0),
        enableDragging: false
      });
      marker.setLabel(new BMap.Label('', { offset: new BMap.Size(-9999, -9999) }));

      function NumberMarkerOverlay(point, content, number, offsetX, offsetY) {
        this._point = point;
        this._content = content;
        this._number = number;  // ä¿å­˜numberå€¼ï¼Œä¾›drawæ–¹æ³•ä½¿ç”¨
        this._offsetX = offsetX || 0;  // Xæ–¹å‘åç§»
        this._offsetY = offsetY || 0;  // Yæ–¹å‘åç§»
      }
      
      NumberMarkerOverlay.prototype = new BMap.Overlay();
      NumberMarkerOverlay.prototype.initialize = function(map) {
        this._map = map;
        const pane = map.getPanes().markerPane || map.getPanes().labelPane;
        if (pane) {
          pane.appendChild(this._content);
          this._pane = pane;
        }
        return this._content;
      };
      
      NumberMarkerOverlay.prototype.draw = function() {
        if (this._content && this._map) {
          try {
            const pixel = this._map.pointToOverlayPixel(this._point);
            // åº”ç”¨åç§»é‡
            this._content.style.position = 'absolute';
            this._content.style.left = (pixel.x - 17.5 + this._offsetX) + 'px';
            this._content.style.top = (pixel.y - 17.5 + this._offsetY) + 'px';
            this._content.style.display = 'flex';
            this._content.style.visibility = 'visible';
            // ä¸ºæ¯ä¸ªæ ‡è®°è®¾ç½®å”¯ä¸€çš„z-indexï¼Œç¡®ä¿æ‰€æœ‰æ•°å­—éƒ½èƒ½æ˜¾ç¤ºï¼ˆåé¢çš„æ•°å­—z-indexæ›´é«˜ï¼‰
            this._content.style.zIndex = (20000 + this._number).toString();
          } catch(e) {
            console.warn('ç»˜åˆ¶æ ‡è®°å¤±è´¥:', e);
          }
        }
      };
      
      const overlay = new NumberMarkerOverlay(point, markerContent, number, offsetX, offsetY);

      map.addOverlay(overlay);
      overlays.push(overlay);
      
      setTimeout(() => {
        if (overlay.draw) {
          overlay.draw();
        }
      }, 100);

      return marker;
    }

    async function drawPoints(locations) {
      clearMap();
      if (!map || !locations.length) return;
      
      // é‡ç½®æ§åˆ¶é¢æ¿ç¼–è¾‘æ ‡å¿—
      controlPanelEdited = false;
      
      // ä¿å­˜å½“å‰æ•°æ®ï¼Œç”¨äºç¼©æ”¾åé‡æ–°è®¡ç®—
      currentRouteData = { route: locations };
      currentLabelOffsets = [];
      currentRoutePolyline = null; // drawPoints æ²¡æœ‰è·¯çº¿ï¼Œæ‰€ä»¥è®¾ä¸ºnull
      currentMarkerOffsets = []; // æ¸…ç©ºåœ†åœˆæ ‡è®°åç§»ä¿¡æ¯
      
      // æ›´æ–°é®ç½©å±‚æ˜¾ç¤º
      updateMaskOverlay(locations);

      // ç¬¬ä¸€æ­¥ï¼šå…ˆè®¡ç®—æ‰€æœ‰ç½‘ç‚¹ï¼Œè°ƒæ•´è§†é‡åˆ°åˆé€‚å¤§å°
      const pts = [];
      locations.forEach((loc) => {
        pts.push(new BMap.Point(loc.lng, loc.lat));
      });

      // å…ˆè°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰ç½‘ç‚¹ï¼Œç¡®ä¿å†…å®¹åœ¨æ§åˆ¶é¢æ¿å³ä¾§åŒºåŸŸå†…å±…ä¸­æ˜¾ç¤º
      if (pts.length > 0) {
        // æ§åˆ¶é¢æ¿å‚æ•°
        const panelLeft = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth + 20; // 420pxï¼ŒåŠ ä¸Šé¢å¤–è¾¹è·
        
        // æ ‡ç­¾é¢„ç•™ç©ºé—´
        const labelMaxWidth = 150;  // æ ‡ç­¾æœ€å¤§å®½åº¦ï¼ˆåƒç´ ï¼‰
        const labelPadding = 80;    // æ ‡ç­¾å‘¨å›´é¢„ç•™ç©ºé—´ï¼ˆåƒç´ ï¼‰
        const contentPadding = 30;  // å†…å®¹è¾¹è·
        
        // è·å–åœ°å›¾å®¹å™¨å°ºå¯¸
        const mapContainer = map.getContainer();
        const mapWidth = mapContainer.offsetWidth;
        const mapHeight = mapContainer.offsetHeight;
        
        // è®¡ç®—å¯ç”¨åŒºåŸŸï¼ˆæ§åˆ¶é¢æ¿å³ä¾§åˆ°viewportå³ä¾§ï¼‰
        const availableLeft = panelRight;
        const availableRight = mapWidth - contentPadding;
        const availableTop = contentPadding;
        const availableBottom = mapHeight - contentPadding;
        const availableWidth = availableRight - availableLeft;
        const availableHeight = availableBottom - availableTop;
        const availableCenterX = availableLeft + availableWidth / 2;
        const availableCenterY = availableTop + availableHeight / 2;
        
        console.log(`[åœ°å›¾è§†å›¾] å¯ç”¨åŒºåŸŸ: x=${availableLeft}~${availableRight} (å®½${availableWidth}px), y=${availableTop}~${availableBottom} (é«˜${availableHeight}px)`);
        
        // è®¡ç®—æ‰€æœ‰ç‚¹çš„åœ°ç†è¾¹ç•Œæ¡†
        let minLng = pts[0].lng, maxLng = pts[0].lng;
        let minLat = pts[0].lat, maxLat = pts[0].lat;
        pts.forEach(pt => {
          minLng = Math.min(minLng, pt.lng);
          maxLng = Math.max(maxLng, pt.lng);
          minLat = Math.min(minLat, pt.lat);
          maxLat = Math.max(maxLat, pt.lat);
        });
        
        // è®¡ç®—åœ°ç†ä¸­å¿ƒç‚¹
        const geoCenter = new BMap.Point((minLng + maxLng) / 2, (minLat + maxLat) / 2);
        
        // å…ˆè®¾ç½®ä¸€ä¸ªåˆå§‹è§†é‡
        map.setViewport(pts);
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // è·å–å½“å‰ç¼©æ”¾çº§åˆ«ï¼Œå°è¯•é€æ­¥æ”¾å¤§
        let currentZoom = map.getZoom();
        const maxZoom = 18;
        
        // é€æ­¥æ”¾å¤§åœ°å›¾ï¼Œç›´åˆ°å†…å®¹æ— æ³•å®Œå…¨å®¹çº³åœ¨å¯ç”¨åŒºåŸŸå†…
        let bestZoom = currentZoom;
        let bestCenter = geoCenter;
        
        for (let testZoom = currentZoom; testZoom <= maxZoom; testZoom++) {
          map.setZoom(testZoom);
          await new Promise(resolve => setTimeout(resolve, 200));
          
          // è®¡ç®—å½“å‰ç¼©æ”¾ä¸‹ï¼Œåƒç´ åˆ°åœ°ç†åæ ‡çš„è½¬æ¢
          const centerPixel = map.pointToPixel(geoCenter);
          const testPixel = new BMap.Pixel(centerPixel.x + 100, centerPixel.y);
          const testPoint = map.pixelToPoint(testPixel);
          const pixelToDegree = Math.abs(testPoint.lng - geoCenter.lng) / 100;
          
          // è®¡ç®—å†…å®¹å ç”¨çš„åƒç´ èŒƒå›´ï¼ˆåŒ…æ‹¬æ ‡ç­¾ï¼‰
          const contentMinLng = minLng - (labelMaxWidth + labelPadding) * pixelToDegree;
          const contentMaxLng = maxLng + (labelMaxWidth + labelPadding) * pixelToDegree;
          const contentMinLat = minLat - (labelPadding) * pixelToDegree;
          const contentMaxLat = maxLat + (labelPadding) * pixelToDegree;
          
          // è®¡ç®—å†…å®¹åœ¨å½“å‰ç¼©æ”¾ä¸‹çš„åƒç´ å°ºå¯¸
          const topLeft = map.pointToPixel(new BMap.Point(contentMinLng, contentMaxLat));
          const bottomRight = map.pointToPixel(new BMap.Point(contentMaxLng, contentMinLat));
          const contentWidth = bottomRight.x - topLeft.x;
          const contentHeight = bottomRight.y - topLeft.y;
          
          // æ£€æŸ¥å†…å®¹æ˜¯å¦èƒ½å®Œå…¨å®¹çº³åœ¨å¯ç”¨åŒºåŸŸå†…
          if (contentWidth <= availableWidth && contentHeight <= availableHeight) {
            bestZoom = testZoom;
            
            // è®¡ç®—éœ€è¦å°†åœ°å›¾ä¸­å¿ƒç§»åŠ¨å¤šå°‘ï¼Œä½¿å†…å®¹åœ¨å¯ç”¨åŒºåŸŸå†…å±…ä¸­
            const contentCenterX = (topLeft.x + bottomRight.x) / 2;
            const contentCenterY = (topLeft.y + bottomRight.y) / 2;
            
            // ç›®æ ‡ä½ç½®ï¼ˆå¯ç”¨åŒºåŸŸä¸­å¿ƒï¼‰ä¸å†…å®¹ä¸­å¿ƒçš„åƒç´ å·®
            const offsetX = availableCenterX - contentCenterX;
            const offsetY = availableCenterY - contentCenterY;
            
            // å°†åƒç´ åç§»è½¬æ¢ä¸ºåœ°ç†åæ ‡åç§»
            const currentCenter = map.getCenter();
            const currentCenterPixel = map.pointToPixel(currentCenter);
            const newCenterPixel = new BMap.Pixel(currentCenterPixel.x - offsetX, currentCenterPixel.y - offsetY);
            bestCenter = map.pixelToPoint(newCenterPixel);
            
            console.log(`[åœ°å›¾è§†å›¾] ç¼©æ”¾çº§åˆ« ${testZoom}: å†…å®¹å°ºå¯¸ ${contentWidth.toFixed(0)}x${contentHeight.toFixed(0)}px, å¯ç”¨åŒºåŸŸ ${availableWidth}x${availableHeight}px âœ“`);
          } else {
            console.log(`[åœ°å›¾è§†å›¾] ç¼©æ”¾çº§åˆ« ${testZoom}: å†…å®¹å°ºå¯¸ ${contentWidth.toFixed(0)}x${contentHeight.toFixed(0)}px > å¯ç”¨åŒºåŸŸ, åœæ­¢æ”¾å¤§`);
            break;
          }
        }
        
        // åº”ç”¨æœ€ä½³ç¼©æ”¾çº§åˆ«å’Œä¸­å¿ƒç‚¹
        map.setZoom(bestZoom);
        await new Promise(resolve => setTimeout(resolve, 200));
        map.setCenter(bestCenter);
        await new Promise(resolve => setTimeout(resolve, 300));
        
        console.log(`[åœ°å›¾è§†å›¾] æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${bestZoom}, å†…å®¹å·²åœ¨å¯ç”¨åŒºåŸŸå†…å±…ä¸­`);
        
        // æœ€ç»ˆéªŒè¯ï¼šç¡®ä¿æ‰€æœ‰ç‚¹éƒ½åœ¨å¯ç”¨åŒºåŸŸå†…
        let allInside = true;
        for (const pt of pts) {
          const pixel = map.pointToPixel(pt);
          if (pixel.x < availableLeft || pixel.x > availableRight || pixel.y < availableTop || pixel.y > availableBottom) {
            allInside = false;
            console.warn(`[åœ°å›¾è§†å›¾] ç‚¹ (${pt.lng.toFixed(4)}, ${pt.lat.toFixed(4)}) è¶…å‡ºå¯ç”¨åŒºåŸŸ: åƒç´ (${pixel.x.toFixed(0)}, ${pixel.y.toFixed(0)})`);
          }
        }
        
        // å¦‚æœæœ‰ç‚¹è¶…å‡ºï¼Œç¼©å°ä¸€çº§
        if (!allInside && bestZoom > 10) {
          map.setZoom(bestZoom - 1);
          await new Promise(resolve => setTimeout(resolve, 300));
          console.log(`[åœ°å›¾è§†å›¾] æœ‰å…ƒç´ è¶…å‡ºå¯ç”¨åŒºåŸŸï¼Œç¼©å°åˆ° ${bestZoom - 1}`);
        }
      }

      // ç¬¬äºŒæ­¥ï¼šè§†é‡è°ƒæ•´å®Œæˆåï¼Œå…ˆè°ƒæ•´åœ†åœˆæ ‡è®°ä½ç½®é¿å…é‡å 
      const originalPoints = locations.map(loc => new BMap.Point(loc.lng, loc.lat));
      const { points: adjustedPoints, offsets } = adjustMarkerPositions(originalPoints);
      
      // ä¿å­˜åœ†åœˆæ ‡è®°çš„åç§»ä¿¡æ¯ï¼Œä¾›æ ‡ç­¾ä½ç½®è®¡ç®—ä½¿ç”¨
      currentMarkerOffsets = offsets.map(offset => ({ x: offset.x, y: offset.y }));
      
      // ç¬¬ä¸‰æ­¥ï¼šä½¿ç”¨è°ƒæ•´åçš„ä½ç½®ç»˜åˆ¶ç½‘ç‚¹åœ†åœˆæ ‡è®°
      locations.forEach((loc, idx) => {
        const pt = adjustedPoints[idx];  // ä½¿ç”¨åŸå§‹åœ°ç†åæ ‡ï¼ˆåç§»åœ¨ç»˜åˆ¶æ—¶åº”ç”¨ï¼‰
        const offset = offsets[idx];     // åƒç´ åç§»é‡
        
        const marker = createNumberMarker(pt, idx + 1, locations.length, offset.x, offset.y);
        map.addOverlay(marker);
        markers.push(marker);

        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼ˆä½¿ç”¨åŸå§‹ä½ç½®ï¼‰
        const infoHtml = `
          <div style="padding:10px;">
            <h4 style="margin:0 0 10px 0;color:#3366FF;">ç¬¬ ${idx + 1} ç«™ï¼š${loc.name}</h4>
            ${loc.remark ? `<p style="margin:5px 0;font-size:14px;color:#FF9800;font-weight:bold;">${loc.remark}</p>` : '<p style="margin:5px 0;font-size:12px;color:#999;">æ— å¤‡æ³¨</p>'}
            <p style="margin:5px 0;font-size:12px;color:#666;">ç»åº¦: ${loc.lng}</p>
            <p style="margin:5px 0;font-size:12px;color:#666;">çº¬åº¦: ${loc.lat}</p>
          </div>`;
        marker.addEventListener('click', () => {
          const win = new BMap.InfoWindow(infoHtml);
          map.openInfoWindow(win, pt);  // ä½¿ç”¨åŸå§‹åœ°ç†åæ ‡æ˜¾ç¤ºä¿¡æ¯çª—å£
        });
      });

      // ç­‰å¾…æ ‡è®°æ¸²æŸ“å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
        
      // ç¬¬ä¸‰æ­¥ï¼šæœ€åæ·»åŠ æ ‡ç­¾ï¼Œç¡®ä¿ä¸é‡å 
      await addLabelsToMarkers(locations, markers);
    }

    async function drawRouteResult(result, autoScreenshot = true) {
      console.log('drawRouteResult æ¥æ”¶åˆ°çš„æ•°æ®:', result);
      const { route, polyline, legs, total_distance, total_duration, farthest_points } = result;
      
      // é‡ç½®æ§åˆ¶é¢æ¿ç¼–è¾‘æ ‡å¿—ï¼ˆç»˜åˆ¶æ–°ç½‘ç»„æ—¶å…è®¸æ›´æ–°æ§åˆ¶é¢æ¿ï¼‰
      controlPanelEdited = false;
      
      // ä¿å­˜å½“å‰è·¯çº¿æ•°æ®ï¼Œç”¨äºç¼©æ”¾åé‡æ–°è®¡ç®—
      currentRouteData = result;
      currentLabelOffsets = [];
      currentMarkerOffsets = []; // æ¸…ç©ºåœ†åœˆæ ‡è®°åç§»ä¿¡æ¯ï¼Œå°†åœ¨ç»˜åˆ¶åœ†åœˆæ ‡è®°åæ›´æ–°
      
      // æ›´æ–°é®ç½©å±‚æ˜¾ç¤ºï¼ˆä»å½“å‰è·¯çº¿ç»“æœä¸­è·å–é®ç½©å†…å®¹ï¼‰
      if (route && route.length > 0) {
        updateMaskOverlay(route);
      }

      clearMap();
      if (!map || !route.length) return;

      // ä¿å­˜å½“å‰è·¯çº¿polylineï¼Œç”¨äºæ ‡ç­¾ä½ç½®è®¡ç®—æ—¶æ£€æµ‹æ˜¯å¦é®æŒ¡è·¯çº¿
      currentRoutePolyline = null;
      
      // ç¬¬ä¸€æ­¥ï¼šå…ˆè®¡ç®—æ‰€æœ‰éœ€è¦æ˜¾ç¤ºçš„ç‚¹ï¼ˆè·¯çº¿ç‚¹å’Œç½‘ç‚¹ï¼‰ï¼Œè°ƒæ•´è§†é‡åˆ°åˆé€‚å¤§å°
      const allPoints = [];
      
      // æ”¶é›†è·¯çº¿ç‚¹
      if (polyline && polyline.length) {
        const routePts = polyline.map(p => new BMap.Point(p[0], p[1]));
        allPoints.push(...routePts);
      }
      
      // æ”¶é›†ç½‘ç‚¹
      route.forEach((loc) => {
        allPoints.push(new BMap.Point(loc.lng, loc.lat));
      });
      
      // å…ˆè°ƒæ•´è§†é‡ä»¥é€‚åº”æ‰€æœ‰ç‚¹ï¼Œç¡®ä¿å†…å®¹åœ¨æ§åˆ¶é¢æ¿å³ä¾§åŒºåŸŸå†…å±…ä¸­æ˜¾ç¤º
      if (allPoints.length > 0) {
        // æ§åˆ¶é¢æ¿å‚æ•°
        const panelLeft = 20;
        const panelWidth = 380;
        const panelRight = panelLeft + panelWidth + 20; // 420pxï¼ŒåŠ ä¸Šé¢å¤–è¾¹è·
        
        // æ ‡ç­¾é¢„ç•™ç©ºé—´
        const labelMaxWidth = 150;  // æ ‡ç­¾æœ€å¤§å®½åº¦ï¼ˆåƒç´ ï¼‰
        const labelPadding = 80;    // æ ‡ç­¾å‘¨å›´é¢„ç•™ç©ºé—´ï¼ˆåƒç´ ï¼‰
        const contentPadding = 30;  // å†…å®¹è¾¹è·
        
        // è·å–åœ°å›¾å®¹å™¨å°ºå¯¸
        const mapContainer = map.getContainer();
        const mapWidth = mapContainer.offsetWidth;
        const mapHeight = mapContainer.offsetHeight;
        
        // è®¡ç®—å¯ç”¨åŒºåŸŸï¼ˆæ§åˆ¶é¢æ¿å³ä¾§åˆ°viewportå³ä¾§ï¼‰
        const availableLeft = panelRight;
        const availableRight = mapWidth - contentPadding;
        const availableTop = contentPadding;
        const availableBottom = mapHeight - contentPadding;
        const availableWidth = availableRight - availableLeft;
        const availableHeight = availableBottom - availableTop;
        const availableCenterX = availableLeft + availableWidth / 2;
        const availableCenterY = availableTop + availableHeight / 2;
        
        console.log(`[åœ°å›¾è§†å›¾] å¯ç”¨åŒºåŸŸ: x=${availableLeft}~${availableRight} (å®½${availableWidth}px), y=${availableTop}~${availableBottom} (é«˜${availableHeight}px)`);
        
        // è®¡ç®—æ‰€æœ‰ç‚¹çš„åœ°ç†è¾¹ç•Œæ¡†
        let minLng = allPoints[0].lng, maxLng = allPoints[0].lng;
        let minLat = allPoints[0].lat, maxLat = allPoints[0].lat;
        allPoints.forEach(pt => {
          minLng = Math.min(minLng, pt.lng);
          maxLng = Math.max(maxLng, pt.lng);
          minLat = Math.min(minLat, pt.lat);
          maxLat = Math.max(maxLat, pt.lat);
        });
        
        // è®¡ç®—åœ°ç†ä¸­å¿ƒç‚¹
        const geoCenter = new BMap.Point((minLng + maxLng) / 2, (minLat + maxLat) / 2);

        // å…ˆè®¾ç½®ä¸€ä¸ªåˆå§‹è§†é‡
        map.setViewport(allPoints);
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // è·å–å½“å‰ç¼©æ”¾çº§åˆ«ï¼Œå°è¯•é€æ­¥æ”¾å¤§
        let currentZoom = map.getZoom();
        const maxZoom = 18;
        
        // é€æ­¥æ”¾å¤§åœ°å›¾ï¼Œç›´åˆ°å†…å®¹æ— æ³•å®Œå…¨å®¹çº³åœ¨å¯ç”¨åŒºåŸŸå†…
        let bestZoom = currentZoom;
        let bestCenter = geoCenter;
        
        for (let testZoom = currentZoom; testZoom <= maxZoom; testZoom++) {
          map.setZoom(testZoom);
          await new Promise(resolve => setTimeout(resolve, 200));
          
          // è®¡ç®—å½“å‰ç¼©æ”¾ä¸‹ï¼Œåƒç´ åˆ°åœ°ç†åæ ‡çš„è½¬æ¢
          const centerPixel = map.pointToPixel(geoCenter);
          const testPixel = new BMap.Pixel(centerPixel.x + 100, centerPixel.y);
          const testPoint = map.pixelToPoint(testPixel);
          const pixelToDegree = Math.abs(testPoint.lng - geoCenter.lng) / 100;
          
          // è®¡ç®—å†…å®¹å ç”¨çš„åƒç´ èŒƒå›´ï¼ˆåŒ…æ‹¬æ ‡ç­¾ï¼‰
          const contentMinLng = minLng - (labelMaxWidth + labelPadding) * pixelToDegree;
          const contentMaxLng = maxLng + (labelMaxWidth + labelPadding) * pixelToDegree;
          const contentMinLat = minLat - (labelPadding) * pixelToDegree;
          const contentMaxLat = maxLat + (labelPadding) * pixelToDegree;
          
          // è®¡ç®—å†…å®¹åœ¨å½“å‰ç¼©æ”¾ä¸‹çš„åƒç´ å°ºå¯¸
          const topLeft = map.pointToPixel(new BMap.Point(contentMinLng, contentMaxLat));
          const bottomRight = map.pointToPixel(new BMap.Point(contentMaxLng, contentMinLat));
          const contentWidth = bottomRight.x - topLeft.x;
          const contentHeight = bottomRight.y - topLeft.y;
          
          // æ£€æŸ¥å†…å®¹æ˜¯å¦èƒ½å®Œå…¨å®¹çº³åœ¨å¯ç”¨åŒºåŸŸå†…
          if (contentWidth <= availableWidth && contentHeight <= availableHeight) {
            bestZoom = testZoom;
            
            // è®¡ç®—éœ€è¦å°†åœ°å›¾ä¸­å¿ƒç§»åŠ¨å¤šå°‘ï¼Œä½¿å†…å®¹åœ¨å¯ç”¨åŒºåŸŸå†…å±…ä¸­
            // å†…å®¹ä¸­å¿ƒçš„åƒç´ ä½ç½®
            const contentCenterX = (topLeft.x + bottomRight.x) / 2;
            const contentCenterY = (topLeft.y + bottomRight.y) / 2;
            
            // ç›®æ ‡ä½ç½®ï¼ˆå¯ç”¨åŒºåŸŸä¸­å¿ƒï¼‰ä¸å†…å®¹ä¸­å¿ƒçš„åƒç´ å·®
            const offsetX = availableCenterX - contentCenterX;
            const offsetY = availableCenterY - contentCenterY;
            
            // å°†åƒç´ åç§»è½¬æ¢ä¸ºåœ°ç†åæ ‡åç§»
            const currentCenter = map.getCenter();
            const currentCenterPixel = map.pointToPixel(currentCenter);
            const newCenterPixel = new BMap.Pixel(currentCenterPixel.x - offsetX, currentCenterPixel.y - offsetY);
            bestCenter = map.pixelToPoint(newCenterPixel);
            
            console.log(`[åœ°å›¾è§†å›¾] ç¼©æ”¾çº§åˆ« ${testZoom}: å†…å®¹å°ºå¯¸ ${contentWidth.toFixed(0)}x${contentHeight.toFixed(0)}px, å¯ç”¨åŒºåŸŸ ${availableWidth}x${availableHeight}px âœ“`);
          } else {
            console.log(`[åœ°å›¾è§†å›¾] ç¼©æ”¾çº§åˆ« ${testZoom}: å†…å®¹å°ºå¯¸ ${contentWidth.toFixed(0)}x${contentHeight.toFixed(0)}px > å¯ç”¨åŒºåŸŸ, åœæ­¢æ”¾å¤§`);
            break;
          }
        }
        
        // åº”ç”¨æœ€ä½³ç¼©æ”¾çº§åˆ«å’Œä¸­å¿ƒç‚¹
        map.setZoom(bestZoom);
        await new Promise(resolve => setTimeout(resolve, 200));
        map.setCenter(bestCenter);
        await new Promise(resolve => setTimeout(resolve, 300));
        
        console.log(`[åœ°å›¾è§†å›¾] æœ€ç»ˆç¼©æ”¾çº§åˆ«: ${bestZoom}, å†…å®¹å·²åœ¨å¯ç”¨åŒºåŸŸå†…å±…ä¸­`);
        
        // æœ€ç»ˆéªŒè¯ï¼šç¡®ä¿æ‰€æœ‰ç‚¹éƒ½åœ¨å¯ç”¨åŒºåŸŸå†…
        let allInside = true;
        for (const pt of allPoints) {
          const pixel = map.pointToPixel(pt);
          if (pixel.x < availableLeft || pixel.x > availableRight || pixel.y < availableTop || pixel.y > availableBottom) {
            allInside = false;
            console.warn(`[åœ°å›¾è§†å›¾] ç‚¹ (${pt.lng.toFixed(4)}, ${pt.lat.toFixed(4)}) è¶…å‡ºå¯ç”¨åŒºåŸŸ: åƒç´ (${pixel.x.toFixed(0)}, ${pixel.y.toFixed(0)})`);
          }
        }
        
        // å¦‚æœæœ‰ç‚¹è¶…å‡ºï¼Œç¼©å°ä¸€çº§
        if (!allInside && bestZoom > 10) {
          map.setZoom(bestZoom - 1);
          await new Promise(resolve => setTimeout(resolve, 300));
          console.log(`[åœ°å›¾è§†å›¾] æœ‰å…ƒç´ è¶…å‡ºå¯ç”¨åŒºåŸŸï¼Œç¼©å°åˆ° ${bestZoom - 1}`);
          }
      }

      // ç¬¬äºŒæ­¥ï¼šè§†é‡è°ƒæ•´å®Œæˆåï¼Œå¼€å§‹æŒ‰é¡ºåºç»˜åˆ¶æ‰€æœ‰æ ‡æ³¨
      // 2.1 ç»˜åˆ¶è·¯çº¿ï¼ˆåº•å±‚ï¼‰
      if (polyline && polyline.length) {
        const routePts = polyline.map(p => new BMap.Point(p[0], p[1]));
        const line = new BMap.Polyline(routePts, { strokeWeight: 4, strokeOpacity: 0.9, strokeColor: "#2196F3" });
        map.addOverlay(line);
        overlays.push(line);
        currentRoutePolyline = line; // ä¿å­˜è·¯çº¿å¼•ç”¨ï¼Œç”¨äºæ ‡ç­¾ä½ç½®è®¡ç®—
        // ç­‰å¾…è·¯çº¿æ¸²æŸ“å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 200));
        }

      // 2.2 å…ˆè°ƒæ•´åœ†åœˆæ ‡è®°ä½ç½®é¿å…é‡å 
      const originalRoutePoints = route.map(loc => new BMap.Point(loc.lng, loc.lat));
      const { points: adjustedRoutePoints, offsets: routeOffsets } = adjustMarkerPositions(originalRoutePoints);
      
      // ä¿å­˜åœ†åœˆæ ‡è®°çš„åç§»ä¿¡æ¯ï¼Œä¾›æ ‡ç­¾ä½ç½®è®¡ç®—ä½¿ç”¨
      currentMarkerOffsets = routeOffsets.map(offset => ({ x: offset.x, y: offset.y }));
      
      // 2.3 ç»˜åˆ¶åœ†åœˆæ ‡è®°ï¼ˆç¬¬ä¸€æ­¥ï¼‰
      route.forEach((loc, idx) => {
        const pt = adjustedRoutePoints[idx];  // ä½¿ç”¨åŸå§‹åœ°ç†åæ ‡ï¼ˆåç§»åœ¨ç»˜åˆ¶æ—¶åº”ç”¨ï¼‰
        const offset = routeOffsets[idx];    // åƒç´ åç§»é‡

        const marker = createNumberMarker(pt, idx + 1, route.length, offset.x, offset.y);
        map.addOverlay(marker);
        markers.push(marker);

        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼ˆä½¿ç”¨åŸå§‹ä½ç½®ï¼‰
        const infoHtml = `
          <div style="padding:10px;">
            <h4 style="margin:0 0 10px 0;color:#3366FF;">ç¬¬ ${idx + 1} ç«™ï¼š${loc.name}</h4>
            ${loc.remark ? `<p style="margin:5px 0;font-size:14px;color:#FF9800;font-weight:bold;">${loc.remark}</p>` : '<p style="margin:5px 0;font-size:12px;color:#999;">æ— å¤‡æ³¨</p>'}
            <p style="margin:5px 0;font-size:12px;color:#666;">ç»åº¦: ${loc.lng}</p>
            <p style="margin:5px 0;font-size:12px;color:#666;">çº¬åº¦: ${loc.lat}</p>
          </div>`;
        marker.addEventListener('click', () => {
          const win = new BMap.InfoWindow(infoHtml);
          map.openInfoWindow(win, pt);  // ä½¿ç”¨åŸå§‹åœ°ç†åæ ‡æ˜¾ç¤ºä¿¡æ¯çª—å£
        });
      });

      // ç­‰å¾…åœ†åœˆæ ‡è®°æ¸²æŸ“å®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
      console.log('[ç»˜åˆ¶é¡ºåº] âœ“ åœ†åœˆæ ‡è®°å·²ç»˜åˆ¶å®Œæˆ');

      // 2.4 ç»˜åˆ¶å¤‡æ³¨æ ‡ç­¾ï¼ˆç¬¬äºŒæ­¥ï¼‰ï¼Œç¡®ä¿ä¸é®æŒ¡åœ†åœˆæ ‡è®°å’Œè·¯çº¿
      await addLabelsToMarkers(route, markers);
      console.log('[ç»˜åˆ¶é¡ºåº] âœ“ å¤‡æ³¨æ ‡ç­¾å·²ç»˜åˆ¶å®Œæˆ');
      
      // 2.5 æœ€åç»˜åˆ¶è·ç¦»æ ‡ç­¾ï¼ˆç¬¬ä¸‰æ­¥ï¼‰ï¼Œç¡®ä¿ä¸é®æŒ¡åœ†åœˆæ ‡è®°ã€å¤‡æ³¨æ ‡ç­¾å’Œè·¯çº¿
      distanceLabels = [];  // æ¸…ç©ºä¹‹å‰çš„è·ç¦»æ ‡ç­¾å¼•ç”¨
      if (legs && legs.length > 0) {
        // æ”¶é›†æ‰€æœ‰å·²æ”¾ç½®çš„åœ†åœˆæ ‡è®°ä½ç½®
        const existingCirclePositions = [];
        route.forEach((loc, idx) => {
          const pt = adjustedRoutePoints[idx];
          const offset = routeOffsets[idx];
          const pixel = map.pointToPixel(pt);
          existingCirclePositions.push({
            x: pixel.x + offset.x,
            y: pixel.y + offset.y,
            radius: 20.5  // åœ†åœˆæ€»åŠå¾„ï¼ˆåŒ…æ‹¬è¾¹æ¡†ï¼‰
          });
        });
        
        // æ”¶é›†æ‰€æœ‰å·²æ”¾ç½®çš„å¤‡æ³¨æ ‡ç­¾ä½ç½®
        const existingLabelPositions = [];
        route.forEach((loc, idx) => {
          if (markers && markers[idx]) {
            const marker = markers[idx];
            const label = marker.getLabel();
            if (label && currentLabelOffsets && currentLabelOffsets[idx]) {
              const pt = new BMap.Point(loc.lng, loc.lat);
              const pixel = map.pointToPixel(pt);
              const offset = currentLabelOffsets[idx];
              const labelSize = getLabelActualSize(label) || { width: 120, height: 34 };
              existingLabelPositions.push({
                x: pixel.x + offset.offsetX,
                y: pixel.y + offset.offsetY,
                width: labelSize.width,
                height: labelSize.height,
                borderWidth: 2
              });
            }
          }
        });
        
        legs.forEach((leg, legIdx) => {
          if (leg.mid_point && leg.mid_point.length === 2) {
            const midPoint = new BMap.Point(leg.mid_point[0], leg.mid_point[1]);
            const midPixel = map.pointToPixel(midPoint);
            
            // ä¼°ç®—è·ç¦»æ ‡ç­¾å°ºå¯¸
            const distanceLabelWidth = 80;  // ä¼°ç®—å®½åº¦
            const distanceLabelHeight = 30; // ä¼°ç®—é«˜åº¦
            const distanceLabelBorder = 2;
            const distanceLabelPadding = 5;
            const distanceLabelTotalWidth = distanceLabelWidth + distanceLabelBorder * 2;
            const distanceLabelTotalHeight = distanceLabelHeight + distanceLabelBorder * 2;
            
            // å°è¯•å¤šä¸ªåç§»ä½ç½®ï¼Œæ‰¾åˆ°ä¸é®æŒ¡çš„ä½ç½®
            const candidateOffsets = [
              { x: 10, y: -10 },
              { x: -10, y: -10 },
              { x: 10, y: 10 },
              { x: -10, y: 10 },
              { x: 20, y: 0 },
              { x: -20, y: 0 },
              { x: 0, y: -20 },
              { x: 0, y: 20 },
              { x: 30, y: -15 },
              { x: -30, y: -15 },
              { x: 30, y: 15 },
              { x: -30, y: 15 }
            ];
            
            let bestOffset = { x: 10, y: -10 }; // é»˜è®¤åç§»
            let foundValidPosition = false;
            
            for (const offset of candidateOffsets) {
              const labelX = midPixel.x + offset.x;
              const labelY = midPixel.y + offset.y;
              const labelBox = {
                left: labelX - distanceLabelTotalWidth / 2 - distanceLabelPadding,
                right: labelX + distanceLabelTotalWidth / 2 + distanceLabelPadding,
                top: labelY - distanceLabelTotalHeight / 2 - distanceLabelPadding,
                bottom: labelY + distanceLabelTotalHeight / 2 + distanceLabelPadding
              };
              
              // æ£€æŸ¥æ˜¯å¦é®æŒ¡åœ†åœˆæ ‡è®°ï¼ˆä½¿ç”¨å·²æ”¶é›†çš„åœ†åœˆä½ç½®ï¼‰
              let overlapsCircle = false;
              for (const circle of existingCirclePositions) {
                const nearestX = Math.max(labelBox.left, Math.min(circle.x, labelBox.right));
                const nearestY = Math.max(labelBox.top, Math.min(circle.y, labelBox.bottom));
                const distToCircle = Math.hypot(nearestX - circle.x, nearestY - circle.y);
                // è€ƒè™‘åœ†åœˆè¾¹æ¡†ï¼ˆ3pxï¼‰å’Œè·ç¦»æ ‡ç­¾è¾¹æ¡†ï¼ˆ2pxï¼‰ä»¥åŠå®‰å…¨è¾¹è·
                const minDistance = circle.radius + distanceLabelBorder * 2 + distanceLabelPadding;
                if (distToCircle < minDistance) {
                  overlapsCircle = true;
            break;
          }
        }
        
              if (overlapsCircle) continue;
              
              // æ£€æŸ¥æ˜¯å¦é®æŒ¡å¤‡æ³¨æ ‡ç­¾ï¼ˆä½¿ç”¨å·²æ”¶é›†çš„å¤‡æ³¨æ ‡ç­¾ä½ç½®ï¼‰
              let overlapsLabel = false;
              for (const existingLabel of existingLabelPositions) {
                // è®¡ç®—å¤‡æ³¨æ ‡ç­¾çš„è¾¹æ¡†æ¡†ï¼ˆåŒ…æ‹¬è¾¹æ¡†å®½åº¦ï¼‰
                const existingLabelTotalWidth = existingLabel.width + existingLabel.borderWidth * 2;
                const existingLabelTotalHeight = existingLabel.height + existingLabel.borderWidth * 2;
                const existingBox = {
                  left: existingLabel.x - existingLabelTotalWidth / 2 - distanceLabelPadding,
                  right: existingLabel.x + existingLabelTotalWidth / 2 + distanceLabelPadding,
                  top: existingLabel.y - existingLabelTotalHeight / 2 - distanceLabelPadding,
                  bottom: existingLabel.y + existingLabelTotalHeight / 2 + distanceLabelPadding
                };
                // æ£€æŸ¥è¾¹æ¡†æ¡†æ˜¯å¦é‡å 
                const overlapX = Math.max(0, Math.min(labelBox.right, existingBox.right) - Math.max(labelBox.left, existingBox.left));
                const overlapY = Math.max(0, Math.min(labelBox.bottom, existingBox.bottom) - Math.max(labelBox.top, existingBox.top));
                if (overlapX > 0 && overlapY > 0) {
                  overlapsLabel = true;
                  break;
                }
              }
              
              if (overlapsLabel) continue;
              
              // æ£€æŸ¥æ˜¯å¦é®æŒ¡è·¯çº¿
              if (currentRoutePolyline) {
                try {
                  const path = currentRoutePolyline.getPath();
                  if (path && path.length > 0) {
                    for (let i = 0; i < path.length - 1; i++) {
                      const p1 = path[i];
                      const p2 = path[i + 1];
                      const p1Pixel = map.pointToPixel(p1);
                      const p2Pixel = map.pointToPixel(p2);
                      const lineWidth = 4;
                      const lineMinX = Math.min(p1Pixel.x, p2Pixel.x) - lineWidth / 2 - distanceLabelPadding;
                      const lineMaxX = Math.max(p1Pixel.x, p2Pixel.x) + lineWidth / 2 + distanceLabelPadding;
                      const lineMinY = Math.min(p1Pixel.y, p2Pixel.y) - lineWidth / 2 - distanceLabelPadding;
                      const lineMaxY = Math.max(p1Pixel.y, p2Pixel.y) + lineWidth / 2 + distanceLabelPadding;
                      
                      const overlapX = Math.max(0, Math.min(labelBox.right, lineMaxX) - Math.max(labelBox.left, lineMinX));
                      const overlapY = Math.max(0, Math.min(labelBox.bottom, lineMaxY) - Math.max(labelBox.top, lineMinY));
                      if (overlapX > 0 && overlapY > 0) {
                        const lineLength = Math.hypot(p2Pixel.x - p1Pixel.x, p2Pixel.y - p1Pixel.y);
                        if (lineLength > 0) {
                          const t = Math.max(0, Math.min(1, 
                            ((labelX - p1Pixel.x) * (p2Pixel.x - p1Pixel.x) + (labelY - p1Pixel.y) * (p2Pixel.y - p1Pixel.y)) / (lineLength * lineLength)
                          ));
                          const nearestPointX = p1Pixel.x + t * (p2Pixel.x - p1Pixel.x);
                          const nearestPointY = p1Pixel.y + t * (p2Pixel.y - p1Pixel.y);
                          const distToLine = Math.hypot(labelX - nearestPointX, labelY - nearestPointY);
                          const minDistToLine = (lineWidth / 2) + Math.max(distanceLabelTotalWidth, distanceLabelTotalHeight) / 2 + distanceLabelPadding;
                          if (distToLine < minDistToLine) {
                            overlapsLabel = true; // æ ‡è®°ä¸ºé®æŒ¡è·¯çº¿
                            break;
                          }
                        }
                      }
                    }
          }
                } catch(e) {
                  // å¿½ç•¥é”™è¯¯
                }
              }
              
              if (!overlapsLabel) {
                bestOffset = offset;
                foundValidPosition = true;
                break; // æ‰¾åˆ°ä¸é®æŒ¡çš„ä½ç½®
              }
            }
            
            const label = new BMap.Label(leg.distance_text, { offset: new BMap.Size(bestOffset.x, bestOffset.y) });
            label.setStyle({
              background: 'rgba(255, 152, 0, 0.95)',
              color: 'white',
              border: '2px solid white',
              padding: '5px 10px',
              borderRadius: '5px',
              fontSize: '12px',
              fontWeight: 'bold',
              boxShadow: '0 2px 6px rgba(0,0,0,0.4)',
              whiteSpace: 'nowrap',
              zIndex: 1000  // è·ç¦»æ ‡è®°åœ¨åº•å±‚ï¼ˆä½äºç½‘ç‚¹åç§°æ ‡ç­¾çš„10000ï¼‰
            });
            label.setPosition(midPoint);
            map.addOverlay(label);
            overlays.push(label);
            distanceLabels.push(label);  // ä¿å­˜å¼•ç”¨ï¼Œç”¨äºæ§åˆ¶æ˜¾ç¤º/éšè—
            
            // ä¿å­˜æ ‡ç­¾çš„åç§»ä¿¡æ¯ï¼Œç”¨äºåç»­å¯ç”¨æ‹–æ‹½åŠŸèƒ½
            label._initialOffset = bestOffset;
            label._midPoint = midPoint;
            label._legIdx = legIdx;
            
            if (!foundValidPosition) {
              console.warn(`[è·ç¦»æ ‡ç­¾] ç¬¬ ${legIdx + 1} ä¸ªè·ç¦»æ ‡ç­¾å¯èƒ½ä¸å…¶ä»–å…ƒç´ é‡å `);
        }
      }
        });
      }
      toggleDistanceLabels();
      console.log('[ç»˜åˆ¶é¡ºåº] âœ“ è·ç¦»æ ‡ç­¾å·²ç»˜åˆ¶å®Œæˆ');
      console.log('[ç»˜åˆ¶é¡ºåº] âœ“ æ‰€æœ‰æ ‡æ³¨ç»˜åˆ¶å®Œæˆ');


      // å¼ºåˆ¶åˆ·æ–°æ ‡è®°ç‚¹æ ‡ç­¾ï¼Œç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚ï¼ˆåœ¨æ‰€æœ‰è·ç¦»æ ‡ç­¾ä¸Šæ–¹ï¼‰
      setTimeout(() => {
        markers.forEach((marker, idx) => {
          try {
            const currentLabel = marker.getLabel();
            if (currentLabel) {
              // é‡æ–°è®¾ç½®æ ‡ç­¾æ ·å¼ï¼Œç¡®ä¿zIndexç”Ÿæ•ˆ
              const style = currentLabel.getStyle();
              if (style) {
                style.zIndex = 10000;  // æœ€é«˜ä¼˜å…ˆçº§
                currentLabel.setStyle(style);
              }
              // é€šè¿‡DOMç›´æ¥è®¾ç½®z-index
              try {
                const labelElement = currentLabel.getContent();
                if (labelElement && labelElement.style) {
                  labelElement.style.zIndex = '10000';
                  labelElement.style.position = 'relative';
                }
              } catch(e) {
                // å¿½ç•¥DOMæ“ä½œé”™è¯¯
              }
              // é‡æ–°å¯ç”¨æ‹–æ‹½åŠŸèƒ½ï¼ˆå¦‚æœæ˜¯æ‰‹åŠ¨è¾“å…¥ï¼Œå¼ºåˆ¶é‡æ–°ç»‘å®šï¼‰
              if (currentRouteData && currentRouteData.route) {
                enableLabelDragging(marker, currentLabel, idx, currentRouteData.route, true);
              }
            }
          } catch(e) {
            // å¿½ç•¥é”™è¯¯
          }
        });
        // é‡æ–°è®¡ç®—æ ‡ç­¾ä½ç½®ï¼Œé¿å…é®æŒ¡
        updateLabelPositions();
      }, 200);

      // âœ… ç¬¬ä¸‰æ­¥ï¼šå»¶è¿Ÿç»˜åˆ¶"æœ€è¿œç›´çº¿"ï¼ˆç¡®ä¿åœ¨è·¯çº¿ç»˜åˆ¶å®Œæˆåï¼‰
      setTimeout(() => {
        drawFarthestLine(farthest_points);
      }, 100);

      // å¼ºåˆ¶é‡ç»˜è‡ªå®šä¹‰ overlayï¼ˆåœ†åœˆæ•°å­—ï¼‰
      setTimeout(() => {
        overlays.forEach(overlay => {
          if (overlay && overlay.draw) {
            try { overlay.draw(); } catch(e) {}
          }
        });
      }, 200);

      // ä¿å­˜å½“å‰è·¯çº¿ç»“æœ
      currentRouteResult = result;
      
      // è·å–å½“å‰ç®€ç‰ˆæ¨¡å¼çŠ¶æ€
      routeSimpleMode = document.getElementById('toggleRouteSimple')?.checked ?? true;
      
      // æ›´æ–°è·¯çº¿è¯¦æƒ…æ˜¾ç¤º
      updateRouteInfo(result, routeSimpleMode);
      
      // è‡ªåŠ¨æ»šåŠ¨æ§åˆ¶é¢æ¿åˆ°åº•éƒ¨å’Œå³éƒ¨
      setTimeout(() => {
        const panel = document.getElementById('control-panel');
        if (panel) {
          panel.scrollTo({
            top: panel.scrollHeight,
            left: panel.scrollWidth,
            behavior: 'smooth'
          });
          
          // åªæœ‰åœ¨ autoScreenshot ä¸º true ä¸”ä¸åœ¨è°ƒè¯•æ¨¡å¼æ—¶æ‰è‡ªåŠ¨æˆªå›¾
          if (autoScreenshot && !debugMode) {
            // æ»šåŠ¨å®Œæˆåï¼Œå»¶è¿Ÿæ‰§è¡Œæˆªå›¾ï¼ˆç¡®ä¿å†…å®¹å®Œå…¨æ˜¾ç¤ºï¼‰
            // ä¼ å…¥å½“å‰è·¯çº¿çš„routeä½œä¸ºlocationsï¼Œä»¥è·å–å¯¹åº”çš„é®ç½©å†…å®¹
            const routeForMask = result.route || [];
            setTimeout(() => {
              captureScreenshot('', '', '', '', routeForMask);
            }, 1500);  // ç­‰å¾…æ»šåŠ¨åŠ¨ç”»å®Œæˆåå†æˆªå›¾
          } else if (debugMode) {
            console.log('[è°ƒè¯•æ¨¡å¼] è·³è¿‡è‡ªåŠ¨æˆªå›¾');
          }
        }
      }, 100);
    }

    function formatMeters(m) {
      if (m >= 1000) return (m / 1000).toFixed(2) + " å…¬é‡Œ";
      return Math.round(m) + " ç±³";
    }
    function formatSeconds(s) {
      s = Math.round(s);
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      if (h > 0) return `${h}å°æ—¶${m}åˆ†é’Ÿ`;
      return `${m}åˆ†é’Ÿ`;
    }

    // æŒ‰ç½‘ç»„åˆ†ç»„å¤„ç†
    // æŒ‰å·¥å·åˆ†ç»„
    function groupLocationsByEmployee(locations) {
      const employees = {};
      locations.forEach(loc => {
        const employeeId = loc.employee_id || '';
        if (employeeId && employeeId.trim()) {
          if (!employees[employeeId]) {
            employees[employeeId] = {
              employee_id: employeeId,
              employee_name: loc.employee_name || '',
              groups: {}
            };
          }
          const group = loc.group || 'æœªåˆ†ç»„';
          if (!employees[employeeId].groups[group]) {
            employees[employeeId].groups[group] = [];
          }
          employees[employeeId].groups[group].push(loc);
        }
      });
      return employees;
    }

    function groupLocationsByGroup(locations) {
      const groups = {};
      for (const loc of locations) {
        const group = (loc.group || '').trim();
        const groupKey = group || 'æœªåˆ†ç»„';
        if (!groups[groupKey]) {
          groups[groupKey] = [];
        }
        groups[groupKey].push(loc);
      }
      return groups;
    }

    async function calculateRoute() {
      const locations = currentLocations.length ? currentLocations : parseLocationData();
      if (locations.length < 2) return showError('è‡³å°‘éœ€è¦2ä¸ªç½‘ç‚¹ï¼');

      // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å·¥å·ï¼Œå¦‚æœæœ‰å·¥å·åˆ™æŒ‰å·¥å·åˆ†ç»„å¤„ç†
      const employees = groupLocationsByEmployee(locations);
      if (employees && Object.keys(employees).length > 0) {
        excelEmployees = employees;
        startBatchProcessByEmployee();
        return;
      }

      // æŒ‰ç½‘ç»„åˆ†ç»„
      const groups = groupLocationsByGroup(locations);
      const groupKeys = Object.keys(groups);
      
      // å¦‚æœæœ‰å¤šä¸ªç½‘ç»„ï¼Œè‡ªåŠ¨æŒ‰ç»„ä¾æ¬¡å¤„ç†
      if (groupKeys.length > 1 || (groupKeys.length === 1 && groupKeys[0] !== 'æœªåˆ†ç»„')) {
        excelGroups = groups;
        startBatchProcess();
        return;
      }

      // å•ä¸ªç»„æˆ–æ— åˆ†ç»„ï¼Œç›´æ¥å¤„ç†
      // åˆ¤æ–­æ˜¯å¦æ˜¯æ‰‹åŠ¨è¾“å…¥ï¼ˆcurrentLocationsä¸ºç©ºï¼Œè¯´æ˜æ˜¯ä»æ–‡æœ¬æ¡†è§£æçš„ï¼‰
      const isManualInput = currentLocations.length === 0;
      showLoading('ğŸ“ æ­£åœ¨æŒ‰åºè®¡ç®—é©¾è½¦è·¯çº¿...');
      try {
        const resp = await fetch('/calculate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ locations })
        });
        const data = await resp.json();
        if (data.error) return showError(data.error);
        // æ‰‹åŠ¨è¾“å…¥æ—¶ä¸è‡ªåŠ¨æˆªå›¾
        await drawRouteResult(data, !isManualInput);
      } catch (e) {
        showError('è®¡ç®—å¤±è´¥ï¼š' + e);
      }
    }

    async function optimizeRoute() {
      const locations = currentLocations.length ? currentLocations : parseLocationData();
      if (locations.length < 2) return showError('è‡³å°‘éœ€è¦2ä¸ªç½‘ç‚¹ï¼');

      // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å·¥å·ï¼Œå¦‚æœæœ‰å·¥å·åˆ™æŒ‰å·¥å·åˆ†ç»„å¤„ç†
      const employees = groupLocationsByEmployee(locations);
      if (employees && Object.keys(employees).length > 0) {
        excelEmployees = employees;
        startBatchProcessByEmployee();
        return;
      }

      // æŒ‰ç½‘ç»„åˆ†ç»„
      const groups = groupLocationsByGroup(locations);
      const groupKeys = Object.keys(groups);
      
      // å¦‚æœæœ‰å¤šä¸ªç½‘ç»„ï¼Œè‡ªåŠ¨æŒ‰ç»„ä¾æ¬¡å¤„ç†
      if (groupKeys.length > 1 || (groupKeys.length === 1 && groupKeys[0] !== 'æœªåˆ†ç»„')) {
        excelGroups = groups;
        startBatchProcess();
        return;
      }

      // å•ä¸ªç»„æˆ–æ— åˆ†ç»„ï¼Œç›´æ¥å¤„ç†
      // åˆ¤æ–­æ˜¯å¦æ˜¯æ‰‹åŠ¨è¾“å…¥ï¼ˆcurrentLocationsä¸ºç©ºï¼Œè¯´æ˜æ˜¯ä»æ–‡æœ¬æ¡†è§£æçš„ï¼‰
      const isManualInput = currentLocations.length === 0;
      const startName = document.getElementById('startPoint').value.trim() || null;
      showLoading('ğŸ”„ æ­£åœ¨ä¼˜åŒ–é¡ºåºå¹¶è§„åˆ’é©¾è½¦è·¯çº¿...');

      try {
        const resp = await fetch('/optimize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ locations, start_name: startName })
        });
        const data = await resp.json();
        if (data.error) return showError(data.error);
        // æ‰‹åŠ¨è¾“å…¥æ—¶ä¸è‡ªåŠ¨æˆªå›¾
        await drawRouteResult(data, !isManualInput);
      } catch (e) {
        showError('ä¼˜åŒ–å¤±è´¥ï¼š' + e);
      }
    }

    // æ‰‹åŠ¨æˆªå›¾åŠŸèƒ½ï¼ˆå¸¦æ»šåŠ¨æ§åˆ¶é¢æ¿ï¼‰
    async function manualCaptureScreenshot() {
      // å…ˆæ»šåŠ¨æ§åˆ¶é¢æ¿åˆ°åº•éƒ¨ï¼Œç¡®ä¿æ˜¾ç¤ºæœ€æ–°å†…å®¹
      const panel = document.getElementById('control-panel');
      
      // è·å–å½“å‰æ˜¾ç¤ºçš„è·¯çº¿æ•°æ®ï¼ˆå¦‚æœæœ‰ï¼‰æˆ–å½“å‰ç½‘ç‚¹æ•°æ®
      let locationsForMask = null;
      if (currentRouteResult && currentRouteResult.route) {
        // å¦‚æœæœ‰å½“å‰è·¯çº¿ç»“æœï¼Œä½¿ç”¨è·¯çº¿çš„ç½‘ç‚¹æ•°æ®
        locationsForMask = currentRouteResult.route;
      } else {
        // å¦åˆ™ä½¿ç”¨å½“å‰ç½‘ç‚¹æ•°æ®
        locationsForMask = currentLocations.length ? currentLocations : parseLocationData();
      }
      
      // è°ƒè¯•æ¨¡å¼ä¸‹çš„æ‰¹é‡å¤„ç†ï¼šä½¿ç”¨ä¿å­˜çš„ç½‘ç»„ä¿¡æ¯è¿›è¡Œæˆªå›¾
      const groupInfo = debugModeCurrentGroupInfo;
      
      const doScreenshot = async () => {
        if (groupInfo) {
          // ä½¿ç”¨ç½‘ç»„ä¿¡æ¯è¿›è¡Œæˆªå›¾
          await captureScreenshot(groupInfo.groupName, groupInfo.employeeId, groupInfo.employeeName, groupInfo.adjustment, groupInfo.locations);
          console.log(`[è°ƒè¯•æ¨¡å¼] ç½‘ç»„ ${groupInfo.groupName} æˆªå›¾å®Œæˆ`);
        } else {
          // æ™®é€šæ‰‹åŠ¨æˆªå›¾
          await captureScreenshot('', '', '', '', locationsForMask);
        }
        
        // å¦‚æœæœ‰ç­‰å¾…çš„ resolverï¼Œå»¶è¿Ÿåè§¦å‘ç»§ç»­ä¸‹ä¸€æ­¥
        // å»¶è¿Ÿ2ç§’è®©ç”¨æˆ·çœ‹åˆ°æˆªå›¾æˆåŠŸçš„æ¶ˆæ¯
        if (debugModeScreenshotResolver) {
          const resolver = debugModeScreenshotResolver;
          debugModeScreenshotResolver = null;
          debugModeCurrentGroupInfo = null;
          
          // ç§»é™¤æŒ‰é’®é«˜äº®
          const btn = document.querySelector('.btn-screenshot');
          if (btn) {
            btn.style.animation = '';
            btn.style.boxShadow = '';
          }
          
          // å»¶è¿Ÿ2ç§’åç»§ç»­ä¸‹ä¸€ä¸ªç½‘ç»„
          setTimeout(() => {
            resolver();
          }, 2000);
        }
      };
      
      if (panel) {
        // æ»šåŠ¨æ§åˆ¶é¢æ¿åˆ°åº•éƒ¨å’Œå³éƒ¨ï¼Œç¡®ä¿æ˜¾ç¤ºæœ€æ–°å†…å®¹
        panel.scrollTo({
          top: panel.scrollHeight,
          left: panel.scrollWidth,
          behavior: 'smooth'
        });
        // ç­‰å¾…æ»šåŠ¨å®Œæˆåå†æˆªå›¾
        setTimeout(doScreenshot, 800);
      } else {
        await doScreenshot();
      }
    }
    
    // è°ƒè¯•æ¨¡å¼ä¸‹ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨æˆªå›¾
    function waitForManualScreenshot(groupInfo) {
      return new Promise((resolve) => {
        debugModeScreenshotResolver = resolve;
        debugModeCurrentGroupInfo = groupInfo;
        
        // æ›´æ–°çŠ¶æ€æç¤º
        updateStatus(`ğŸ”§ è°ƒè¯•æ¨¡å¼ï¼šè¯·è°ƒæ•´ "${groupInfo.groupName}" åç‚¹å‡»"æ‰‹åŠ¨æˆªå›¾"æŒ‰é’®ç»§ç»­`, 'warning');
        
        // é«˜äº®æ‰‹åŠ¨æˆªå›¾æŒ‰é’®
        const btn = document.querySelector('.btn-screenshot');
        if (btn) {
          btn.style.animation = 'pulse 1s infinite';
          btn.style.boxShadow = '0 0 10px #FF9800';
        }
      });
    }
    
    // æ¸…é™¤è°ƒè¯•æ¨¡å¼ç­‰å¾…çŠ¶æ€
    function clearDebugModeWait() {
      debugModeScreenshotResolver = null;
      debugModeCurrentGroupInfo = null;
      
      // ç§»é™¤æŒ‰é’®é«˜äº®
      const btn = document.querySelector('.btn-screenshot');
      if (btn) {
        btn.style.animation = '';
        btn.style.boxShadow = '';
      }
    }

    // æ›´æ–°é®ç½©å±‚æ˜¾ç¤ºï¼ˆä»ç½‘ç‚¹æ•°æ®ä¸­è¯»å–é®ç½©å†…å®¹ï¼‰
    function updateMaskOverlay(locations) {
      const maskOverlay = document.getElementById('mask-overlay');
      if (!maskOverlay) return;
      
      // æŸ¥æ‰¾æœ€åä¸€ä¸ªæœ‰é®ç½©å†…å®¹çš„ç½‘ç‚¹
      let maskText = '';
      for (let i = locations.length - 1; i >= 0; i--) {
        if (locations[i].mask && locations[i].mask.trim()) {
          maskText = locations[i].mask.trim();
          break;
        }
      }
      
      // æ›´æ–°é®ç½©å±‚ï¼ˆæ‚¬æµ®åœ¨æ§åˆ¶é¢æ¿ä¸Šæ–¹ï¼‰
      if (maskText) {
        maskOverlay.textContent = maskText;
        maskOverlay.style.display = 'block';
        // è°ƒæ•´æ§åˆ¶é¢æ¿ä½ç½®ï¼Œé¿å…è¢«é®ç½©å±‚é®æŒ¡
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          const maskHeight = maskOverlay.offsetHeight || 50;
          controlPanel.style.top = (20 + maskHeight + 10) + 'px';
        }
      } else {
        maskOverlay.style.display = 'none';
        maskOverlay.textContent = '';
        // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          controlPanel.style.top = '20px';
        }
      }
    }

    // æˆªå›¾åŠŸèƒ½
    async function captureScreenshot(groupName = '', employeeId = '', employeeName = '', adjustment = '', locationsForMask = null) {
      // è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œæˆªå›¾å‰éšè—æ‰‹åŠ¨æˆªå›¾é¢æ¿
      const manualPanel = document.getElementById('manual-screenshot-panel');
      if (debugMode && manualPanel) {
        manualPanel.style.display = 'none';
      }
      
      // è·å–å½“å‰çš„UIçŠ¶æ€ï¼ˆå¤é€‰æ¡†çŠ¶æ€ï¼‰
      const uiState = {
        showFarthestLine: document.getElementById('toggleFarthest')?.checked ?? true,
        showDistanceLabels: document.getElementById('toggleDistanceLabels')?.checked ?? false,
        showRouteSimple: document.getElementById('toggleRouteSimple')?.checked ?? true
      };
      
      // åˆ¤æ–­æ˜¯å¦ä¸ºè¡Œæ”¿åŒºå›¾
      const isDistrictMap = groupName === '__DISTRICT_MAP__';
      const isDistrictMapOnly = groupName === '__DISTRICT_MAP_ONLY__';
      
      // è·å–é®ç½©å†…å®¹
      let maskText = '';
      if (isDistrictMap) {
        // å¦‚æœæ˜¯è¡Œæ”¿åŒºå›¾ï¼Œæ˜¾ç¤º"å·¥å·-å§“å-è¡Œæ”¿åŒºå›¾"
        if (employeeId && employeeId.trim() && employeeName && employeeName.trim()) {
          maskText = `${employeeId}-${employeeName}-è¡Œæ”¿åŒºå›¾`;
        } else {
          maskText = 'è¡Œæ”¿åŒºå›¾';
        }
      } else if (isDistrictMapOnly) {
        // å¦‚æœæ˜¯ä»…è¡Œæ”¿åŒºå›¾ï¼Œæ˜¾ç¤º"ä»…è¡Œæ”¿åŒºå›¾"
        maskText = 'ä»…è¡Œæ”¿åŒºå›¾';
      } else {
        // æ™®é€šç½‘ç»„å›¾ï¼Œä¼˜å…ˆä»ä¼ å…¥çš„locationsä¸­è·å–é®ç½©å†…å®¹ï¼ˆå½“å‰ç»˜åˆ¶çš„ç½‘ç»„æ•°æ®ï¼‰
        let locationsToCheck = locationsForMask;
        if (!locationsToCheck || locationsToCheck.length === 0) {
          // å¦‚æœæ²¡æœ‰ä¼ å…¥locationsï¼Œåˆ™ä½¿ç”¨å…¨å±€çš„currentLocationsæˆ–è§£æè¾“å…¥
          locationsToCheck = currentLocations.length ? currentLocations : parseLocationData();
        }
        
        // ä»locationsä¸­æŸ¥æ‰¾æœ€åä¸€ä¸ªæœ‰é®ç½©å†…å®¹çš„ç½‘ç‚¹
        for (let i = locationsToCheck.length - 1; i >= 0; i--) {
          if (locationsToCheck[i].mask && locationsToCheck[i].mask.trim()) {
            maskText = locationsToCheck[i].mask.trim();
            break;
          }
        }
      }
      
      // ç¡®ä¿é®ç½©å±‚æ˜¾ç¤ºï¼ˆå¦‚æœæœ‰é®ç½©å†…å®¹ï¼‰
      if (maskText) {
        // ç›´æ¥è®¾ç½®é®ç½©å†…å®¹
        const maskOverlay = document.getElementById('mask-overlay');
        if (maskOverlay) {
          maskOverlay.textContent = maskText;
          maskOverlay.style.display = 'block';
          // è°ƒæ•´æ§åˆ¶é¢æ¿ä½ç½®ï¼Œé¿å…è¢«é®ç½©å±‚é®æŒ¡
          const controlPanel = document.getElementById('control-panel');
          if (controlPanel) {
            const maskHeight = maskOverlay.offsetHeight || 50;
            controlPanel.style.top = (20 + maskHeight + 10) + 'px';
          }
        }
        // ç­‰å¾…é®ç½©å±‚æ˜¾ç¤ºå®Œæˆ
        await new Promise(resolve => setTimeout(resolve, 300));
      } else {
        // å¦‚æœæ²¡æœ‰é®ç½©å†…å®¹ï¼Œéšè—é®ç½©å±‚
        const maskOverlay = document.getElementById('mask-overlay');
        if (maskOverlay) {
          maskOverlay.style.display = 'none';
        }
        // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          controlPanel.style.top = '20px';
        }
      }
      const displayName = isDistrictMap ? 'è¡Œæ”¿åŒºå›¾' : (isDistrictMapOnly ? 'ä»…è¡Œæ”¿åŒºå›¾' : (groupName ? 'ç½‘ç»„ ' + groupName : ''));
      
      // æ˜¾ç¤ºæˆªå›¾æç¤ºåœ¨çŠ¶æ€åŒºåŸŸï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
      updateStatus(`ğŸ“¸ æ­£åœ¨æˆªå›¾${displayName}...`, 'loading');
      
      // è®¾ç½®è¶…æ—¶å¤„ç†ï¼ˆ30ç§’è¶…æ—¶ï¼‰
      const timeoutId = setTimeout(() => {
        updateStatus('âŒ æˆªå›¾è¶…æ—¶ï¼ˆ30ç§’ï¼‰ï¼Œè¯·æ£€æŸ¥Edgeæµè§ˆå™¨å’Œç½‘ç»œè¿æ¥', 'error');
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
      }, 30000);
      
      try {
        const controller = new AbortController();
        const timeoutSignal = setTimeout(() => controller.abort(), 30000);
        
        const resp = await fetch('/capture_screenshot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ui_state: uiState,
            group_name: groupName,
            employee_id: employeeId,
            employee_name: employeeName,
            adjustment: adjustment,
            mask_text: maskText,
            debug_mode: debugMode
          }),
          signal: controller.signal
        });
        
        clearTimeout(timeoutSignal);
        clearTimeout(timeoutId);
        
        const data = await resp.json();
        
        // æ›´æ–°çŠ¶æ€åŒºåŸŸï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
        if (data.error) {
          updateStatus(`âŒ æˆªå›¾å¤±è´¥ï¼š${data.error}`, 'error');
          // æˆªå›¾å®Œæˆåï¼Œéšè—é®ç½©å±‚
          const maskOverlay = document.getElementById('mask-overlay');
          if (maskOverlay) {
            maskOverlay.style.display = 'none';
            maskOverlay.textContent = '';
          }
          // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
          const controlPanel = document.getElementById('control-panel');
          if (controlPanel) {
            controlPanel.style.top = '20px';
          }
          // è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œæ¢å¤æ‰‹åŠ¨æˆªå›¾é¢æ¿æ˜¾ç¤º
          const manualPanelError = document.getElementById('manual-screenshot-panel');
          if (debugMode && manualPanelError) {
            manualPanelError.style.display = '';
          }
          // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
          setTimeout(() => {
            updateStatus('å°±ç»ª', 'ready');
          }, 10000);
          return;
        }
        
        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        updateStatus(`âœ… æˆªå›¾å·²ä¿å­˜: ${data.filename}`, 'success');
        
        // æˆªå›¾å®Œæˆåï¼Œéšè—é®ç½©å±‚
        const maskOverlay = document.getElementById('mask-overlay');
        if (maskOverlay) {
          maskOverlay.style.display = 'none';
          maskOverlay.textContent = '';
        }
        // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          controlPanel.style.top = '20px';
        }
        
        // è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œæ¢å¤æ‰‹åŠ¨æˆªå›¾é¢æ¿æ˜¾ç¤º
        const manualPanelSuccess = document.getElementById('manual-screenshot-panel');
        if (debugMode && manualPanelSuccess) {
          manualPanelSuccess.style.display = '';
        }
        
        // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
        
        console.log('æˆªå›¾ä¿å­˜æˆåŠŸ:', data.filepath);
      } catch (e) {
        clearTimeout(timeoutId);
        
        // æ›´æ–°çŠ¶æ€åŒºåŸŸæ˜¾ç¤ºé”™è¯¯ï¼ˆä¸å½±å“è·¯çº¿è¯¦æƒ…é¡µï¼‰
        if (e.name === 'AbortError') {
          updateStatus('âŒ æˆªå›¾è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥Edgeæµè§ˆå™¨å’Œç½‘ç»œè¿æ¥', 'error');
        } else {
          updateStatus(`âŒ æˆªå›¾å¤±è´¥ï¼š${e.message || String(e)}`, 'error');
        }
        // æˆªå›¾å®Œæˆåï¼Œéšè—é®ç½©å±‚
        const maskOverlay = document.getElementById('mask-overlay');
        if (maskOverlay) {
          maskOverlay.style.display = 'none';
          maskOverlay.textContent = '';
        }
        // æ¢å¤æ§åˆ¶é¢æ¿ä½ç½®
        const controlPanel = document.getElementById('control-panel');
        if (controlPanel) {
          controlPanel.style.top = '20px';
        }
        // è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œæ¢å¤æ‰‹åŠ¨æˆªå›¾é¢æ¿æ˜¾ç¤º
        const manualPanelCatch = document.getElementById('manual-screenshot-panel');
        if (debugMode && manualPanelCatch) {
          manualPanelCatch.style.display = '';
        }
        
        // 10ç§’åæ¢å¤å°±ç»ªçŠ¶æ€
        setTimeout(() => {
          updateStatus('å°±ç»ª', 'ready');
        }, 10000);
        console.error('æˆªå›¾è¯·æ±‚å¤±è´¥:', e);
      }
    }
  </script>
</body>
</html>
</html>